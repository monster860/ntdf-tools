<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script src="FileSaver.js"></script>
<script src="three.min.js"></script>
<script>
let logging_enabled = true;
function do_log(...args) {
	if(logging_enabled) console.log(...args);
}

THREE.ShaderChunk.color_pars_vertex = `
#ifdef USE_COLOR
	varying vec4 vColor;
	attribute float alpha;
#endif
`;
THREE.ShaderChunk.color_vertex = `
#ifdef USE_COLOR
	vColor.xyz = color.xyz;
	vColor.w = alpha;
#endif
`;
THREE.ShaderChunk.color_pars_fragment = `
#ifdef USE_COLOR
	varying vec4 vColor;
#endif
`;
THREE.ShaderChunk.color_fragment = `
#ifdef USE_COLOR
	diffuseColor.rgba *= vColor.rgba;
	
#endif
`;
const file_sectors = [0x00000000, 0x0000003A, 0x00000074, 0x000000AE, 0x000000F8, 0x000000F8, 0x000000F8, 0x000000F8, 0x00000260, 0x00000260, 0x00000545, 0x000006F8, 0x000008B0, 0x00000A5C, 0x00000C17, 0x00000DD8, 0x00000F94, 0x00001147, 0x00001300, 0x00001493, 0x00001649, 0x0000181F, 0x000019AD, 0x00001B6D, 0x00001D03, 0x00001EA6, 0x00002049, 0x000021FE, 0x000023A0, 0x0000254A, 0x000026EA, 0x00002876, 0x00002A01, 0x00002B64, 0x00002D12, 0x00002E8C, 0x00003019, 0x000031D2, 0x00003375, 0x00003518, 0x000036AB, 0x0000384F, 0x00003A0F, 0x00003BBF, 0x00003D5F, 0x00003F16, 0x000040CD, 0x0000427F, 0x00004444, 0x000045ED, 0x0000478A, 0x0000492A, 0x00004AB6, 0x00004C5D, 0x00004DFE, 0x00004F8D, 0x00005122, 0x000052F0, 0x000054C6, 0x0000567B, 0x000057F3, 0x000059A4, 0x00005B64, 0x00005D08, 0x00005EC8, 0x00006088, 0x00006248, 0x000063F4, 0x000065C7, 0x0000676A, 0x00006908, 0x00006AA8, 0x00006C7B, 0x00006E4E, 0x00007019, 0x0000719D, 0x0000735E, 0x00007511, 0x000076C4, 0x0000786D, 0x00007A20, 0x00007BD4, 0x00007D8B, 0x00007F3A, 0x000080ED, 0x000082AB, 0x0000843E, 0x000085F4, 0x000087BA, 0x00008948, 0x00008B03, 0x00008C99, 0x00008E3C, 0x00008FE0, 0x00009195, 0x00009336, 0x000094DE, 0x0000967E, 0x0000980A, 0x00009995, 0x00009AF8, 0x00009CAE, 0x00009E28, 0x00009FB5, 0x0000A16E, 0x0000A30B, 0x0000A4A8, 0x0000A63B, 0x0000A7DF, 0x0000A99F, 0x0000AB4F, 0x0000ACEF, 0x0000AEA4, 0x0000B059, 0x0000B20A, 0x0000B3C0, 0x0000B569, 0x0000B706, 0x0000B8A6, 0x0000BA32, 0x0000BBD9, 0x0000BD79, 0x0000BF08, 0x0000C09D, 0x0000C26B, 0x0000C42E, 0x0000C5E3, 0x0000C75B, 0x0000C909, 0x0000CAC6, 0x0000CC6A, 0x0000CE2A, 0x0000CFEA, 0x0000D1AA, 0x0000D349, 0x0000D51C, 0x0000D6BF, 0x0000D85D, 0x0000D9FD, 0x0000DBD0, 0x0000DDA3, 0x0000DF6E, 0x0000E0F2, 0x0000E2B3, 0x0000E466, 0x00010BAE, 0x000118AD, 0x00011CFA, 0x0001211F, 0x00012544, 0x00012905, 0x00012E7E, 0x0001323F, 0x0001368C, 0x00013A25, 0x00013E36, 0x000141E3, 0x00014590, 0x00014A55, 0x00014E3E, 0x0001515F, 0x00015520, 0x00015981, 0x00015D92, 0x0001627F, 0x0001676C, 0x00016BCD, 0x00017092, 0x00017543, 0x00017990, 0x00017DDD, 0x00018216, 0x00018663, 0x00018A24, 0x00018F9D, 0x0001935E, 0x0001971F, 0x00019AE0, 0x00019E79, 0x0001A23A, 0x0001A64B, 0x0001ADB8, 0x0001B525, 0x0001BC92, 0x0001BF27, 0x0001C1BC, 0x0001C929, 0x0001D096, 0x0001D42F, 0x0001D7C8, 0x0001DF35, 0x0001E256, 0x0001E437, 0x0001E974, 0x0001ED85, 0x0001F196, 0x0001F43F, 0x0001F850, 0x0001FD8D, 0x000203A6, 0x000209BF, 0x00020D80, 0x000211CD, 0x000215F2, 0x00021A17, 0x00021DD8, 0x00022351, 0x00022712, 0x00022B5F, 0x00022FE8, 0x000233F9, 0x00023882, 0x00023D33, 0x000241F8, 0x00024645, 0x00024966, 0x00024E17, 0x00025278, 0x00025689, 0x00025AD6, 0x00025FC3, 0x00026424, 0x000268E9, 0x00026D9A, 0x000271E7, 0x00027634, 0x00027A6D, 0x00027EBA, 0x00028343, 0x00028754, 0x00028BA1, 0x00028FEE, 0x0002949F, 0x00029838, 0x00029BF9, 0x0002A00A, 0x0002A457, 0x0002A8A4, 0x0002ACF1, 0x0002AF86, 0x0002B21B, 0x0002B668, 0x0002BAB5, 0x0002BE4E, 0x0002C1E7, 0x0002C954, 0x0002CC75, 0x0002D126, 0x0002D663, 0x0002DA74, 0x0002DE85, 0x0002E12E, 0x0002E53F, 0x0002EA7C, 0x0002F095, 0x0002F6AE, 0x0002FB37, 0x0002FB5E, 0x0002FB86, 0x0002FB9C, 0x0002FBB6, 0x0002FBDD, 0x0002FC12, 0x0002FC31, 0x0002FC59, 0x0002FC79, 0x0002FC8E, 0x0002FCAE, 0x0002FCD6, 0x0002FCFC, 0x0002FD1B, 0x0002FD37, 0x0002FD62, 0x0002FD79, 0x0002FD91, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FE13, 0x0002FE27, 0x0002FE3E, 0x0002FE73, 0x0002FEA2, 0x0002FEC5, 0x0002FF02, 0x0002FF23, 0x0002FF58, 0x0002FF5A, 0x0002FF5C, 0x0002FF5E, 0x0002FF60, 0x0002FF96, 0x0002FFC8, 0x0002FFF9, 0x00030024, 0x0003005D, 0x000300BB, 0x0003010F, 0x00030173, 0x000301AA, 0x000301E0, 0x00030217, 0x0003024F, 0x00030286, 0x000302B6, 0x000302E6, 0x0003031C, 0x00030350, 0x0003037C, 0x000303B5, 0x000303E4, 0x00030417, 0x00030419, 0x0003044C, 0x0003047E, 0x000304E3, 0x000304E5, 0x00030519, 0x00030587, 0x000305DC, 0x00030627, 0x00030629, 0x000306EB, 0x0003071E, 0x00030751, 0x000307A6, 0x000307B5, 0x000307D7, 0x000307DE, 0x000307F4, 0x00030830, 0x0003086C, 0x000308A8, 0x000308B7, 0x000308D7, 0x00030905, 0x0003093D, 0x00030954, 0x00030976, 0x00030982, 0x0003098F, 0x0003099B, 0x000309C2, 0x000309F2, 0x00030A00, 0x00030A2C, 0x00030A4E, 0x00030A7F, 0x00030A84, 0x00030A99, 0x00030AB1, 0x00030AB6, 0x00030ACB, 0x00030AE3, 0x00030AF6, 0x00030B29, 0x00030B4C, 0x00030B63, 0x00030B76, 0x00030BA7, 0x00030BB6, 0x00030BBD, 0x00030BEE, 0x00030C21, 0x00030C4E, 0x00030C80, 0x00030C9F, 0x00030CAF, 0x00030CB5, 0x00030CE5, 0x00030D17, 0x00030D48, 0x00030D60, 0x00030D91, 0x00030DBB, 0x00030DE9, 0x00030DF6, 0x00030E0E, 0x00030E2C, 0x00030E4A, 0x00030E78, 0x00030E7D, 0x00030E99, 0x00030EAE, 0x00030ECA, 0x00030EE6, 0x00030EEB, 0x00030EEF, 0x00030EF3, 0x00030EF8, 0x00030EFE, 0x00030F02, 0x00030F18, 0x00030F2B, 0x00030F47, 0x00030F67, 0x00030F8A, 0x00030FAF, 0x00030FCE, 0x00030FF2, 0x00031010, 0x0003102D, 0x0003104B, 0x00031069, 0x00031087, 0x000310A5, 0x000310C3, 0x000310E6, 0x00031109, 0x0003112C, 0x0003114D, 0x00031173, 0x00031199, 0x000311BC, 0x000311E0, 0x00031204, 0x00031230, 0x0003124C, 0x00031264, 0x0003127C, 0x0003129D, 0x000312B8, 0x000312D1, 0x000312D3, 0x000314C2, 0x000314C3, 0x0003151F, 0x00031520, 0x0003157C, 0x0003157D, 0x00031740, 0x00031741, 0x000317D3, 0x000317D4, 0x0003184F, 0x000318F0, 0x0003199C, 0x00031A44, 0x00031AE8, 0x00031B9A, 0x00031C49, 0x00031D09, 0x00031DAD, 0x00031E7D, 0x00031F56, 0x0003202B, 0x00032103, 0x000321E6, 0x000322BE, 0x0003239D, 0x0003243D, 0x0003243E, 0x0003243F, 0x00032440, 0x00032441, 0x00032442, 0x00032443, 0x0003259E, 0x0003259F, 0x000325E9, 0x000325EF, 0x00032692, 0x0003269F, 0x000327F3, 0x0003282A, 0x000328DB, 0x000329C6, 0x00032A82, 0x00032B12, 0x00032B6D, 0x00032BD3, 0x00032C61, 0x00032D3F, 0x00032E1D, 0x00032E7D, 0x00032E83, 0x00032E8A, 0x00032E92, 0x00032EA4, 0x00032EB2, 0x00032EBE, 0x00032ECA, 0x00032ED0, 0x00032ED7, 0x00032EE8, 0x00032EFE, 0x00032F07, 0x00032F16, 0x00032F25, 0x00032F3D, 0x00032F48, 0x00032F53, 0x00032F62, 0x00032F78, 0x00032F87, 0x00032F96, 0x00032FA1, 0x00032FB3, 0x00032FC5, 0x00032FCC, 0x00032FDA, 0x00032FE9, 0x00032FF6, 0x00032FFE, 0x0003300E, 0x0003301E, 0x00033028, 0x00034A48, 0x00034AC9, 0x00034B4A, 0x00034BCB, 0x00034C4C, 0x00034CCD, 0x00034D4E, 0x00034DCF, 0x00034E50, 0x00034ED1, 0x00034F52, 0x00034FD3, 0x00035054, 0x000350D5, 0x00035156, 0x000351D7, 0x00035258, 0x000352D9, 0x0003531A, 0x0003539B, 0x0003541C, 0x0003549D, 0x0003551E, 0x0003559F, 0x00035620, 0x000356A1, 0x00035722, 0x000357A3, 0x00035824, 0x000358A5, 0x00035926, 0x000359A7, 0x00035A28, 0x00035AA9, 0x00035B2A, 0x00035BAB, 0x00035C2C, 0x00035CAD, 0x00035D2E, 0x00035DAF, 0x00035E30, 0x00035EB1, 0x00035F32, 0x00035FB3, 0x00036034, 0x000360B5, 0x00036136, 0x000361B7, 0x00036238, 0x000362B9, 0x0003633A, 0x000363BB, 0x0003643C, 0x000364BD, 0x0003653E, 0x000365BF, 0x00036640, 0x000366C1, 0x00036742, 0x000367C3, 0x00036844, 0x000368C5, 0x00036946, 0x000369C7, 0x00036A48, 0x00036AC9, 0x00036B4A, 0x00036BCB, 0x00036C4C, 0x00036CCD, 0x00036D4E, 0x00036DCF, 0x00036E50, 0x00036ED1, 0x00036F52, 0x00036FD3, 0x00037054, 0x000370D5, 0x00037156, 0x000371D7, 0x00037258, 0x000372D9, 0x0003735A, 0x000373DB, 0x0003745C, 0x000374DD, 0x0003755E, 0x000375DF, 0x00037660, 0x000376E1, 0x00037762, 0x000377E3, 0x00037864, 0x000378E5, 0x00037966, 0x000379E7, 0x00037A68, 0x00037AE9, 0x00037B6A, 0x00037BEB, 0x00037C6C, 0x00037CED, 0x00038115, 0x0003859D, 0x00038905, 0x00038BC9, 0x00038E34, 0x00038F7D, 0x0003975A, 0x00039F9B, 0x0003A3C3, 0x0003A84B, 0x0003ABB3, 0x0003AE77, 0x0003B0E2, 0x0003B50A, 0x0003B992, 0x0003BCFA, 0x0003BFBE, 0x0003C229, 0x0003CA6C, 0x0003CAEA, 0x0003CB68, 0x0003D365, 0x0003D523, 0x0003D678, 0x0003DC65, 0x0003E191, 0x0003E7F6, 0x0003ECB4, 0x0003F457, 0x0003F55C, 0x0003F5E4, 0x0003F66C, 0x0003F787, 0x0003F8A2, 0x0003F92A, 0x0003FDFD, 0x000404F1, 0x0004069C, 0x00040842, 0x00040AA8, 0x00040DE9, 0x00040ECD, 0x00040F88, 0x00041402, 0x00041C88, 0x00041CF1, 0x000420B7, 0x0004247D, 0x000429EB, 0x00042AC5, 0x00042BD1, 0x00042CF6, 0x00042D9B, 0x00043406, 0x00043B3A, 0x00043CC6, 0x00043DEA, 0x00044F20, 0x0004516F, 0x000453C1, 0x000456AF, 0x0004599D, 0x00045AD7, 0x00045C13, 0x0004609E, 0x000462E3, 0x0004646F, 0x00046914, 0x00046B1F, 0x00046C2B, 0x00047082, 0x0004767C, 0x00047BDF, 0x00047CA1, 0x0004815A, 0x00048C62, 0x0004901B, 0x00049258, 0x00049449, 0x0004A4AB, 0x0004B20E, 0x0004B271, 0x0004B46F, 0x0004B66D, 0x0004B878, 0x0004BACA, 0x0004BCDD, 0x0004BE84, 0x0004C091, 0x0004C29E, 0x0004C434, 0x0004C64B, 0x0004C758, 0x0004C891, 0x0004DB83, 0x0004DCBF, 0x0004DF96, 0x0004E07F, 0x0004E5A8, 0x0004F19E, 0x0004F383, 0x0004F568, 0x0004F833, 0x0004F91C, 0x0004FE31, 0x000502C4, 0x0005051A, 0x0005065D, 0x00050A14, 0x00050D9F, 0x00051236, 0x000517A0, 0x00052683, 0x00052A28, 0x00052F8F, 0x00053617, 0x0005389F, 0x000539EB, 0x0005452B, 0x000545B0, 0x00054677, 0x00054884, 0x00054FAE, 0x00055327, 0x000553A8, 0x00055430, 0x00055799, 0x00055989, 0x00055B7F, 0x00055D71, 0x00055F04, 0x0005612D, 0x00056245, 0x0005635D, 0x00056475, 0x0005658D, 0x000566A5, 0x000566A6, 0x00056B39, 0x00056C51, 0x00056D69, 0x00056E81, 0x00056F99, 0x000570B1, 0x000583AA, 0x00058839, 0x00058944, 0x00058B66, 0x00058FF1, 0x0005936A, 0x00059483, 0x0005959C, 0x00059791, 0x00059BA7, 0x00059C30, 0x00059CB9, 0x0005A035, 0x0005A1D7, 0x0005A379, 0x0005A78E, 0x0005A97E, 0x0005AB6E, 0x0005AD5E, 0x0005AF4E, 0x0005BA3F, 0x0005C25F, 0x0005C8BB, 0x0005CE58, 0x0005D3DD, 0x0005D4C4, 0x0005DAD0, 0x0005E12C, 0x0005E1E2, 0x0005E8B1, 0x0005E96B, 0x0005EA25, 0x0005EADF, 0x0005EF11, 0x0005F3A5, 0x0005F822, 0x0005FCCD, 0x0005FFF8, 0x0005FFF9, 0x00060462, 0x00060608, 0x00060916, 0x00061B8C, 0x00061DF8, 0x0006213C, 0x0006224E, 0x00062352, 0x00062548, 0x0006265A, 0x0006278C, 0x00062880, 0x0006298C, 0x00062D33, 0x00062EB0, 0x0006303D, 0x0006314F, 0x00063281, 0x00063A40, 0x00064657, 0x00064CEC, 0x00064F42, 0x0006503F, 0x0006513C, 0x0006528F, 0x00065CA5, 0x0006620C, 0x0006653A, 0x00066803, 0x0006688B, 0x000669E0, 0x00066C80, 0x00067D5D, 0x00067DEB, 0x00067FA7, 0x00068154, 0x0006826F, 0x0006853F, 0x00068626, 0x0006870D, 0x000689CD, 0x00068AD2, 0x00068B4F, 0x00068BCC, 0x00068BCD, 0x00069615, 0x00069616, 0x00069694, 0x0006A32D, 0x0006A3EE, 0x0006A4AD, 0x0006A510, 0x0006A9C6, 0x0006AAE1, 0x0006ABFC, 0x0006AD17, 0x0006AE32, 0x0006AF4D, 0x0006B068, 0x0006B162, 0x0006B25C, 0x0006B356, 0x0006B450, 0x0006B54A, 0x0006B644, 0x0006B72B, 0x0006B812, 0x0006B8F9, 0x0006B9E0, 0x0006BAC7, 0x0006BBAE, 0x0006BC95, 0x0006BD7C, 0x0006CCB6, 0x0006CEAA, 0x0006D09A, 0x0006D177, 0x0006D254, 0x0006D2DF, 0x0006D3A5, 0x0006D54E, 0x0006D959, 0x0006DC37, 0x0006DD4D, 0x0006DE5F, 0x0006E0E1, 0x0006E7EC, 0x0006E8DF, 0x0006EB9F, 0x0006EC95, 0x0006F0B9, 0x0006F3B4, 0x0006F6AF, 0x0006F9AA, 0x0006FB31, 0x00070ED3, 0x00070F7B, 0x000710A2, 0x000711C8, 0x000712AE, 0x000713CB, 0x000714CF, 0x000715D3, 0x00071853, 0x00071971, 0x00071C88, 0x00071EA2, 0x00072084, 0x00072361, 0x00073703, 0x000737AB, 0x000738D2, 0x000739F8, 0x00073ADE, 0x00073BFB, 0x00073CFF, 0x00073E03, 0x00074083, 0x000741A1, 0x000744B8, 0x000746D2, 0x000748B4, 0x00074B91, 0x00074FB0, 0x00076139, 0x0007720C, 0x00077641, 0x00077763, 0x00077D2C, 0x00078C66, 0x00079E74, 0x00079F69, 0x0007A0A6, 0x0007A161, 0x0007A29A, 0x0007A59E, 0x0007A8CE, 0x0007AADB, 0x0007ADD8, 0x0007B0A9, 0x0007B188, 0x0007B386, 0x0007BB8B, 0x0007BBBC, 0x0007BFCA, 0x0007C103, 0x0007C23C, 0x0007C5F9, 0x0007C709, 0x0007C819, 0x0007CDAD, 0x0007CE73, 0x0007CF39, 0x0007D2E6, 0x0007D4A7, 0x0007D668, 0x0007DCAC, 0x0007E04F, 0x0007E3F2, 0x0007E8D8, 0x0007E9DC, 0x0007EAE0, 0x0007FD00, 0x0007FDDD, 0x0007FECA, 0x00080024, 0x000801DB, 0x0008037A, 0x000804C9, 0x00080767, 0x00080949, 0x00080B5D, 0x00080D73, 0x00080F6A, 0x0008118F, 0x000813A7, 0x0008154E, 0x00081604, 0x00081805, 0x00081A8E, 0x00081C70, 0x00081E49, 0x00081FEA, 0x0008222C, 0x0008246A, 0x0008266C, 0x000828AB, 0x000829BF, 0x00082AFC, 0x00082BFD, 0x00082CFF, 0x00082DF5, 0x00082F0B, 0x0008301F, 0x00083077, 0x0008405C, 0x000842D5, 0x0008454E, 0x00084853, 0x00084ACC, 0x00084BD0, 0x00084C5D, 0x00084D8A, 0x0008507D, 0x00085370, 0x00085BF6, 0x00085C80, 0x00085EE0, 0x0008641D, 0x00086522, 0x0008665E, 0x0008679A, 0x0008692E, 0x00087852, 0x000879BA, 0x00087B22, 0x0008876A, 0x00089D0A, 0x0008A09F, 0x0008B7C3, 0x0008C4BF, 0x0008C4ED, 0x0008D058, 0x0008D32B, 0x0008D725, 0x0008DB21, 0x0008E066, 0x0008E5AB, 0x0008EC2F, 0x0008FF4A, 0x0009122D, 0x00091352, 0x0009147F, 0x000915AA, 0x000916E0, 0x000927E0, 0x000927E1, 0x000936F2, 0x0009384A, 0x000939A2, 0x00093CF0, 0x00093E02, 0x00093F1F, 0x0009403C, 0x00094145, 0x00094350, 0x000946FC, 0x00094AE4, 0x00094D6D, 0x00094E71, 0x00094F75, 0x0009506B, 0x00095170, 0x00095304, 0x00095424, 0x00095533, 0x00095653, 0x000959CA, 0x00095AC0, 0x00095AC1, 0x00095C36, 0x0009632B, 0x00096745, 0x000969EB, 0x00096E23, 0x00096F7C, 0x00097107, 0x00097247, 0x00097E8F, 0x000981A3, 0x000986BD, 0x000986BE, 0x00098927, 0x00098A3D, 0x00098B53, 0x000990A4, 0x000991A9, 0x000992AE, 0x00099992, 0x00099DC6, 0x00099ED0, 0x00099FDA, 0x0009A389, 0x0009A464, 0x0009A53F, 0x0009A61A, 0x0009A6F5, 0x0009AE2D, 0x0009AFAF, 0x0009B722, 0x0009B826, 0x0009BAD4, 0x0009BBD9, 0x0009BCF4, 0x0009BE12, 0x0009BFE4, 0x0009C0FD, 0x0009C21C, 0x0009C3BF, 0x0009C49E, 0x0009C5B7, 0x0009C6D3, 0x0009CCB2, 0x0009D22F, 0x0009D363, 0x0009D4BA, 0x0009D5BF, 0x0009D6DF, 0x0009D7C6, 0x0009DC4D, 0x0009EC05, 0x0009F13B, 0x0009F4CA, 0x000A0431, 0x000A08C6, 0x000A0DDB, 0x000A1115, 0x000A156F, 0x000A16B2, 0x000A18A2, 0x000A19BB, 0x000A1B6E, 0x000A1D2F, 0x000A2EA8, 0x000A3049, 0x000A32FD, 0x000A35B1, 0x000A38F7, 0x000A3A68, 0x000A3D15, 0x000A3FC2, 0x000A4165, 0x000A4308, 0x000A4364, 0x000A43C0, 0x000A4529, 0x000A4699, 0x000A4946, 0x000A4BF3, 0x000A4D99, 0x000A4F3F, 0x000A5156, 0x000A51CD, 0x000A549E, 0x000A57A8, 0x000A5A55, 0x000A5D02, 0x000A5D5E, 0x000A5F08, 0x000A60B2, 0x000A6117, 0x000A6177, 0x000A631A, 0x000A64BD, 0x000A6565, 0x000A65E0, 0x000A7467, 0x000A7592, 0x000A76CA, 0x000A7A56, 0x000A7B60, 0x000A7C6A, 0x000A7D96, 0x000A7EC2, 0x000A8411, 0x000A851E, 0x000A862F, 0x000A873C, 0x000A8849, 0x000A96C4, 0x000A9BC0, 0x000AA0BE, 0x000AA395, 0x000AAA24, 0x000AABAF, 0x000AAD3A, 0x000AAD3B, 0x000AB75D, 0x000ABB1C, 0x000ABB7B, 0x000ABBD9, 0x000ABDDF, 0x000ABDE0, 0x000ACDBF, 0x000ADBC8, 0x000AEF30, 0x000AFF70, 0x000B10F6, 0x000B20B0, 0x000B3605, 0x000B388F, 0x000B3890, 0x000B455A, 0x000B4668, 0x000B4B10, 0x000B4EAA, 0x000B5AC4, 0x000B5C00, 0x000B5F1C, 0x000B627B, 0x000B6707, 0x000B68FB, 0x000B6EF6, 0x000B7542, 0x000B7637, 0x000B7BA5, 0x000B7D4F, 0x000B7EEB, 0x000B8715, 0x000B8C69, 0x000B8EAA, 0x000B90D8, 0x000B9142, 0x000B9285, 0x000B9705, 0x000B9B31, 0x000B9D94, 0x000BA08F, 0x000BA38A, 0x000BA712, 0x000BA9B6, 0x000BAEA0, 0x000BB365, 0x000BB7DE, 0x000BBCF3, 0x000BC124, 0x000BC56F, 0x000BC9DE, 0x000BCDAA, 0x000BD142, 0x000BD6AD, 0x000BDC75, 0x000BDF2B, 0x000BE304, 0x000BE7A1, 0x000BEB23, 0x000BEE22, 0x000BF017, 0x000BF53C, 0x000C043B, 0x000C04F9, 0x000C05BD, 0x000C064D, 0x000C075C, 0x000C086B, 0x000C097A, 0x000C0A89, 0x000C0B8D, 0x000C0C91, 0x000C0D95, 0x000C0EAA, 0x000C0FBF, 0x000C10D4, 0x000C11E9, 0x000C15E5, 0x000C1721, 0x000C1B69, 0x000C229C, 0x000C2524, 0x000C27A7, 0x000C28CE, 0x000C312B, 0x000C42F7, 0x000C49A1, 0x000C4DCA, 0x000C4EEF, 0x000C5936, 0x000C59AA, 0x000C5EAD, 0x000C5F0F, 0x000C5F78, 0x000C64E0, 0x000C65EF, 0x000C66F3, 0x000C794A, 0x000C7CE7, 0x000C7F74, 0x000C831E, 0x000C841F, 0x000C8513, 0x000C85F2, 0x000C8801, 0x000C8905, 0x000C8E13, 0x000C9093, 0x000C9313, 0x000C9593, 0x000C96A8, 0x000C9988, 0x000CA880, 0x000CAF7D, 0x000CB751, 0x000CC7F2, 0x000CCC28, 0x000CCE20, 0x000CD33B, 0x000CD55E, 0x000CE55B, 0x000CEB0D, 0x000CEE15, 0x000CF01F, 0x000CF1EB, 0x000D0413, 0x000D089A, 0x000D099B, 0x000D0B87, 0x000D0DF9, 0x000D0E79, 0x000D1779, 0x000D1CF6, 0x000D2943, 0x000D2D64, 0x000D30D5, 0x000D327C, 0x000D35D4, 0x000D38F9, 0x000D3A0B, 0x000D3E06, 0x000D43DC, 0x000D4830, 0x000D50D3, 0x000D5F2C, 0x000D60EA, 0x000D64FA, 0x000D68FD, 0x000D6CF7, 0x000D7107, 0x000D74B4, 0x000D78B4, 0x000D7B9D, 0x000D7D81, 0x000D8D3D, 0x000D99C1, 0x000DA016, 0x000DA230, 0x000DA3B0, 0x000DB6A6, 0x000DC3B4, 0x000DC55A, 0x000DC5B6, 0x000DC61A, 0x000DC773, 0x000DC893, 0x000DC9F9, 0x000DCB93, 0x000DCC94, 0x000DCEA7, 0x000DCF7E, 0x000DD247, 0x000DD46C, 0x000DDBB1, 0x000DE2B6, 0x000DE88A, 0x000DF247, 0x000DF5F9, 0x000DFAB0, 0x000DFDA5, 0x000DFEBD, 0x000E0246, 0x000E0360, 0x000E0534, 0x000E062E, 0x000E077E, 0x000E08A4, 0x000E0C8D, 0x000E0D92, 0x000E102D, 0x000E16A7, 0x000E1A68, 0x000E1E29, 0x000E21EA, 0x000E28C2];
const file_sizes = [0x0000003A, 0x0000003A, 0x0000003A, 0x0000004A, 0x00000000, 0x00000000, 0x00000000, 0x00000168, 0x00000000, 0x000002E5, 0x000001B3, 0x000001B8, 0x000001AC, 0x000001BB, 0x000001C1, 0x000001BC, 0x000001B3, 0x000001B9, 0x00000193, 0x000001B6, 0x000001D6, 0x0000018E, 0x000001C0, 0x00000196, 0x000001A3, 0x000001A3, 0x000001B5, 0x000001A2, 0x000001AA, 0x000001A0, 0x0000018C, 0x0000018B, 0x00000163, 0x000001AE, 0x0000017A, 0x0000018D, 0x000001B9, 0x000001A3, 0x000001A3, 0x00000193, 0x000001A4, 0x000001C0, 0x000001B0, 0x000001A0, 0x000001B7, 0x000001B7, 0x000001B2, 0x000001C5, 0x000001A9, 0x0000019D, 0x000001A0, 0x0000018C, 0x000001A7, 0x000001A1, 0x0000018F, 0x00000195, 0x000001CE, 0x000001D6, 0x000001B5, 0x00000178, 0x000001B1, 0x000001C0, 0x000001A4, 0x000001C0, 0x000001C0, 0x000001C0, 0x000001AC, 0x000001D3, 0x000001A3, 0x0000019E, 0x000001A0, 0x000001D3, 0x000001D3, 0x000001CB, 0x00000184, 0x000001C1, 0x000001B3, 0x000001B3, 0x000001A9, 0x000001B3, 0x000001B4, 0x000001B7, 0x000001AF, 0x000001B3, 0x000001BE, 0x00000193, 0x000001B6, 0x000001C6, 0x0000018E, 0x000001BB, 0x00000196, 0x000001A3, 0x000001A4, 0x000001B5, 0x000001A1, 0x000001A8, 0x000001A0, 0x0000018C, 0x0000018B, 0x00000163, 0x000001B6, 0x0000017A, 0x0000018D, 0x000001B9, 0x0000019D, 0x0000019D, 0x00000193, 0x000001A4, 0x000001C0, 0x000001B0, 0x000001A0, 0x000001B5, 0x000001B5, 0x000001B1, 0x000001B6, 0x000001A9, 0x0000019D, 0x000001A0, 0x0000018C, 0x000001A7, 0x000001A0, 0x0000018F, 0x00000195, 0x000001CE, 0x000001C3, 0x000001B5, 0x00000178, 0x000001AE, 0x000001BD, 0x000001A4, 0x000001C0, 0x000001C0, 0x000001C0, 0x0000019F, 0x000001D3, 0x000001A3, 0x0000019E, 0x000001A0, 0x000001D3, 0x000001D3, 0x000001CB, 0x00000184, 0x000001C1, 0x000001B3, 0x00002748, 0x00000CFF, 0x0000044D, 0x00000425, 0x00000425, 0x000003C1, 0x00000579, 0x000003C1, 0x0000044D, 0x00000399, 0x00000411, 0x000003AD, 0x000003AD, 0x000004C5, 0x000003E9, 0x00000321, 0x000003C1, 0x00000461, 0x00000411, 0x000004ED, 0x000004ED, 0x00000461, 0x000004C5, 0x000004B1, 0x0000044D, 0x0000044D, 0x00000439, 0x0000044D, 0x000003C1, 0x00000579, 0x000003C1, 0x000003C1, 0x000003C1, 0x00000399, 0x000003C1, 0x00000411, 0x0000076D, 0x0000076D, 0x0000076D, 0x00000295, 0x00000295, 0x0000076D, 0x0000076D, 0x00000399, 0x00000399, 0x0000076D, 0x00000321, 0x000001E1, 0x0000053D, 0x00000411, 0x00000411, 0x000002A9, 0x00000411, 0x0000053D, 0x00000619, 0x00000619, 0x000003C1, 0x0000044D, 0x00000425, 0x00000425, 0x000003C1, 0x00000579, 0x000003C1, 0x0000044D, 0x00000489, 0x00000411, 0x00000489, 0x000004B1, 0x000004C5, 0x0000044D, 0x00000321, 0x000004B1, 0x00000461, 0x00000411, 0x0000044D, 0x000004ED, 0x00000461, 0x000004C5, 0x000004B1, 0x0000044D, 0x0000044D, 0x00000439, 0x0000044D, 0x00000489, 0x00000411, 0x0000044D, 0x0000044D, 0x000004B1, 0x00000399, 0x000003C1, 0x00000411, 0x0000044D, 0x0000044D, 0x0000044D, 0x00000295, 0x00000295, 0x0000044D, 0x0000044D, 0x00000399, 0x00000399, 0x0000076D, 0x00000321, 0x000004B1, 0x0000053D, 0x00000411, 0x00000411, 0x000002A9, 0x00000411, 0x0000053D, 0x00000619, 0x00000619, 0x00000489, 0x00000027, 0x00000028, 0x00000016, 0x0000001A, 0x00000027, 0x00000035, 0x0000001F, 0x00000028, 0x00000020, 0x00000015, 0x00000020, 0x00000028, 0x00000026, 0x0000001F, 0x0000001C, 0x0000002B, 0x00000017, 0x00000018, 0x00000011, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000071, 0x00000014, 0x00000017, 0x00000035, 0x0000002F, 0x00000023, 0x0000003D, 0x00000021, 0x00000035, 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000036, 0x00000032, 0x00000031, 0x0000002B, 0x00000039, 0x0000005E, 0x00000054, 0x00000064, 0x00000037, 0x00000036, 0x00000037, 0x00000038, 0x00000037, 0x00000030, 0x00000030, 0x00000036, 0x00000034, 0x0000002C, 0x00000039, 0x0000002F, 0x00000033, 0x00000002, 0x00000033, 0x00000032, 0x00000065, 0x00000002, 0x00000034, 0x0000006E, 0x00000055, 0x0000004B, 0x00000002, 0x000000C2, 0x00000033, 0x00000033, 0x00000055, 0x0000000F, 0x00000022, 0x00000007, 0x00000016, 0x0000003C, 0x0000003C, 0x0000003C, 0x0000000F, 0x00000020, 0x0000002E, 0x00000038, 0x00000017, 0x00000022, 0x0000000C, 0x0000000D, 0x0000000C, 0x00000027, 0x00000030, 0x0000000E, 0x0000002C, 0x00000022, 0x00000031, 0x00000005, 0x00000015, 0x00000018, 0x00000005, 0x00000015, 0x00000018, 0x00000013, 0x00000033, 0x00000023, 0x00000017, 0x00000013, 0x00000031, 0x0000000F, 0x00000007, 0x00000031, 0x00000033, 0x0000002D, 0x00000032, 0x0000001F, 0x00000010, 0x00000006, 0x00000030, 0x00000032, 0x00000031, 0x00000018, 0x00000031, 0x0000002A, 0x0000002E, 0x0000000D, 0x00000018, 0x0000001E, 0x0000001E, 0x0000002E, 0x00000005, 0x0000001C, 0x00000015, 0x0000001C, 0x0000001C, 0x00000005, 0x00000004, 0x00000004, 0x00000005, 0x00000006, 0x00000004, 0x00000016, 0x00000013, 0x0000001C, 0x00000020, 0x00000023, 0x00000025, 0x0000001F, 0x00000024, 0x0000001E, 0x0000001D, 0x0000001E, 0x0000001E, 0x0000001E, 0x0000001E, 0x0000001E, 0x00000023, 0x00000023, 0x00000023, 0x00000021, 0x00000026, 0x00000026, 0x00000023, 0x00000024, 0x00000024, 0x0000002C, 0x0000001C, 0x00000018, 0x00000018, 0x00000021, 0x0000001B, 0x00000019, 0x00000002, 0x000001EF, 0x00000001, 0x0000005C, 0x00000001, 0x0000005C, 0x00000001, 0x000001C3, 0x00000001, 0x00000092, 0x00000001, 0x0000007B, 0x000000A1, 0x000000AC, 0x000000A8, 0x000000A4, 0x000000B2, 0x000000AF, 0x000000C0, 0x000000A4, 0x000000D0, 0x000000D9, 0x000000D5, 0x000000D8, 0x000000E3, 0x000000D8, 0x000000DF, 0x000000A0, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x0000015B, 0x00000001, 0x0000004A, 0x00000006, 0x000000A3, 0x0000000D, 0x00000154, 0x00000037, 0x000000B1, 0x000000EB, 0x000000BC, 0x00000090, 0x0000005B, 0x00000066, 0x0000008E, 0x000000DE, 0x000000DE, 0x00000060, 0x00000006, 0x00000007, 0x00000008, 0x00000012, 0x0000000E, 0x0000000C, 0x0000000C, 0x00000006, 0x00000007, 0x00000011, 0x00000016, 0x00000009, 0x0000000F, 0x0000000F, 0x00000018, 0x0000000B, 0x0000000B, 0x0000000F, 0x00000016, 0x0000000F, 0x0000000F, 0x0000000B, 0x00000012, 0x00000012, 0x00000007, 0x0000000E, 0x0000000F, 0x0000000D, 0x00000008, 0x00000010, 0x00000010, 0x0000000A, 0x00001A20, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000041, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000428, 0x00000488, 0x00000368, 0x000002C4, 0x0000026B, 0x00000149, 0x000007DD, 0x00000841, 0x00000428, 0x00000488, 0x00000368, 0x000002C4, 0x0000026B, 0x00000428, 0x00000488, 0x00000368, 0x000002C4, 0x0000026B, 0x00000843, 0x0000007E, 0x0000007E, 0x000007FD, 0x000001BE, 0x00000155, 0x000005ED, 0x0000052C, 0x00000665, 0x000004BE, 0x000007A3, 0x00000105, 0x00000088, 0x00000088, 0x0000011B, 0x0000011B, 0x00000088, 0x000004D3, 0x000006F4, 0x000001AB, 0x000001A6, 0x00000266, 0x00000341, 0x000000E4, 0x000000BB, 0x0000047A, 0x00000886, 0x00000069, 0x000003C6, 0x000003C6, 0x0000056E, 0x000000DA, 0x0000010C, 0x00000125, 0x000000A5, 0x0000066B, 0x00000734, 0x0000018C, 0x00000124, 0x00001136, 0x0000024F, 0x00000252, 0x000002EE, 0x000002EE, 0x0000013A, 0x0000013C, 0x0000048B, 0x00000245, 0x0000018C, 0x000004A5, 0x0000020B, 0x0000010C, 0x00000457, 0x000005FA, 0x00000563, 0x000000C2, 0x000004B9, 0x00000B08, 0x000003B9, 0x0000023D, 0x000001F1, 0x00001062, 0x00000D63, 0x00000063, 0x000001FE, 0x000001FE, 0x0000020B, 0x00000252, 0x00000213, 0x000001A7, 0x0000020D, 0x0000020D, 0x00000196, 0x00000217, 0x0000010D, 0x00000139, 0x000012F2, 0x0000013C, 0x000002D7, 0x000000E9, 0x00000529, 0x00000BF6, 0x000001E5, 0x000001E5, 0x000002CB, 0x000000E9, 0x00000515, 0x00000493, 0x00000256, 0x00000143, 0x000003B7, 0x0000038B, 0x00000497, 0x0000056A, 0x00000EE3, 0x000003A5, 0x00000567, 0x00000688, 0x00000288, 0x0000014C, 0x00000B40, 0x00000085, 0x000000C7, 0x0000020D, 0x0000072A, 0x00000379, 0x00000081, 0x00000088, 0x00000369, 0x000001F0, 0x000001F6, 0x000001F2, 0x00000193, 0x00000229, 0x00000118, 0x00000118, 0x00000118, 0x00000118, 0x00000118, 0x00000001, 0x00000493, 0x00000118, 0x00000118, 0x00000118, 0x00000118, 0x00000118, 0x000012F9, 0x0000048F, 0x0000010B, 0x00000222, 0x0000048B, 0x00000379, 0x00000119, 0x00000119, 0x000001F5, 0x00000416, 0x00000089, 0x00000089, 0x0000037C, 0x000001A2, 0x000001A2, 0x00000415, 0x000001F0, 0x000001F0, 0x000001F0, 0x000001F0, 0x00000AF1, 0x00000820, 0x0000065C, 0x0000059D, 0x00000585, 0x000000E7, 0x0000060C, 0x0000065C, 0x000000B6, 0x000006CF, 0x000000BA, 0x000000BA, 0x000000BA, 0x00000432, 0x00000494, 0x0000047D, 0x000004AB, 0x0000032B, 0x00000001, 0x00000469, 0x000001A6, 0x0000030E, 0x00001276, 0x0000026C, 0x00000344, 0x00000112, 0x00000104, 0x000001F6, 0x00000112, 0x00000132, 0x000000F4, 0x0000010C, 0x000003A7, 0x0000017D, 0x0000018D, 0x00000112, 0x00000132, 0x000007BF, 0x00000C17, 0x00000695, 0x00000256, 0x000000FD, 0x000000FD, 0x00000153, 0x00000A16, 0x00000567, 0x0000032E, 0x000002C9, 0x00000088, 0x00000155, 0x000002A0, 0x000010DD, 0x0000008E, 0x000001BC, 0x000001AD, 0x0000011B, 0x000002D0, 0x000000E7, 0x000000E7, 0x000002C0, 0x00000105, 0x0000007D, 0x0000007D, 0x00000001, 0x00000A48, 0x00000001, 0x0000007E, 0x00000C99, 0x000000C1, 0x000000BF, 0x00000063, 0x000004B6, 0x0000011B, 0x0000011B, 0x0000011B, 0x0000011B, 0x0000011B, 0x0000011B, 0x000000FA, 0x000000FA, 0x000000FA, 0x000000FA, 0x000000FA, 0x000000FA, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x00000F3A, 0x000001F4, 0x000001F0, 0x000000DD, 0x000000DD, 0x0000008B, 0x000000C6, 0x000001A9, 0x0000040B, 0x000002DE, 0x00000116, 0x00000112, 0x00000282, 0x0000070B, 0x000000F3, 0x000002C0, 0x000000F6, 0x00000424, 0x000002FB, 0x000002FB, 0x000002FB, 0x00000187, 0x000013A2, 0x000000A8, 0x00000127, 0x00000126, 0x000000E6, 0x0000011D, 0x00000104, 0x00000104, 0x00000280, 0x0000011E, 0x00000317, 0x0000021A, 0x000001E2, 0x000002DD, 0x000013A2, 0x000000A8, 0x00000127, 0x00000126, 0x000000E6, 0x0000011D, 0x00000104, 0x00000104, 0x00000280, 0x0000011E, 0x00000317, 0x0000021A, 0x000001E2, 0x000002DD, 0x0000041F, 0x00001189, 0x000010D3, 0x00000435, 0x00000122, 0x000005C9, 0x00000F3A, 0x0000120E, 0x000000F5, 0x0000013D, 0x000000BB, 0x00000139, 0x00000304, 0x00000330, 0x0000020D, 0x000002FD, 0x000002D1, 0x000000DF, 0x000001FE, 0x00000805, 0x00000031, 0x0000040E, 0x00000139, 0x00000139, 0x000003BD, 0x00000110, 0x00000110, 0x00000594, 0x000000C6, 0x000000C6, 0x000003AD, 0x000001C1, 0x000001C1, 0x00000644, 0x000003A3, 0x000003A3, 0x000004E6, 0x00000104, 0x00000104, 0x00001220, 0x000000DD, 0x000000ED, 0x0000015A, 0x000001B7, 0x0000019F, 0x0000014F, 0x0000029E, 0x000001E2, 0x00000214, 0x00000216, 0x000001F7, 0x00000225, 0x00000218, 0x000001A7, 0x000000B6, 0x00000201, 0x00000289, 0x000001E2, 0x000001D9, 0x000001A1, 0x00000242, 0x0000023E, 0x00000202, 0x0000023F, 0x00000114, 0x0000013D, 0x00000101, 0x00000102, 0x000000F6, 0x00000116, 0x00000114, 0x00000058, 0x00000FE5, 0x00000279, 0x00000279, 0x00000305, 0x00000279, 0x00000104, 0x0000008D, 0x0000012D, 0x000002F3, 0x000002F3, 0x00000886, 0x0000008A, 0x00000260, 0x0000053D, 0x00000105, 0x0000013C, 0x0000013C, 0x00000194, 0x00000F24, 0x00000168, 0x00000168, 0x00000C48, 0x000015A0, 0x00000395, 0x00001724, 0x00000CFC, 0x0000002E, 0x00000B6B, 0x000002D3, 0x000003FA, 0x000003FC, 0x00000545, 0x00000545, 0x00000684, 0x0000131B, 0x000012E3, 0x00000125, 0x0000012D, 0x0000012B, 0x00000136, 0x00001100, 0x00000001, 0x00000F11, 0x00000158, 0x00000158, 0x0000034E, 0x00000112, 0x0000011D, 0x0000011D, 0x00000109, 0x0000020B, 0x000003AC, 0x000003E8, 0x00000289, 0x00000104, 0x00000104, 0x000000F6, 0x00000105, 0x00000194, 0x00000120, 0x0000010F, 0x00000120, 0x00000377, 0x000000F6, 0x00000001, 0x00000175, 0x000006F5, 0x0000041A, 0x000002A6, 0x00000438, 0x00000159, 0x0000018B, 0x00000140, 0x00000C48, 0x00000314, 0x0000051A, 0x00000001, 0x00000269, 0x00000116, 0x00000116, 0x00000551, 0x00000105, 0x00000105, 0x000006E4, 0x00000434, 0x0000010A, 0x0000010A, 0x000003AF, 0x000000DB, 0x000000DB, 0x000000DB, 0x000000DB, 0x00000738, 0x00000182, 0x00000773, 0x00000104, 0x000002AE, 0x00000105, 0x0000011B, 0x0000011E, 0x000001D2, 0x00000119, 0x0000011F, 0x000001A3, 0x000000DF, 0x00000119, 0x0000011C, 0x000005DF, 0x0000057D, 0x00000134, 0x00000157, 0x00000105, 0x00000120, 0x000000E7, 0x00000487, 0x00000FB8, 0x00000536, 0x0000038F, 0x00000F67, 0x00000495, 0x00000515, 0x0000033A, 0x0000045A, 0x00000143, 0x000001F0, 0x00000119, 0x000001B3, 0x000001C1, 0x00001179, 0x000001A1, 0x000002B4, 0x000002B4, 0x00000346, 0x00000171, 0x000002AD, 0x000002AD, 0x000001A3, 0x000001A3, 0x0000005C, 0x0000005C, 0x00000169, 0x00000170, 0x000002AD, 0x000002AD, 0x000001A6, 0x000001A6, 0x00000217, 0x00000077, 0x000002D1, 0x0000030A, 0x000002AD, 0x000002AD, 0x0000005C, 0x000001AA, 0x000001AA, 0x00000065, 0x00000060, 0x000001A3, 0x000001A3, 0x000000A8, 0x0000007B, 0x00000E87, 0x0000012B, 0x00000138, 0x0000038C, 0x0000010A, 0x0000010A, 0x0000012C, 0x0000012C, 0x0000054F, 0x0000010D, 0x00000111, 0x0000010D, 0x0000010D, 0x00000E7B, 0x000004FC, 0x000004FE, 0x000002D7, 0x0000068F, 0x0000018B, 0x0000018B, 0x00000001, 0x00000A22, 0x000003BF, 0x0000005F, 0x0000005E, 0x00000206, 0x00000001, 0x00000FDF, 0x00000E09, 0x00001368, 0x00001040, 0x00001186, 0x00000FBA, 0x00001555, 0x0000028A, 0x00000001, 0x00000CCA, 0x0000010E, 0x000004A8, 0x0000039A, 0x00000C1A, 0x0000013C, 0x0000031C, 0x0000035F, 0x0000048C, 0x000001F4, 0x000005FB, 0x0000064C, 0x000000F5, 0x0000056E, 0x000001AA, 0x0000019C, 0x0000082A, 0x00000554, 0x00000241, 0x0000022E, 0x0000006A, 0x00000143, 0x00000480, 0x0000042C, 0x00000263, 0x000002FB, 0x000002FB, 0x00000388, 0x000002A4, 0x000004EA, 0x000004C5, 0x00000479, 0x00000515, 0x00000431, 0x0000044B, 0x0000046F, 0x000003CC, 0x00000398, 0x0000056B, 0x000005C8, 0x000002B6, 0x000003D9, 0x0000049D, 0x00000382, 0x000002FF, 0x000001F5, 0x00000525, 0x00000EFF, 0x000000BE, 0x000000C4, 0x00000090, 0x0000010F, 0x0000010F, 0x0000010F, 0x0000010F, 0x00000104, 0x00000104, 0x00000104, 0x00000115, 0x00000115, 0x00000115, 0x00000115, 0x000003FC, 0x0000013C, 0x00000448, 0x00000733, 0x00000288, 0x00000283, 0x00000127, 0x0000085D, 0x000011CC, 0x000006AA, 0x00000429, 0x00000125, 0x00000A47, 0x00000074, 0x00000503, 0x00000062, 0x00000069, 0x00000568, 0x0000010F, 0x00000104, 0x00001257, 0x0000039D, 0x0000028D, 0x000003AA, 0x00000101, 0x000000F4, 0x000000DF, 0x0000020F, 0x00000104, 0x0000050E, 0x00000280, 0x00000280, 0x00000280, 0x00000115, 0x000002E0, 0x00000EF8, 0x000006FD, 0x000007D4, 0x000010A1, 0x00000436, 0x000001F8, 0x0000051B, 0x00000223, 0x00000FFD, 0x000005B2, 0x00000308, 0x0000020A, 0x000001CC, 0x00001228, 0x00000487, 0x00000101, 0x000001EC, 0x00000272, 0x00000080, 0x00000900, 0x0000057D, 0x00000C4D, 0x00000421, 0x00000371, 0x000001A7, 0x00000358, 0x00000325, 0x00000112, 0x000003FB, 0x000005D6, 0x00000454, 0x000008A3, 0x00000E59, 0x000001BE, 0x00000410, 0x00000403, 0x000003FA, 0x00000410, 0x000003AD, 0x00000400, 0x000002E9, 0x000001E4, 0x00000FBC, 0x00000C84, 0x00000655, 0x0000021A, 0x00000180, 0x000012F6, 0x00000D0E, 0x000001A6, 0x0000005C, 0x00000064, 0x00000159, 0x00000120, 0x00000166, 0x0000019A, 0x00000101, 0x00000213, 0x000000D7, 0x000002C9, 0x00000225, 0x00000745, 0x00000705, 0x000005D4, 0x000009BD, 0x000003B2, 0x000004B7, 0x000002F5, 0x00000118, 0x00000389, 0x0000011A, 0x000001D4, 0x000000FA, 0x00000150, 0x00000126, 0x000003E9, 0x00000105, 0x0000029B, 0x0000067A, 0x000003C1, 0x000003C1, 0x000003C1, 0x000006D8, 0x000003C1];
const oct13_file_sectors = [0x00000000, 0x0000003A, 0x00000074, 0x000000AE, 0x000000F8, 0x000000F8, 0x000000F8, 0x000000F8, 0x00000260, 0x00000260, 0x00000545, 0x000006F8, 0x000008B0, 0x00000A5C, 0x00000C17, 0x00000DD8, 0x00000F94, 0x00001147, 0x00001300, 0x00001493, 0x00001649, 0x0000181F, 0x000019AD, 0x00001B6D, 0x00001D03, 0x00001EA6, 0x00002049, 0x000021FE, 0x000023A0, 0x0000254A, 0x000026EA, 0x00002876, 0x00002A01, 0x00002B64, 0x00002D12, 0x00002E8C, 0x00003019, 0x000031D2, 0x00003375, 0x00003518, 0x000036AB, 0x0000384F, 0x00003A0F, 0x00003BBF, 0x00003D5F, 0x00003F16, 0x000040CD, 0x0000427F, 0x00004444, 0x000045ED, 0x0000478A, 0x0000492A, 0x00004AB6, 0x00004C5D, 0x00004DFE, 0x00004F8D, 0x00005122, 0x000052F0, 0x000054C6, 0x0000567B, 0x000057F3, 0x000059A4, 0x00005B64, 0x00005D08, 0x00005EC8, 0x00006088, 0x00006248, 0x000063F4, 0x000065C7, 0x0000676A, 0x00006908, 0x00006AA8, 0x00006C7B, 0x00006E4E, 0x00007019, 0x0000719D, 0x0000735E, 0x00007511, 0x000076C4, 0x0000786D, 0x00007A20, 0x00007BD4, 0x00007D8B, 0x00007F3A, 0x000080ED, 0x000082AB, 0x0000843E, 0x000085F4, 0x000087BA, 0x00008948, 0x00008B03, 0x00008C99, 0x00008E3C, 0x00008FE0, 0x00009195, 0x00009336, 0x000094DE, 0x0000967E, 0x0000980A, 0x00009995, 0x00009AF8, 0x00009CAE, 0x00009E28, 0x00009FB5, 0x0000A16E, 0x0000A30B, 0x0000A4A8, 0x0000A63B, 0x0000A7DF, 0x0000A99F, 0x0000AB4F, 0x0000ACEF, 0x0000AEA4, 0x0000B059, 0x0000B20A, 0x0000B3C0, 0x0000B569, 0x0000B706, 0x0000B8A6, 0x0000BA32, 0x0000BBD9, 0x0000BD79, 0x0000BF08, 0x0000C09D, 0x0000C26B, 0x0000C42E, 0x0000C5E3, 0x0000C75B, 0x0000C909, 0x0000CAC6, 0x0000CC6A, 0x0000CE2A, 0x0000CFEA, 0x0000D1AA, 0x0000D349, 0x0000D51C, 0x0000D6BF, 0x0000D85D, 0x0000D9FD, 0x0000DBD0, 0x0000DDA3, 0x0000DF6E, 0x0000E0F2, 0x0000E2B3, 0x0000E466, 0x00010BAE, 0x000118AD, 0x00011CFA, 0x0001211F, 0x00012544, 0x00012905, 0x00012E7E, 0x0001323F, 0x0001368C, 0x00013A25, 0x00013E36, 0x000141E3, 0x00014590, 0x00014A55, 0x00014E3E, 0x0001515F, 0x00015520, 0x00015981, 0x00015D92, 0x0001627F, 0x0001676C, 0x00016BCD, 0x00017092, 0x00017543, 0x00017990, 0x00017DDD, 0x00018216, 0x00018663, 0x00018A24, 0x00018F9D, 0x0001935E, 0x0001971F, 0x00019AE0, 0x00019E79, 0x0001A23A, 0x0001A64B, 0x0001ADB8, 0x0001B525, 0x0001BC92, 0x0001BF27, 0x0001C1BC, 0x0001C929, 0x0001D096, 0x0001D42F, 0x0001D7C8, 0x0001DF35, 0x0001E256, 0x0001E437, 0x0001E974, 0x0001ED85, 0x0001F196, 0x0001F43F, 0x0001F850, 0x0001FD8D, 0x000203A6, 0x000209BF, 0x00020D80, 0x000211CD, 0x000215F2, 0x00021A17, 0x00021DD8, 0x00022351, 0x00022712, 0x00022B5F, 0x00022FE8, 0x000233F9, 0x00023882, 0x00023D33, 0x000241F8, 0x00024645, 0x00024966, 0x00024E17, 0x00025278, 0x00025689, 0x00025AD6, 0x00025FC3, 0x00026424, 0x000268E9, 0x00026D9A, 0x000271E7, 0x00027634, 0x00027A6D, 0x00027EBA, 0x00028343, 0x00028754, 0x00028BA1, 0x00028FEE, 0x0002949F, 0x00029838, 0x00029BF9, 0x0002A00A, 0x0002A457, 0x0002A8A4, 0x0002ACF1, 0x0002AF86, 0x0002B21B, 0x0002B668, 0x0002BAB5, 0x0002BE4E, 0x0002C1E7, 0x0002C954, 0x0002CC75, 0x0002D126, 0x0002D663, 0x0002DA74, 0x0002DE85, 0x0002E12E, 0x0002E53F, 0x0002EA7C, 0x0002F095, 0x0002F6AE, 0x0002FB37, 0x0002FB5E, 0x0002FB86, 0x0002FB9C, 0x0002FBB6, 0x0002FBDD, 0x0002FC12, 0x0002FC31, 0x0002FC59, 0x0002FC79, 0x0002FC8E, 0x0002FCAE, 0x0002FCD6, 0x0002FCFC, 0x0002FD1B, 0x0002FD37, 0x0002FD62, 0x0002FD79, 0x0002FD91, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FDA2, 0x0002FE13, 0x0002FE27, 0x0002FE3E, 0x0002FE73, 0x0002FEA2, 0x0002FEC5, 0x0002FF02, 0x0002FF23, 0x0002FF58, 0x0002FF5A, 0x0002FF5C, 0x0002FF5E, 0x0002FF60, 0x0002FF96, 0x0002FFC8, 0x0002FFF9, 0x00030024, 0x0003005D, 0x000300BB, 0x0003010F, 0x00030173, 0x000301AA, 0x000301E0, 0x00030217, 0x0003024F, 0x00030286, 0x000302B6, 0x000302E6, 0x0003031C, 0x00030350, 0x0003037C, 0x000303B5, 0x000303E4, 0x00030417, 0x00030419, 0x0003044C, 0x0003047E, 0x000304E3, 0x000304E5, 0x00030519, 0x00030587, 0x000305DC, 0x00030627, 0x00030629, 0x000306EB, 0x0003071E, 0x00030751, 0x000307A6, 0x000307B5, 0x000307D7, 0x000307DE, 0x000307F4, 0x00030830, 0x0003086C, 0x000308A8, 0x000308B7, 0x000308D7, 0x00030905, 0x0003093D, 0x00030954, 0x00030976, 0x00030982, 0x0003098F, 0x0003099B, 0x000309C2, 0x000309F2, 0x00030A00, 0x00030A2C, 0x00030A4E, 0x00030A7F, 0x00030A84, 0x00030A99, 0x00030AB1, 0x00030AB6, 0x00030ACB, 0x00030AE3, 0x00030AF6, 0x00030B29, 0x00030B4C, 0x00030B63, 0x00030B76, 0x00030BA7, 0x00030BB6, 0x00030BBD, 0x00030BEE, 0x00030C21, 0x00030C4E, 0x00030C80, 0x00030C9F, 0x00030CAF, 0x00030CB5, 0x00030CE5, 0x00030D17, 0x00030D48, 0x00030D60, 0x00030D91, 0x00030DBB, 0x00030DE9, 0x00030DF6, 0x00030E0E, 0x00030E2C, 0x00030E4A, 0x00030E78, 0x00030E7D, 0x00030E99, 0x00030EAE, 0x00030ECA, 0x00030EE6, 0x00030EEB, 0x00030EEF, 0x00030EF3, 0x00030EF8, 0x00030EFE, 0x00030F02, 0x00030F18, 0x00030F2B, 0x00030F47, 0x00030F67, 0x00030F8A, 0x00030FAF, 0x00030FCE, 0x00030FF2, 0x00031010, 0x0003102D, 0x0003104B, 0x00031069, 0x00031087, 0x000310A5, 0x000310C3, 0x000310E6, 0x00031109, 0x0003112C, 0x0003114D, 0x00031173, 0x00031199, 0x000311BC, 0x000311E0, 0x00031204, 0x00031230, 0x0003124C, 0x00031264, 0x0003127C, 0x0003129D, 0x000312B8, 0x000312D1, 0x000312D3, 0x000314C2, 0x000314C3, 0x0003151F, 0x00031520, 0x0003157C, 0x0003157D, 0x00031740, 0x00031741, 0x000317D3, 0x000317D4, 0x0003184F, 0x000318F0, 0x0003199C, 0x00031A44, 0x00031AE8, 0x00031B9A, 0x00031C49, 0x00031D09, 0x00031DAD, 0x00031E7D, 0x00031F56, 0x0003202B, 0x00032103, 0x000321E6, 0x000322BE, 0x0003239D, 0x0003243D, 0x0003243E, 0x0003243F, 0x00032440, 0x00032441, 0x00032442, 0x00032443, 0x0003259E, 0x0003259F, 0x000325E9, 0x000325EF, 0x00032692, 0x0003269F, 0x000327F3, 0x0003282A, 0x000328DB, 0x000329C6, 0x00032A82, 0x00032B12, 0x00032B6D, 0x00032BD3, 0x00032C61, 0x00032D3F, 0x00032E1D, 0x00032E7D, 0x00032E83, 0x00032E8A, 0x00032E92, 0x00032EA4, 0x00032EB2, 0x00032EBE, 0x00032ECA, 0x00032ED0, 0x00032ED7, 0x00032EE8, 0x00032EFE, 0x00032F07, 0x00032F16, 0x00032F25, 0x00032F3D, 0x00032F48, 0x00032F53, 0x00032F62, 0x00032F78, 0x00032F87, 0x00032F96, 0x00032FA1, 0x00032FB3, 0x00032FC5, 0x00032FCC, 0x00032FDA, 0x00032FE9, 0x00032FF6, 0x00032FFE, 0x0003300E, 0x0003301E, 0x00033028, 0x00034A48, 0x00034AC9, 0x00034B4A, 0x00034BCB, 0x00034C4C, 0x00034CCD, 0x00034D4E, 0x00034DCF, 0x00034E50, 0x00034ED1, 0x00034F52, 0x00034FD3, 0x00035054, 0x000350D5, 0x00035156, 0x000351D7, 0x00035258, 0x000352D9, 0x0003531A, 0x0003539B, 0x0003541C, 0x0003549D, 0x0003551E, 0x0003559F, 0x00035620, 0x000356A1, 0x00035722, 0x000357A3, 0x00035824, 0x000358A5, 0x00035926, 0x000359A7, 0x00035A28, 0x00035AA9, 0x00035B2A, 0x00035BAB, 0x00035C2C, 0x00035CAD, 0x00035D2E, 0x00035DAF, 0x00035E30, 0x00035EB1, 0x00035F32, 0x00035FB3, 0x00036034, 0x000360B5, 0x00036136, 0x000361B7, 0x00036238, 0x000362B9, 0x0003633A, 0x000363BB, 0x0003643C, 0x000364BD, 0x0003653E, 0x000365BF, 0x00036640, 0x000366C1, 0x00036742, 0x000367C3, 0x00036844, 0x000368C5, 0x00036946, 0x000369C7, 0x00036A48, 0x00036AC9, 0x00036B4A, 0x00036BCB, 0x00036C4C, 0x00036CCD, 0x00036D4E, 0x00036DCF, 0x00036E50, 0x00036ED1, 0x00036F52, 0x00036FD3, 0x00037054, 0x000370D5, 0x00037156, 0x000371D7, 0x00037258, 0x000372D9, 0x0003735A, 0x000373DB, 0x0003745C, 0x000374DD, 0x0003755E, 0x000375DF, 0x00037660, 0x000376E1, 0x00037762, 0x000377E3, 0x00037864, 0x000378E5, 0x00037966, 0x000379E7, 0x00037A68, 0x00037AE9, 0x00037B6A, 0x00037BEB, 0x00037C6C, 0x00037CED, 0x00038115, 0x0003859D, 0x00038905, 0x00038BC9, 0x00038E34, 0x00038F7D, 0x0003975A, 0x00039F9B, 0x0003A3C3, 0x0003A84B, 0x0003ABB3, 0x0003AE77, 0x0003B0E2, 0x0003B50A, 0x0003B992, 0x0003BCFA, 0x0003BFBE, 0x0003C229, 0x0003CA6C, 0x0003CAEA, 0x0003CB68, 0x0003D365, 0x0003D523, 0x0003D678, 0x0003DC65, 0x0003E191, 0x0003E7F6, 0x0003ECB4, 0x0003F457, 0x0003F55C, 0x0003F5E4, 0x0003F66C, 0x0003F787, 0x0003F8A2, 0x0003F92A, 0x0003FDFD, 0x000404F1, 0x0004069C, 0x00040842, 0x00040AA8, 0x00040DE9, 0x00040ECD, 0x00040F88, 0x00041402, 0x00041C88, 0x00041CF1, 0x000420B7, 0x0004247D, 0x000429EB, 0x00042AC5, 0x00042BD1, 0x00042CF6, 0x00042D9B, 0x00043406, 0x00043B3A, 0x00043CC6, 0x00043DEA, 0x00044F20, 0x0004516F, 0x000453C1, 0x000456AF, 0x0004599D, 0x00045AD7, 0x00045C13, 0x0004609E, 0x000462E3, 0x0004646F, 0x00046914, 0x00046B1F, 0x00046C2B, 0x00047082, 0x0004767C, 0x00047BDF, 0x00047CA1, 0x0004815A, 0x00048C63, 0x0004901D, 0x0004925A, 0x0004944D, 0x0004A4AF, 0x0004B212, 0x0004B275, 0x0004B473, 0x0004B671, 0x0004B87C, 0x0004BACE, 0x0004BCE1, 0x0004BE88, 0x0004C095, 0x0004C2A2, 0x0004C438, 0x0004C64F, 0x0004C75C, 0x0004C895, 0x0004DB87, 0x0004DCC3, 0x0004DF9A, 0x0004E083, 0x0004E5AC, 0x0004F1A2, 0x0004F387, 0x0004F56C, 0x0004F837, 0x0004F920, 0x0004FE35, 0x000502C8, 0x0005051E, 0x00050661, 0x00050A18, 0x00050DA3, 0x0005123A, 0x000517A4, 0x00052687, 0x00052A2C, 0x00052F93, 0x0005361B, 0x000538A3, 0x000539EF, 0x0005452F, 0x000545B4, 0x0005467B, 0x00054888, 0x00054FB2, 0x0005532B, 0x000553AC, 0x00055434, 0x0005579D, 0x0005598D, 0x00055B83, 0x00055D75, 0x00055F08, 0x00056131, 0x00056249, 0x00056361, 0x00056479, 0x00056591, 0x000566A9, 0x000566AA, 0x00056B3D, 0x00056C55, 0x00056D6D, 0x00056E85, 0x00056F9D, 0x000570B5, 0x000583AE, 0x0005883D, 0x00058948, 0x00058B6A, 0x00058FF5, 0x0005936E, 0x00059487, 0x000595A0, 0x00059795, 0x00059BAB, 0x00059C34, 0x00059CBD, 0x0005A039, 0x0005A1DB, 0x0005A37D, 0x0005A792, 0x0005A982, 0x0005AB72, 0x0005AD62, 0x0005AF52, 0x0005BA43, 0x0005C263, 0x0005C8BF, 0x0005CE5C, 0x0005D3E1, 0x0005D4C8, 0x0005DAD4, 0x0005E130, 0x0005E1E6, 0x0005E8B5, 0x0005E96F, 0x0005EA29, 0x0005EAE3, 0x0005EF15, 0x0005F3A9, 0x0005F826, 0x0005FCD1, 0x0005FFFC, 0x0005FFFD, 0x00060466, 0x0006060C, 0x0006091A, 0x00061B90, 0x00061DFC, 0x00062140, 0x00062252, 0x00062356, 0x0006254C, 0x0006265E, 0x00062790, 0x00062884, 0x00062990, 0x00062D37, 0x00062EB4, 0x00063041, 0x00063153, 0x00063285, 0x00063A44, 0x0006465B, 0x00064CF0, 0x00064F46, 0x00065043, 0x00065140, 0x00065293, 0x00065CA9, 0x00066210, 0x0006653E, 0x00066807, 0x0006688F, 0x000669E4, 0x00066C84, 0x00067D61, 0x00067DEF, 0x00067FAB, 0x00068158, 0x00068273, 0x00068543, 0x0006862A, 0x00068711, 0x000689D1, 0x00068AD6, 0x00068B53, 0x00068BD0, 0x00068BD1, 0x00069619, 0x0006961A, 0x00069698, 0x0006A331, 0x0006A3F2, 0x0006A4B1, 0x0006A514, 0x0006A9CA, 0x0006AAE5, 0x0006AC00, 0x0006AD1B, 0x0006AE36, 0x0006AF51, 0x0006B06C, 0x0006B166, 0x0006B260, 0x0006B35A, 0x0006B454, 0x0006B54E, 0x0006B648, 0x0006B72F, 0x0006B816, 0x0006B8FD, 0x0006B9E4, 0x0006BACB, 0x0006BBB2, 0x0006BC99, 0x0006BD80, 0x0006CCBA, 0x0006CEAE, 0x0006D09E, 0x0006D17B, 0x0006D258, 0x0006D2E3, 0x0006D3A9, 0x0006D552, 0x0006D95D, 0x0006DC3B, 0x0006DD51, 0x0006DE63, 0x0006E0E5, 0x0006E7F0, 0x0006E8E3, 0x0006EBA3, 0x0006EC99, 0x0006F0BD, 0x0006F3B8, 0x0006F6B3, 0x0006F9AE, 0x0006FB35, 0x00070ED7, 0x00070F7F, 0x000710A6, 0x000711CC, 0x000712B2, 0x000713CF, 0x000714D3, 0x000715D7, 0x00071857, 0x00071975, 0x00071C8C, 0x00071EA6, 0x00072088, 0x00072365, 0x00073707, 0x000737AF, 0x000738D6, 0x000739FC, 0x00073AE2, 0x00073BFF, 0x00073D03, 0x00073E07, 0x00074087, 0x000741A5, 0x000744BC, 0x000746D6, 0x000748B8, 0x00074B95, 0x00074FB4, 0x0007613D, 0x00077210, 0x00077645, 0x00077767, 0x00077D30, 0x00078C6A, 0x00079E78, 0x00079F6D, 0x0007A0AA, 0x0007A165, 0x0007A29E, 0x0007A5A2, 0x0007A8D2, 0x0007AADF, 0x0007ADDC, 0x0007B0AD, 0x0007B18C, 0x0007B38A, 0x0007BB8F, 0x0007BBC0, 0x0007BFCE, 0x0007C107, 0x0007C240, 0x0007C5FD, 0x0007C70D, 0x0007C81D, 0x0007CDB1, 0x0007CE77, 0x0007CF3D, 0x0007D2EA, 0x0007D4AB, 0x0007D66C, 0x0007DCB0, 0x0007E053, 0x0007E3F6, 0x0007E8DC, 0x0007E9E0, 0x0007EAE4, 0x0007FD04, 0x0007FDE1, 0x0007FECE, 0x00080028, 0x000801DF, 0x0008037E, 0x000804CD, 0x0008076B, 0x0008094D, 0x00080B61, 0x00080D77, 0x00080F6E, 0x00081193, 0x000813AB, 0x00081552, 0x00081608, 0x00081809, 0x00081A92, 0x00081C74, 0x00081E4D, 0x00081FEE, 0x00082230, 0x0008246E, 0x00082670, 0x000828AF, 0x000829C3, 0x00082B00, 0x00082C01, 0x00082D03, 0x00082DF9, 0x00082F0F, 0x00083023, 0x0008307B, 0x00084060, 0x000842D9, 0x00084552, 0x00084857, 0x00084AD0, 0x00084BD4, 0x00084C61, 0x00084D8E, 0x00085081, 0x00085374, 0x00085BFA, 0x00085C84, 0x00085EE4, 0x00086421, 0x00086526, 0x00086662, 0x0008679E, 0x00086932, 0x00087856, 0x000879BE, 0x00087B26, 0x0008876E, 0x00089D0E, 0x0008A0A3, 0x0008B7C7, 0x0008C4C3, 0x0008C4F1, 0x0008D05C, 0x0008D32F, 0x0008D729, 0x0008DB25, 0x0008E06A, 0x0008E5AF, 0x0008EC33, 0x0008FF4E, 0x00091231, 0x00091356, 0x00091483, 0x000915AE, 0x000916E4, 0x000927E4, 0x000927E5, 0x000936F6, 0x0009384E, 0x000939A6, 0x00093CF4, 0x00093E06, 0x00093F23, 0x00094040, 0x00094149, 0x00094354, 0x00094700, 0x00094AE8, 0x00094D71, 0x00094E75, 0x00094F79, 0x0009506F, 0x00095174, 0x00095308, 0x00095428, 0x00095537, 0x00095657, 0x000959CE, 0x00095AC4, 0x00095AC5, 0x00095C3A, 0x0009632F, 0x00096749, 0x000969EF, 0x00096E27, 0x00096F80, 0x0009710B, 0x0009724B, 0x00097E93, 0x000981A7, 0x000986C1, 0x000986C2, 0x0009892B, 0x00098A41, 0x00098B57, 0x000990A8, 0x000991AD, 0x000992B2, 0x00099996, 0x00099DCA, 0x00099ED4, 0x00099FDE, 0x0009A38D, 0x0009A468, 0x0009A543, 0x0009A61E, 0x0009A6F9, 0x0009AE31, 0x0009AFB3, 0x0009B726, 0x0009B82A, 0x0009BAD8, 0x0009BBDD, 0x0009BCF8, 0x0009BE16, 0x0009BFE8, 0x0009C101, 0x0009C220, 0x0009C3C3, 0x0009C4A2, 0x0009C5BB, 0x0009C6D7, 0x0009CCB6, 0x0009D233, 0x0009D367, 0x0009D4BE, 0x0009D5C3, 0x0009D6E3, 0x0009D7CA, 0x0009DC51, 0x0009EC09, 0x0009F13F, 0x0009F4CE, 0x000A0435, 0x000A08CA, 0x000A0DDF, 0x000A1119, 0x000A1573, 0x000A16B6, 0x000A18A6, 0x000A19BF, 0x000A1B72, 0x000A1D33, 0x000A2EAC, 0x000A304D, 0x000A3301, 0x000A35B5, 0x000A38FB, 0x000A3A6C, 0x000A3D19, 0x000A3FC6, 0x000A4169, 0x000A430C, 0x000A4368, 0x000A43C4, 0x000A452D, 0x000A469D, 0x000A494A, 0x000A4BF7, 0x000A4D9D, 0x000A4F43, 0x000A515A, 0x000A51D1, 0x000A54A2, 0x000A57AC, 0x000A5A59, 0x000A5D06, 0x000A5D62, 0x000A5F0C, 0x000A60B6, 0x000A611B, 0x000A617B, 0x000A631E, 0x000A64C1, 0x000A6569, 0x000A65E4, 0x000A746B, 0x000A7596, 0x000A76CE, 0x000A7A5A, 0x000A7B64, 0x000A7C6E, 0x000A7D9A, 0x000A7EC6, 0x000A8415, 0x000A8522, 0x000A8633, 0x000A8740, 0x000A884D, 0x000A96C8, 0x000A9BC4, 0x000AA0C2, 0x000AA399, 0x000AAA28, 0x000AABB3, 0x000AAD3E, 0x000AAD3F, 0x000AB761, 0x000ABB20, 0x000ABB7F, 0x000ABBDD, 0x000ABDE3, 0x000ABDE4, 0x000ACDC3, 0x000ADBCC, 0x000AEF34, 0x000AFF74, 0x000B10FA, 0x000B20B4, 0x000B3609, 0x000B3893, 0x000B3894, 0x000B455E, 0x000B466C, 0x000B4B14, 0x000B4EAE, 0x000B5AC8, 0x000B5C04, 0x000B5F20, 0x000B627F, 0x000B670B, 0x000B68FF, 0x000B6EFA, 0x000B7546, 0x000B763B, 0x000B7BA9, 0x000B7D53, 0x000B7EEF, 0x000B8719, 0x000B8C6D, 0x000B8EAE, 0x000B90DC, 0x000B9146, 0x000B9289, 0x000B9709, 0x000B9B35, 0x000B9D98, 0x000BA093, 0x000BA38E, 0x000BA716, 0x000BA9BA, 0x000BAEA4, 0x000BB369, 0x000BB7E2, 0x000BBCF7, 0x000BC128, 0x000BC573, 0x000BC9E2, 0x000BCDAE, 0x000BD146, 0x000BD6B1, 0x000BDC79, 0x000BDF2F, 0x000BE308, 0x000BE7A5, 0x000BEB27, 0x000BEE26, 0x000BF01B, 0x000BF540, 0x000C043F, 0x000C04FD, 0x000C05C1, 0x000C0651, 0x000C0760, 0x000C086F, 0x000C097E, 0x000C0A8D, 0x000C0B91, 0x000C0C95, 0x000C0D99, 0x000C0EAE, 0x000C0FC3, 0x000C10D8, 0x000C11ED, 0x000C15E9, 0x000C1725, 0x000C1B6D, 0x000C22A0, 0x000C2528, 0x000C27AB, 0x000C28D2, 0x000C312F, 0x000C42FB, 0x000C49A5, 0x000C4DCE, 0x000C4EF3, 0x000C593A, 0x000C59AE, 0x000C5EB1, 0x000C5F13, 0x000C5F7C, 0x000C64E4, 0x000C65F3, 0x000C66F7, 0x000C794E, 0x000C7CEB, 0x000C7F78, 0x000C8322, 0x000C8423, 0x000C8517, 0x000C85F6, 0x000C8805, 0x000C8909, 0x000C8E17, 0x000C9097, 0x000C9317, 0x000C9597, 0x000C96AC, 0x000C998C, 0x000CA884, 0x000CAF81, 0x000CB755, 0x000CC7F6, 0x000CCC2C, 0x000CCE24, 0x000CD33F, 0x000CD562, 0x000CE55F, 0x000CEB11, 0x000CEE19, 0x000CF023, 0x000CF1EF, 0x000D0417, 0x000D089E, 0x000D099F, 0x000D0B8B, 0x000D0DFD, 0x000D0E7D, 0x000D177D, 0x000D1CFA, 0x000D2947, 0x000D2D68, 0x000D30D9, 0x000D3280, 0x000D35D8, 0x000D38FD, 0x000D3A0F, 0x000D3E0A, 0x000D43E0, 0x000D4834, 0x000D50D7, 0x000D5F30, 0x000D60EE, 0x000D64FE, 0x000D6901, 0x000D6CFB, 0x000D710B, 0x000D74B8, 0x000D78B8, 0x000D7BA1, 0x000D7D85, 0x000D8D41, 0x000D99C5, 0x000DA01A, 0x000DA234, 0x000DA3B4, 0x000DB6AA, 0x000DC3B8, 0x000DC55E, 0x000DC5BA, 0x000DC61E, 0x000DC777, 0x000DC897, 0x000DC9FD, 0x000DCB97, 0x000DCC98, 0x000DCEAB, 0x000DCF82, 0x000DD24B, 0x000DD470, 0x000DDBB5, 0x000DE2BA, 0x000DE88E, 0x000DF24B, 0x000DF5FD, 0x000DFAB4, 0x000DFDA9, 0x000DFEC1, 0x000E024A, 0x000E0364, 0x000E0538, 0x000E0632, 0x000E0782, 0x000E08A8, 0x000E0C91, 0x000E0D96, 0x000E1031, 0x000E16AB, 0x000E1A6C, 0x000E1E2D, 0x000E21EE, 0x000E28C6];
const oct13_file_sizes = [0x0000003A, 0x0000003A, 0x0000003A, 0x0000004A, 0x00000000, 0x00000000, 0x00000000, 0x00000168, 0x00000000, 0x000002E5, 0x000001B3, 0x000001B8, 0x000001AC, 0x000001BB, 0x000001C1, 0x000001BC, 0x000001B3, 0x000001B9, 0x00000193, 0x000001B6, 0x000001D6, 0x0000018E, 0x000001C0, 0x00000196, 0x000001A3, 0x000001A3, 0x000001B5, 0x000001A2, 0x000001AA, 0x000001A0, 0x0000018C, 0x0000018B, 0x00000163, 0x000001AE, 0x0000017A, 0x0000018D, 0x000001B9, 0x000001A3, 0x000001A3, 0x00000193, 0x000001A4, 0x000001C0, 0x000001B0, 0x000001A0, 0x000001B7, 0x000001B7, 0x000001B2, 0x000001C5, 0x000001A9, 0x0000019D, 0x000001A0, 0x0000018C, 0x000001A7, 0x000001A1, 0x0000018F, 0x00000195, 0x000001CE, 0x000001D6, 0x000001B5, 0x00000178, 0x000001B1, 0x000001C0, 0x000001A4, 0x000001C0, 0x000001C0, 0x000001C0, 0x000001AC, 0x000001D3, 0x000001A3, 0x0000019E, 0x000001A0, 0x000001D3, 0x000001D3, 0x000001CB, 0x00000184, 0x000001C1, 0x000001B3, 0x000001B3, 0x000001A9, 0x000001B3, 0x000001B4, 0x000001B7, 0x000001AF, 0x000001B3, 0x000001BE, 0x00000193, 0x000001B6, 0x000001C6, 0x0000018E, 0x000001BB, 0x00000196, 0x000001A3, 0x000001A4, 0x000001B5, 0x000001A1, 0x000001A8, 0x000001A0, 0x0000018C, 0x0000018B, 0x00000163, 0x000001B6, 0x0000017A, 0x0000018D, 0x000001B9, 0x0000019D, 0x0000019D, 0x00000193, 0x000001A4, 0x000001C0, 0x000001B0, 0x000001A0, 0x000001B5, 0x000001B5, 0x000001B1, 0x000001B6, 0x000001A9, 0x0000019D, 0x000001A0, 0x0000018C, 0x000001A7, 0x000001A0, 0x0000018F, 0x00000195, 0x000001CE, 0x000001C3, 0x000001B5, 0x00000178, 0x000001AE, 0x000001BD, 0x000001A4, 0x000001C0, 0x000001C0, 0x000001C0, 0x0000019F, 0x000001D3, 0x000001A3, 0x0000019E, 0x000001A0, 0x000001D3, 0x000001D3, 0x000001CB, 0x00000184, 0x000001C1, 0x000001B3, 0x00002748, 0x00000CFF, 0x0000044D, 0x00000425, 0x00000425, 0x000003C1, 0x00000579, 0x000003C1, 0x0000044D, 0x00000399, 0x00000411, 0x000003AD, 0x000003AD, 0x000004C5, 0x000003E9, 0x00000321, 0x000003C1, 0x00000461, 0x00000411, 0x000004ED, 0x000004ED, 0x00000461, 0x000004C5, 0x000004B1, 0x0000044D, 0x0000044D, 0x00000439, 0x0000044D, 0x000003C1, 0x00000579, 0x000003C1, 0x000003C1, 0x000003C1, 0x00000399, 0x000003C1, 0x00000411, 0x0000076D, 0x0000076D, 0x0000076D, 0x00000295, 0x00000295, 0x0000076D, 0x0000076D, 0x00000399, 0x00000399, 0x0000076D, 0x00000321, 0x000001E1, 0x0000053D, 0x00000411, 0x00000411, 0x000002A9, 0x00000411, 0x0000053D, 0x00000619, 0x00000619, 0x000003C1, 0x0000044D, 0x00000425, 0x00000425, 0x000003C1, 0x00000579, 0x000003C1, 0x0000044D, 0x00000489, 0x00000411, 0x00000489, 0x000004B1, 0x000004C5, 0x0000044D, 0x00000321, 0x000004B1, 0x00000461, 0x00000411, 0x0000044D, 0x000004ED, 0x00000461, 0x000004C5, 0x000004B1, 0x0000044D, 0x0000044D, 0x00000439, 0x0000044D, 0x00000489, 0x00000411, 0x0000044D, 0x0000044D, 0x000004B1, 0x00000399, 0x000003C1, 0x00000411, 0x0000044D, 0x0000044D, 0x0000044D, 0x00000295, 0x00000295, 0x0000044D, 0x0000044D, 0x00000399, 0x00000399, 0x0000076D, 0x00000321, 0x000004B1, 0x0000053D, 0x00000411, 0x00000411, 0x000002A9, 0x00000411, 0x0000053D, 0x00000619, 0x00000619, 0x00000489, 0x00000027, 0x00000028, 0x00000016, 0x0000001A, 0x00000027, 0x00000035, 0x0000001F, 0x00000028, 0x00000020, 0x00000015, 0x00000020, 0x00000028, 0x00000026, 0x0000001F, 0x0000001C, 0x0000002B, 0x00000017, 0x00000018, 0x00000011, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000071, 0x00000014, 0x00000017, 0x00000035, 0x0000002F, 0x00000023, 0x0000003D, 0x00000021, 0x00000035, 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000036, 0x00000032, 0x00000031, 0x0000002B, 0x00000039, 0x0000005E, 0x00000054, 0x00000064, 0x00000037, 0x00000036, 0x00000037, 0x00000038, 0x00000037, 0x00000030, 0x00000030, 0x00000036, 0x00000034, 0x0000002C, 0x00000039, 0x0000002F, 0x00000033, 0x00000002, 0x00000033, 0x00000032, 0x00000065, 0x00000002, 0x00000034, 0x0000006E, 0x00000055, 0x0000004B, 0x00000002, 0x000000C2, 0x00000033, 0x00000033, 0x00000055, 0x0000000F, 0x00000022, 0x00000007, 0x00000016, 0x0000003C, 0x0000003C, 0x0000003C, 0x0000000F, 0x00000020, 0x0000002E, 0x00000038, 0x00000017, 0x00000022, 0x0000000C, 0x0000000D, 0x0000000C, 0x00000027, 0x00000030, 0x0000000E, 0x0000002C, 0x00000022, 0x00000031, 0x00000005, 0x00000015, 0x00000018, 0x00000005, 0x00000015, 0x00000018, 0x00000013, 0x00000033, 0x00000023, 0x00000017, 0x00000013, 0x00000031, 0x0000000F, 0x00000007, 0x00000031, 0x00000033, 0x0000002D, 0x00000032, 0x0000001F, 0x00000010, 0x00000006, 0x00000030, 0x00000032, 0x00000031, 0x00000018, 0x00000031, 0x0000002A, 0x0000002E, 0x0000000D, 0x00000018, 0x0000001E, 0x0000001E, 0x0000002E, 0x00000005, 0x0000001C, 0x00000015, 0x0000001C, 0x0000001C, 0x00000005, 0x00000004, 0x00000004, 0x00000005, 0x00000006, 0x00000004, 0x00000016, 0x00000013, 0x0000001C, 0x00000020, 0x00000023, 0x00000025, 0x0000001F, 0x00000024, 0x0000001E, 0x0000001D, 0x0000001E, 0x0000001E, 0x0000001E, 0x0000001E, 0x0000001E, 0x00000023, 0x00000023, 0x00000023, 0x00000021, 0x00000026, 0x00000026, 0x00000023, 0x00000024, 0x00000024, 0x0000002C, 0x0000001C, 0x00000018, 0x00000018, 0x00000021, 0x0000001B, 0x00000019, 0x00000002, 0x000001EF, 0x00000001, 0x0000005C, 0x00000001, 0x0000005C, 0x00000001, 0x000001C3, 0x00000001, 0x00000092, 0x00000001, 0x0000007B, 0x000000A1, 0x000000AC, 0x000000A8, 0x000000A4, 0x000000B2, 0x000000AF, 0x000000C0, 0x000000A4, 0x000000D0, 0x000000D9, 0x000000D5, 0x000000D8, 0x000000E3, 0x000000D8, 0x000000DF, 0x000000A0, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x0000015B, 0x00000001, 0x0000004A, 0x00000006, 0x000000A3, 0x0000000D, 0x00000154, 0x00000037, 0x000000B1, 0x000000EB, 0x000000BC, 0x00000090, 0x0000005B, 0x00000066, 0x0000008E, 0x000000DE, 0x000000DE, 0x00000060, 0x00000006, 0x00000007, 0x00000008, 0x00000012, 0x0000000E, 0x0000000C, 0x0000000C, 0x00000006, 0x00000007, 0x00000011, 0x00000016, 0x00000009, 0x0000000F, 0x0000000F, 0x00000018, 0x0000000B, 0x0000000B, 0x0000000F, 0x00000016, 0x0000000F, 0x0000000F, 0x0000000B, 0x00000012, 0x00000012, 0x00000007, 0x0000000E, 0x0000000F, 0x0000000D, 0x00000008, 0x00000010, 0x00000010, 0x0000000A, 0x00001A20, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000041, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000428, 0x00000488, 0x00000368, 0x000002C4, 0x0000026B, 0x00000149, 0x000007DD, 0x00000841, 0x00000428, 0x00000488, 0x00000368, 0x000002C4, 0x0000026B, 0x00000428, 0x00000488, 0x00000368, 0x000002C4, 0x0000026B, 0x00000843, 0x0000007E, 0x0000007E, 0x000007FD, 0x000001BE, 0x00000155, 0x000005ED, 0x0000052C, 0x00000665, 0x000004BE, 0x000007A3, 0x00000105, 0x00000088, 0x00000088, 0x0000011B, 0x0000011B, 0x00000088, 0x000004D3, 0x000006F4, 0x000001AB, 0x000001A6, 0x00000266, 0x00000341, 0x000000E4, 0x000000BB, 0x0000047A, 0x00000886, 0x00000069, 0x000003C6, 0x000003C6, 0x0000056E, 0x000000DA, 0x0000010C, 0x00000125, 0x000000A5, 0x0000066B, 0x00000734, 0x0000018C, 0x00000124, 0x00001136, 0x0000024F, 0x00000252, 0x000002EE, 0x000002EE, 0x0000013A, 0x0000013C, 0x0000048B, 0x00000245, 0x0000018C, 0x000004A5, 0x0000020B, 0x0000010C, 0x00000457, 0x000005FA, 0x00000563, 0x000000C2, 0x000004B9, 0x00000B09, 0x000003BA, 0x0000023D, 0x000001F3, 0x00001062, 0x00000D63, 0x00000063, 0x000001FE, 0x000001FE, 0x0000020B, 0x00000252, 0x00000213, 0x000001A7, 0x0000020D, 0x0000020D, 0x00000196, 0x00000217, 0x0000010D, 0x00000139, 0x000012F2, 0x0000013C, 0x000002D7, 0x000000E9, 0x00000529, 0x00000BF6, 0x000001E5, 0x000001E5, 0x000002CB, 0x000000E9, 0x00000515, 0x00000493, 0x00000256, 0x00000143, 0x000003B7, 0x0000038B, 0x00000497, 0x0000056A, 0x00000EE3, 0x000003A5, 0x00000567, 0x00000688, 0x00000288, 0x0000014C, 0x00000B40, 0x00000085, 0x000000C7, 0x0000020D, 0x0000072A, 0x00000379, 0x00000081, 0x00000088, 0x00000369, 0x000001F0, 0x000001F6, 0x000001F2, 0x00000193, 0x00000229, 0x00000118, 0x00000118, 0x00000118, 0x00000118, 0x00000118, 0x00000001, 0x00000493, 0x00000118, 0x00000118, 0x00000118, 0x00000118, 0x00000118, 0x000012F9, 0x0000048F, 0x0000010B, 0x00000222, 0x0000048B, 0x00000379, 0x00000119, 0x00000119, 0x000001F5, 0x00000416, 0x00000089, 0x00000089, 0x0000037C, 0x000001A2, 0x000001A2, 0x00000415, 0x000001F0, 0x000001F0, 0x000001F0, 0x000001F0, 0x00000AF1, 0x00000820, 0x0000065C, 0x0000059D, 0x00000585, 0x000000E7, 0x0000060C, 0x0000065C, 0x000000B6, 0x000006CF, 0x000000BA, 0x000000BA, 0x000000BA, 0x00000432, 0x00000494, 0x0000047D, 0x000004AB, 0x0000032B, 0x00000001, 0x00000469, 0x000001A6, 0x0000030E, 0x00001276, 0x0000026C, 0x00000344, 0x00000112, 0x00000104, 0x000001F6, 0x00000112, 0x00000132, 0x000000F4, 0x0000010C, 0x000003A7, 0x0000017D, 0x0000018D, 0x00000112, 0x00000132, 0x000007BF, 0x00000C17, 0x00000695, 0x00000256, 0x000000FD, 0x000000FD, 0x00000153, 0x00000A16, 0x00000567, 0x0000032E, 0x000002C9, 0x00000088, 0x00000155, 0x000002A0, 0x000010DD, 0x0000008E, 0x000001BC, 0x000001AD, 0x0000011B, 0x000002D0, 0x000000E7, 0x000000E7, 0x000002C0, 0x00000105, 0x0000007D, 0x0000007D, 0x00000001, 0x00000A48, 0x00000001, 0x0000007E, 0x00000C99, 0x000000C1, 0x000000BF, 0x00000063, 0x000004B6, 0x0000011B, 0x0000011B, 0x0000011B, 0x0000011B, 0x0000011B, 0x0000011B, 0x000000FA, 0x000000FA, 0x000000FA, 0x000000FA, 0x000000FA, 0x000000FA, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x000000E7, 0x00000F3A, 0x000001F4, 0x000001F0, 0x000000DD, 0x000000DD, 0x0000008B, 0x000000C6, 0x000001A9, 0x0000040B, 0x000002DE, 0x00000116, 0x00000112, 0x00000282, 0x0000070B, 0x000000F3, 0x000002C0, 0x000000F6, 0x00000424, 0x000002FB, 0x000002FB, 0x000002FB, 0x00000187, 0x000013A2, 0x000000A8, 0x00000127, 0x00000126, 0x000000E6, 0x0000011D, 0x00000104, 0x00000104, 0x00000280, 0x0000011E, 0x00000317, 0x0000021A, 0x000001E2, 0x000002DD, 0x000013A2, 0x000000A8, 0x00000127, 0x00000126, 0x000000E6, 0x0000011D, 0x00000104, 0x00000104, 0x00000280, 0x0000011E, 0x00000317, 0x0000021A, 0x000001E2, 0x000002DD, 0x0000041F, 0x00001189, 0x000010D3, 0x00000435, 0x00000122, 0x000005C9, 0x00000F3A, 0x0000120E, 0x000000F5, 0x0000013D, 0x000000BB, 0x00000139, 0x00000304, 0x00000330, 0x0000020D, 0x000002FD, 0x000002D1, 0x000000DF, 0x000001FE, 0x00000805, 0x00000031, 0x0000040E, 0x00000139, 0x00000139, 0x000003BD, 0x00000110, 0x00000110, 0x00000594, 0x000000C6, 0x000000C6, 0x000003AD, 0x000001C1, 0x000001C1, 0x00000644, 0x000003A3, 0x000003A3, 0x000004E6, 0x00000104, 0x00000104, 0x00001220, 0x000000DD, 0x000000ED, 0x0000015A, 0x000001B7, 0x0000019F, 0x0000014F, 0x0000029E, 0x000001E2, 0x00000214, 0x00000216, 0x000001F7, 0x00000225, 0x00000218, 0x000001A7, 0x000000B6, 0x00000201, 0x00000289, 0x000001E2, 0x000001D9, 0x000001A1, 0x00000242, 0x0000023E, 0x00000202, 0x0000023F, 0x00000114, 0x0000013D, 0x00000101, 0x00000102, 0x000000F6, 0x00000116, 0x00000114, 0x00000058, 0x00000FE5, 0x00000279, 0x00000279, 0x00000305, 0x00000279, 0x00000104, 0x0000008D, 0x0000012D, 0x000002F3, 0x000002F3, 0x00000886, 0x0000008A, 0x00000260, 0x0000053D, 0x00000105, 0x0000013C, 0x0000013C, 0x00000194, 0x00000F24, 0x00000168, 0x00000168, 0x00000C48, 0x000015A0, 0x00000395, 0x00001724, 0x00000CFC, 0x0000002E, 0x00000B6B, 0x000002D3, 0x000003FA, 0x000003FC, 0x00000545, 0x00000545, 0x00000684, 0x0000131B, 0x000012E3, 0x00000125, 0x0000012D, 0x0000012B, 0x00000136, 0x00001100, 0x00000001, 0x00000F11, 0x00000158, 0x00000158, 0x0000034E, 0x00000112, 0x0000011D, 0x0000011D, 0x00000109, 0x0000020B, 0x000003AC, 0x000003E8, 0x00000289, 0x00000104, 0x00000104, 0x000000F6, 0x00000105, 0x00000194, 0x00000120, 0x0000010F, 0x00000120, 0x00000377, 0x000000F6, 0x00000001, 0x00000175, 0x000006F5, 0x0000041A, 0x000002A6, 0x00000438, 0x00000159, 0x0000018B, 0x00000140, 0x00000C48, 0x00000314, 0x0000051A, 0x00000001, 0x00000269, 0x00000116, 0x00000116, 0x00000551, 0x00000105, 0x00000105, 0x000006E4, 0x00000434, 0x0000010A, 0x0000010A, 0x000003AF, 0x000000DB, 0x000000DB, 0x000000DB, 0x000000DB, 0x00000738, 0x00000182, 0x00000773, 0x00000104, 0x000002AE, 0x00000105, 0x0000011B, 0x0000011E, 0x000001D2, 0x00000119, 0x0000011F, 0x000001A3, 0x000000DF, 0x00000119, 0x0000011C, 0x000005DF, 0x0000057D, 0x00000134, 0x00000157, 0x00000105, 0x00000120, 0x000000E7, 0x00000487, 0x00000FB8, 0x00000536, 0x0000038F, 0x00000F67, 0x00000495, 0x00000515, 0x0000033A, 0x0000045A, 0x00000143, 0x000001F0, 0x00000119, 0x000001B3, 0x000001C1, 0x00001179, 0x000001A1, 0x000002B4, 0x000002B4, 0x00000346, 0x00000171, 0x000002AD, 0x000002AD, 0x000001A3, 0x000001A3, 0x0000005C, 0x0000005C, 0x00000169, 0x00000170, 0x000002AD, 0x000002AD, 0x000001A6, 0x000001A6, 0x00000217, 0x00000077, 0x000002D1, 0x0000030A, 0x000002AD, 0x000002AD, 0x0000005C, 0x000001AA, 0x000001AA, 0x00000065, 0x00000060, 0x000001A3, 0x000001A3, 0x000000A8, 0x0000007B, 0x00000E87, 0x0000012B, 0x00000138, 0x0000038C, 0x0000010A, 0x0000010A, 0x0000012C, 0x0000012C, 0x0000054F, 0x0000010D, 0x00000111, 0x0000010D, 0x0000010D, 0x00000E7B, 0x000004FC, 0x000004FE, 0x000002D7, 0x0000068F, 0x0000018B, 0x0000018B, 0x00000001, 0x00000A22, 0x000003BF, 0x0000005F, 0x0000005E, 0x00000206, 0x00000001, 0x00000FDF, 0x00000E09, 0x00001368, 0x00001040, 0x00001186, 0x00000FBA, 0x00001555, 0x0000028A, 0x00000001, 0x00000CCA, 0x0000010E, 0x000004A8, 0x0000039A, 0x00000C1A, 0x0000013C, 0x0000031C, 0x0000035F, 0x0000048C, 0x000001F4, 0x000005FB, 0x0000064C, 0x000000F5, 0x0000056E, 0x000001AA, 0x0000019C, 0x0000082A, 0x00000554, 0x00000241, 0x0000022E, 0x0000006A, 0x00000143, 0x00000480, 0x0000042C, 0x00000263, 0x000002FB, 0x000002FB, 0x00000388, 0x000002A4, 0x000004EA, 0x000004C5, 0x00000479, 0x00000515, 0x00000431, 0x0000044B, 0x0000046F, 0x000003CC, 0x00000398, 0x0000056B, 0x000005C8, 0x000002B6, 0x000003D9, 0x0000049D, 0x00000382, 0x000002FF, 0x000001F5, 0x00000525, 0x00000EFF, 0x000000BE, 0x000000C4, 0x00000090, 0x0000010F, 0x0000010F, 0x0000010F, 0x0000010F, 0x00000104, 0x00000104, 0x00000104, 0x00000115, 0x00000115, 0x00000115, 0x00000115, 0x000003FC, 0x0000013C, 0x00000448, 0x00000733, 0x00000288, 0x00000283, 0x00000127, 0x0000085D, 0x000011CC, 0x000006AA, 0x00000429, 0x00000125, 0x00000A47, 0x00000074, 0x00000503, 0x00000062, 0x00000069, 0x00000568, 0x0000010F, 0x00000104, 0x00001257, 0x0000039D, 0x0000028D, 0x000003AA, 0x00000101, 0x000000F4, 0x000000DF, 0x0000020F, 0x00000104, 0x0000050E, 0x00000280, 0x00000280, 0x00000280, 0x00000115, 0x000002E0, 0x00000EF8, 0x000006FD, 0x000007D4, 0x000010A1, 0x00000436, 0x000001F8, 0x0000051B, 0x00000223, 0x00000FFD, 0x000005B2, 0x00000308, 0x0000020A, 0x000001CC, 0x00001228, 0x00000487, 0x00000101, 0x000001EC, 0x00000272, 0x00000080, 0x00000900, 0x0000057D, 0x00000C4D, 0x00000421, 0x00000371, 0x000001A7, 0x00000358, 0x00000325, 0x00000112, 0x000003FB, 0x000005D6, 0x00000454, 0x000008A3, 0x00000E59, 0x000001BE, 0x00000410, 0x00000403, 0x000003FA, 0x00000410, 0x000003AD, 0x00000400, 0x000002E9, 0x000001E4, 0x00000FBC, 0x00000C84, 0x00000655, 0x0000021A, 0x00000180, 0x000012F6, 0x00000D0E, 0x000001A6, 0x0000005C, 0x00000064, 0x00000159, 0x00000120, 0x00000166, 0x0000019A, 0x00000101, 0x00000213, 0x000000D7, 0x000002C9, 0x00000225, 0x00000745, 0x00000705, 0x000005D4, 0x000009BD, 0x000003B2, 0x000004B7, 0x000002F5, 0x00000118, 0x00000389, 0x0000011A, 0x000001D4, 0x000000FA, 0x00000150, 0x00000126, 0x000003E9, 0x00000105, 0x0000029B, 0x0000067A, 0x000003C1, 0x000003C1, 0x000003C1, 0x000006D8, 0x000003C1];
const demo_file_sectors = [0x00000000, 0x0000003A, 0x0000003A, 0x0000003A, 0x0000003A, 0x0000003A, 0x0000003A, 0x00000191, 0x00000191, 0x0000047D, 0x00000630, 0x00000630, 0x00000630, 0x000007EB, 0x000009AC, 0x00000B68, 0x00000D1B, 0x00000D1B, 0x00000D1B, 0x00000EBB, 0x00000EBB, 0x00000EBB, 0x00000EBB, 0x00000EBB, 0x00000EBB, 0x00000EBB, 0x00000EBB, 0x00000EBB, 0x00000EBB, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x00001046, 0x000011F9, 0x000011F9, 0x000011F9, 0x000013AD, 0x00001564, 0x00001713, 0x000018C6, 0x000018C6, 0x000018C6, 0x00001A66, 0x00001A66, 0x00001A66, 0x00001A66, 0x00001A66, 0x00001A66, 0x00001A66, 0x00001A66, 0x00001A66, 0x00001A66, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x00001BF1, 0x000032FB, 0x00003FFA, 0x00004447, 0x00004447, 0x00004447, 0x00004BB4, 0x00004ED5, 0x000050CA, 0x00005517, 0x00005517, 0x00005928, 0x00005928, 0x00005928, 0x00005928, 0x00005928, 0x00005928, 0x00005928, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D39, 0x00005D60, 0x00005D88, 0x00005D9E, 0x00005DB8, 0x00005DDF, 0x00005E14, 0x00005E33, 0x00005E5B, 0x00005E7B, 0x00005E90, 0x00005EB0, 0x00005ED8, 0x00005EFE, 0x00005F1D, 0x00005F39, 0x00005F64, 0x00005F7B, 0x00005F93, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00005FA4, 0x00006000, 0x00006014, 0x0000602B, 0x0000602B, 0x0000602B, 0x0000602B, 0x0000605F, 0x00006078, 0x00006078, 0x0000607A, 0x0000607C, 0x0000607E, 0x00006080, 0x000060B6, 0x000060E8, 0x00006119, 0x00006144, 0x0000617D, 0x00006180, 0x00006180, 0x00006180, 0x00006180, 0x00006180, 0x00006180, 0x000061B8, 0x000061EF, 0x000061EF, 0x000061EF, 0x000061EF, 0x000061EF, 0x000061EF, 0x000061EF, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621E, 0x0000621F, 0x0000621F, 0x0000621F, 0x00006220, 0x00006220, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006221, 0x00006226, 0x0000622A, 0x0000622E, 0x00006233, 0x00006239, 0x0000623D, 0x00006253, 0x00006266, 0x00006282, 0x000062A2, 0x000062C5, 0x000062EA, 0x00006309, 0x0000632D, 0x0000634B, 0x00006368, 0x00006386, 0x000063A4, 0x000063C2, 0x000063E0, 0x000063FE, 0x00006421, 0x0000642A, 0x0000644D, 0x00006456, 0x0000645F, 0x00006468, 0x00006471, 0x0000647A, 0x00006483, 0x0000648C, 0x00006495, 0x0000649E, 0x000064A7, 0x000064B0, 0x000064B9, 0x000064EC, 0x000064EE, 0x00006718, 0x00006719, 0x00006780, 0x00006781, 0x000067E5, 0x000067E6, 0x00006A1D, 0x00006A1E, 0x00006AD1, 0x00006AD2, 0x00006B7A, 0x00006C1C, 0x00006CC8, 0x00006D70, 0x00006E14, 0x00006EC6, 0x00006F75, 0x00007035, 0x000070D9, 0x000071A9, 0x00007282, 0x00007357, 0x0000742F, 0x00007513, 0x000075EB, 0x000076DB, 0x00007776, 0x00007777, 0x00007778, 0x00007779, 0x0000777A, 0x0000777B, 0x0000777C, 0x000078D6, 0x000078D7, 0x00007921, 0x00007927, 0x000079C9, 0x000079D6, 0x00007B27, 0x00007B54, 0x00007C05, 0x00007CF0, 0x00007DAC, 0x00007E3C, 0x00007E97, 0x00007EFD, 0x00007F8B, 0x00008069, 0x00008147, 0x000081A7, 0x000081AD, 0x000081B4, 0x000081BC, 0x000081CE, 0x000081DD, 0x000081E9, 0x000081F3, 0x000081F8, 0x000081FF, 0x00008210, 0x00008226, 0x00008231, 0x00008240, 0x0000824F, 0x00008267, 0x00008272, 0x0000827D, 0x0000828C, 0x000082A2, 0x000082B1, 0x000082C0, 0x000082CD, 0x000082D2, 0x000082E5, 0x000082F0, 0x000082FE, 0x0000830D, 0x0000831D, 0x00008324, 0x00008335, 0x0000834A, 0x00008354, 0x00009CDC, 0x00009D5D, 0x00009DDE, 0x00009E5F, 0x00009EE0, 0x00009F61, 0x00009FE2, 0x0000A063, 0x0000A0E4, 0x0000A165, 0x0000A1E6, 0x0000A267, 0x0000A2E8, 0x0000A369, 0x0000A3EA, 0x0000A46B, 0x0000A4EC, 0x0000A56D, 0x0000A5AE, 0x0000A62F, 0x0000A6B0, 0x0000A731, 0x0000A7B2, 0x0000A833, 0x0000A8B4, 0x0000A935, 0x0000A9B6, 0x0000AA37, 0x0000AAB8, 0x0000AB39, 0x0000ABBA, 0x0000AC3B, 0x0000ACBC, 0x0000AD3D, 0x0000ADBE, 0x0000AE3F, 0x0000AEC0, 0x0000AF41, 0x0000AFC2, 0x0000B043, 0x0000B0C4, 0x0000B145, 0x0000B1C6, 0x0000B247, 0x0000B2C8, 0x0000B349, 0x0000B3CA, 0x0000B44B, 0x0000B4CC, 0x0000B54D, 0x0000B5CE, 0x0000B64F, 0x0000B6D0, 0x0000B751, 0x0000B7D2, 0x0000B853, 0x0000B8D4, 0x0000B955, 0x0000B9D6, 0x0000BA57, 0x0000BAD8, 0x0000BB59, 0x0000BBDA, 0x0000BC5B, 0x0000BCDC, 0x0000BD5D, 0x0000BDDE, 0x0000BE5F, 0x0000BEE0, 0x0000BF61, 0x0000BFE2, 0x0000C063, 0x0000C0E4, 0x0000C165, 0x0000C1E6, 0x0000C267, 0x0000C2E8, 0x0000C369, 0x0000C3EA, 0x0000C46B, 0x0000C4EC, 0x0000C56D, 0x0000C5EE, 0x0000C66F, 0x0000C6F0, 0x0000C771, 0x0000C7F2, 0x0000C873, 0x0000C8F4, 0x0000C975, 0x0000C9F6, 0x0000CA77, 0x0000CAF8, 0x0000CB79, 0x0000CBFA, 0x0000CC7B, 0x0000CCFC, 0x0000CD7D, 0x0000CD7D, 0x0000CD7D, 0x0000CD7D, 0x0000CD7D, 0x0000CD7D, 0x0000CD7D, 0x0000CD7D, 0x0000CD7D, 0x0000CD7D, 0x0000D2A5, 0x0000D2A6, 0x0000D2A7, 0x0000D2C4, 0x0000D46E, 0x0000D48E, 0x0000D4E1, 0x0000D5A1, 0x0000D5A2, 0x0000D5A3, 0x0000D5A7, 0x0000D5AD, 0x0000D5AE, 0x0000D5AF, 0x0000D5B0, 0x0000D5B1, 0x0000D5B2, 0x0000D5B3, 0x0000D5B4, 0x0000D616, 0x0000D697, 0x0000D718, 0x0000D79A, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000D7DC, 0x0000E84E, 0x0000E84F, 0x0000E850, 0x0000E86A, 0x0000EE48, 0x0000EE63, 0x0000EE9A, 0x0000EFB1, 0x0000EFB2, 0x0000EFB6, 0x0000EFCD, 0x0000EFD3, 0x0000EFD4, 0x0000EFD6, 0x0000EFD8, 0x0000EFD9, 0x0000EFDC, 0x0000EFDD, 0x0000EFDE, 0x0000F2DD, 0x0000F2DF, 0x0000F796, 0x0000F818, 0x0000F899, 0x0000F8DB, 0x0000F8DB, 0x00010C52, 0x00010C53, 0x00010C54, 0x00010C77, 0x000112F1, 0x0001131E, 0x0001144E, 0x000117A1, 0x000117A2, 0x000117A8, 0x000117C1, 0x000117D2, 0x000117D3, 0x000117D4, 0x000117D7, 0x000117D8, 0x000117DB, 0x000117E0, 0x000117E1, 0x000117E2, 0x000117ED, 0x000117EE, 0x00011DB2, 0x00011E34, 0x00011E95, 0x00011EF6, 0x00011F78, 0x00011FDA, 0x00011FDA, 0x00011FDA, 0x00011FDA, 0x0001226A, 0x000123E9, 0x000123EA, 0x000123EB, 0x000123F8, 0x00012526, 0x00012528, 0x00012530, 0x00012541, 0x00012542, 0x00012552, 0x00012553, 0x00012554, 0x00012555, 0x00012557, 0x00012558, 0x00012559, 0x0001261E, 0x0001261F, 0x00012620, 0x00012682, 0x00012682, 0x00012682, 0x00012682, 0x00012682, 0x00012682, 0x00012682, 0x00012682, 0x00012682, 0x00012682, 0x00012876, 0x00012877, 0x00012878, 0x0001287D, 0x00012996, 0x00012997, 0x000129A7, 0x000129C0, 0x000129C1, 0x000129C3, 0x000129C5, 0x000129C7, 0x000129C8, 0x000129C9, 0x000129CA, 0x000129CB, 0x000129CD, 0x000129CE, 0x000129CF, 0x000129D0, 0x000129D6, 0x000129D7, 0x00012A18, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79, 0x00012A79];
const demo_file_sizes = [0x0000003A, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000157, 0x00000000, 0x000002EC, 0x000001B3, 0x00000000, 0x00000000, 0x000001BB, 0x000001C1, 0x000001BC, 0x000001B3, 0x00000000, 0x00000000, 0x000001A0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000018B, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001B3, 0x00000000, 0x00000000, 0x000001B4, 0x000001B7, 0x000001AF, 0x000001B3, 0x00000000, 0x00000000, 0x000001A0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000018B, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000170A, 0x00000CFF, 0x0000044D, 0x00000000, 0x00000000, 0x0000076D, 0x00000321, 0x000001F5, 0x0000044D, 0x00000000, 0x00000411, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000411, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000027, 0x00000028, 0x00000016, 0x0000001A, 0x00000027, 0x00000035, 0x0000001F, 0x00000028, 0x00000020, 0x00000015, 0x00000020, 0x00000028, 0x00000026, 0x0000001F, 0x0000001C, 0x0000002B, 0x00000017, 0x00000018, 0x00000011, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000005C, 0x00000014, 0x00000017, 0x00000000, 0x00000000, 0x00000000, 0x00000034, 0x00000019, 0x00000000, 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000036, 0x00000032, 0x00000031, 0x0000002B, 0x00000039, 0x00000003, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000038, 0x00000037, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000002F, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000005, 0x00000004, 0x00000004, 0x00000005, 0x00000006, 0x00000004, 0x00000016, 0x00000013, 0x0000001C, 0x00000020, 0x00000023, 0x00000025, 0x0000001F, 0x00000024, 0x0000001E, 0x0000001D, 0x0000001E, 0x0000001E, 0x0000001E, 0x0000001E, 0x0000001E, 0x00000023, 0x00000009, 0x00000023, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000009, 0x00000033, 0x00000002, 0x0000022A, 0x00000001, 0x00000067, 0x00000001, 0x00000064, 0x00000001, 0x00000237, 0x00000001, 0x000000B3, 0x00000001, 0x000000A8, 0x000000A2, 0x000000AC, 0x000000A8, 0x000000A4, 0x000000B2, 0x000000AF, 0x000000C0, 0x000000A4, 0x000000D0, 0x000000D9, 0x000000D5, 0x000000D8, 0x000000E4, 0x000000D8, 0x000000F0, 0x0000009B, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x0000015A, 0x00000001, 0x0000004A, 0x00000006, 0x000000A2, 0x0000000D, 0x00000151, 0x0000002D, 0x000000B1, 0x000000EB, 0x000000BC, 0x00000090, 0x0000005B, 0x00000066, 0x0000008E, 0x000000DE, 0x000000DE, 0x00000060, 0x00000006, 0x00000007, 0x00000008, 0x00000012, 0x0000000F, 0x0000000C, 0x0000000A, 0x00000005, 0x00000007, 0x00000011, 0x00000016, 0x0000000B, 0x0000000F, 0x0000000F, 0x00000018, 0x0000000B, 0x0000000B, 0x0000000F, 0x00000016, 0x0000000F, 0x0000000F, 0x0000000D, 0x00000005, 0x00000013, 0x0000000B, 0x0000000E, 0x0000000F, 0x00000010, 0x00000007, 0x00000011, 0x00000015, 0x0000000A, 0x00001988, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000041, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000081, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000528, 0x00000001, 0x00000001, 0x0000001D, 0x000001AA, 0x00000020, 0x00000053, 0x000000C0, 0x00000001, 0x00000001, 0x00000004, 0x00000006, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000062, 0x00000081, 0x00000081, 0x00000082, 0x00000042, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001072, 0x00000001, 0x00000001, 0x0000001A, 0x000005DE, 0x0000001B, 0x00000037, 0x00000117, 0x00000001, 0x00000004, 0x00000017, 0x00000006, 0x00000001, 0x00000002, 0x00000002, 0x00000001, 0x00000003, 0x00000001, 0x00000001, 0x000002FF, 0x00000002, 0x000004B7, 0x00000082, 0x00000081, 0x00000042, 0x00000000, 0x00001377, 0x00000001, 0x00000001, 0x00000023, 0x0000067A, 0x0000002D, 0x00000130, 0x00000353, 0x00000001, 0x00000006, 0x00000019, 0x00000011, 0x00000001, 0x00000001, 0x00000003, 0x00000001, 0x00000003, 0x00000005, 0x00000001, 0x00000001, 0x0000000B, 0x00000001, 0x000005C4, 0x00000082, 0x00000061, 0x00000061, 0x00000082, 0x00000062, 0x00000000, 0x00000000, 0x00000000, 0x00000290, 0x0000017F, 0x00000001, 0x00000001, 0x0000000D, 0x0000012E, 0x00000002, 0x00000008, 0x00000011, 0x00000001, 0x00000010, 0x00000001, 0x00000001, 0x00000001, 0x00000002, 0x00000001, 0x00000001, 0x000000C5, 0x00000001, 0x00000001, 0x00000062, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000001F4, 0x00000001, 0x00000001, 0x00000005, 0x00000119, 0x00000001, 0x00000010, 0x00000019, 0x00000001, 0x00000002, 0x00000002, 0x00000002, 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000002, 0x00000001, 0x00000001, 0x00000001, 0x00000006, 0x00000001, 0x00000041, 0x00000061, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000];
const dos_chars = ["\u002E", "\u263A", "\u263B", "\u2665", "\u2666", "\u2663", "\u2660", "\u2022", "\u25D8", "\u25CB", "\u25D9", "\u2642", "\u2640", "\u266A", "\u266B", "\u263C", "\u25BA", "\u25C4", "\u2195", "\u203C", "\u00B6", "\u00A7", "\u25AC", "\u21A8", "\u2191", "\u2193", "\u2192", "\u2190", "\u221F", "\u2194", "\u25B2", "\u25BC", "\u0020", "\u0021", "\u0022", "\u0023", "\u0024", "\u0025", "\u0026", "\u0027", "\u0028", "\u0029", "\u002A", "\u002B", "\u002C", "\u002D", "\u002E", "\u002F", "\u0030", "\u0031", "\u0032", "\u0033", "\u0034", "\u0035", "\u0036", "\u0037", "\u0038", "\u0039", "\u003A", "\u003B", "\u003C", "\u003D", "\u003E", "\u003F", "\u0040", "\u0041", "\u0042", "\u0043", "\u0044", "\u0045", "\u0046", "\u0047", "\u0048", "\u0049", "\u004A", "\u004B", "\u004C", "\u004D", "\u004E", "\u004F", "\u0050", "\u0051", "\u0052", "\u0053", "\u0054", "\u0055", "\u0056", "\u0057", "\u0058", "\u0059", "\u005A", "\u005B", "\u005C", "\u005D", "\u005E", "\u005F", "\u0060", "\u0061", "\u0062", "\u0063", "\u0064", "\u0065", "\u0066", "\u0067", "\u0068", "\u0069", "\u006A", "\u006B", "\u006C", "\u006D", "\u006E", "\u006F", "\u0070", "\u0071", "\u0072", "\u0073", "\u0074", "\u0075", "\u0076", "\u0077", "\u0078", "\u0079", "\u007A", "\u007B", "\u007C", "\u007D", "\u007E", "\u2302", "\u00C7", "\u00FC", "\u00E9", "\u00E2", "\u00E4", "\u00E0", "\u00E5", "\u00E7", "\u00EA", "\u00EB", "\u00E8", "\u00EF", "\u00EE", "\u00EC", "\u00C4", "\u00C5", "\u00C9", "\u00E6", "\u00C6", "\u00F4", "\u00F6", "\u00F2", "\u00FB", "\u00F9", "\u00FF", "\u00D6", "\u00DC", "\u00A2", "\u00A3", "\u00A5", "\u20A7", "\u0192", "\u00E1", "\u00ED", "\u00F3", "\u00FA", "\u00F1", "\u00D1", "\u00AA", "\u00BA", "\u00BF", "\u2310", "\u00AC", "\u00BD", "\u00BC", "\u00A1", "\u00AB", "\u00BB", "\u2591", "\u2592", "\u2593", "\u2502", "\u2524", "\u2561", "\u2562", "\u2556", "\u2555", "\u2563", "\u2551", "\u2557", "\u255D", "\u255C", "\u255B", "\u2510", "\u2514", "\u2534", "\u252C", "\u251C", "\u2500", "\u253C", "\u255E", "\u255F", "\u255A", "\u2554", "\u2569", "\u2566", "\u2560", "\u2550", "\u256C", "\u2567", "\u2568", "\u2564", "\u2565", "\u2559", "\u2558", "\u2552", "\u2553", "\u256B", "\u256A", "\u2518", "\u250C", "\u2588", "\u2584", "\u258C", "\u2590", "\u2580", "\u03B1", "\u00DF", "\u0393", "\u03C0", "\u03A3", "\u03C3", "\u00B5", "\u03C4", "\u03A6", "\u0398", "\u03A9", "\u03B4", "\u221E", "\u03C6", "\u03B5", "\u2229", "\u2261", "\u00B1", "\u2265", "\u2264", "\u2320", "\u2321", "\u00F7", "\u2248", "\u00B0", "\u2022", "\u00B7", "\u221A", "\u207F", "\u00B2", "\u25A0", "\u00A0"];

let infile;
let audio_context;
let midi_access;
let midi_select = document.createElement("select");
let midi_handler = () => {};
let convolver_node;
let convolver_buffer;
const note_base = 2 ** (1/12);
const note_factor = 1 / 1298141.5161388416; // this number was achieved via SCIENCE!
let file_list = [];
let dispose_old = null;
const mips_registers = ['zero','at','v0','v1','a0','a1','a2','a3','t0','t1','t2','t3','t4','t5','t6','t7','s0','s1','s2','s3','s4','s5','s6','s7','t8','t9','k0','k1','gp','sp','fp','ra'];
const mips_instructions = {
	"000000????????????????????100000": {name: "add", args: "{r3}, {r1}, {r2}"},
	"001000??????????????????????????": {name: "addi", args: "{r2}, {r1}, {imm}"},
	"001001??????????????????????????": {name: "addiu", args: "{r2}, {r1}, {imm}"},
	"000000????????????????????100001": {name: "addu", args: "{r3}, {r1}, {r2}"},
	"000000????????????????????100100": {name: "and", args: "{r3}, {r1}, {r2}"},
	"001100??????????????????????????": {name: "andi", args: "{r2}, {r1}, {imm}"},
	"000100??????????????????????????": {name: "beq", args: "{r1}, {r2}, {b}"},
	"010100??????????????????????????": {name: "beql", args: "{r1}, {r2}, {b}"},
	"000001?????00001????????????????": {name: "bgez", args: "{r1}, {b}"},
	"000001?????10001????????????????": {name: "bgezal", args: "{r1}, {b}"},
	"000001?????10011????????????????": {name: "bgezall", args: "{r1}, {b}"},
	"000001?????00011????????????????": {name: "bgezl", args: "{r1}, {b}"},
	"000111??????????????????????????": {name: "bgtz", args: "{r1}, {b}"},
	"010111??????????????????????????": {name: "bgtzl", args: "{r1}, {b}"},
	"000110??????????????????????????": {name: "blez", args: "{r1}, {b}"},
	"010110??????????????????????????": {name: "blezl", args: "{r1}, {b}"},
	"000001?????00000????????????????": {name: "bltz", args: "{r1}, {b}"},
	"000001?????10000????????????????": {name: "bltzal", args: "{r1}, {b}"},
	"000001?????10010????????????????": {name: "bltzall", args: "{r1}, {b}"},
	"000001?????00010????????????????": {name: "bltzl", args: "{r1}, {b}"},
	"000101??????????????????????????": {name: "bne", args: "{r1}, {r2}, {b}"},
	"010101??????????????????????????": {name: "bnel", args: "{r1}, {r2}, {b}"},
	"000000????????????????????001101": {name: "break", args: "{code}"},
	"000000????????????????????101100": {name: "dadd", args: "{r3}, {r1}, {r2}"},
	"011000??????????????????????????": {name: "daddi", args: "{r2}, {r1}, {imm}"},
	"011001??????????????????????????": {name: "daddiu", args: "{r2}, {r1}, {imm}"},
	"000000????????????????????101101": {name: "daddu", args: "{r3}, {r1}, {r2}"},
	"000000????????????????????011010": {name: "div", args: "{r1}, {r2}"},
	"000000????????????????????011011": {name: "divu", args: "{r1}, {r2}"},
	"000000????????????????????111000": {name: "dsll", args: "{r3}, {r2}, {i4}"},
	"000000????????????????????111100": {name: "dsll32", args: "{r3}, {r2}, {i4}"},
	"000000????????????????????010100": {name: "dsllv", args: "{r3}, {r2}, {r1}"},
	"000000????????????????????111011": {name: "dsra", args: "{r3}, {r2}, {i4}"},
	"000000????????????????????111111": {name: "dsra32", args: "{r3}, {r2}, {i4}"},
	"000000????????????????????010111": {name: "dsrav", args: "{r3}, {r2}, {r1}"},
	"000000????????????????????111010": {name: "dsrl", args: "{r3}, {r2}, {i4}"},
	"000000????????????????????111110": {name: "dsrl32", args: "{r3}, {r2}, {i4}"},
	"000000????????????????????010110": {name: "dsrlv", args: "{r3}, {r2}, {r1}"},
	"000000????????????????????101110": {name: "dsub", args: "{r3}, {r1}, {r2}"},
	"000000????????????????????101111": {name: "dsubu", args: "{r3}, {r1}, {r2}"},
	"000010??????????????????????????": {name: "j", args: "{j}"},
	"000011??????????????????????????": {name: "jal", args: "{j}"},
	"000000????????????????????001001": {name: "jalr", args: "{r3}, {r1}"},
	"000000????????????????????001000": {name: "jr", args: "{r1}"},
	"100000??????????????????????????": {name: "lb", args: "{r2}, {imm}({r1})"},
	"100100??????????????????????????": {name: "lbu", args: "{r2}, {imm}({r1})"},
	"110111??????????????????????????": {name: "ld", args: "{r2}, {imm}({r1})"},
	"011010??????????????????????????": {name: "ldl", args: "{r2}, {imm}({r1})"},
	"011011??????????????????????????": {name: "ldr", args: "{r2}, {imm}({r1})"},
	"100001??????????????????????????": {name: "lh", args: "{r2}, {imm}({r1})"},
	"100101??????????????????????????": {name: "lhu", args: "{r2}, {imm}({r1})"},
	"001111??????????????????????????": {name: "lui", args: "{r2}, {imm}"},
	"100011??????????????????????????": {name: "lw", args: "{r2}, {imm}({r1})"},
	"100010??????????????????????????": {name: "lwl", args: "{r2}, {imm}({r1})"},
	"100110??????????????????????????": {name: "lwr", args: "{r2}, {imm}({r1})"},
	"100111??????????????????????????": {name: "lwu", args: "{r2}, {imm}({r1})"},
	"000000????????????????????010000": {name: "mfhi", args: "{r3}"},
	"000000????????????????????010010": {name: "mflo", args: "{r3}"},
	"000000????????????????????001011": {name: "movn", args: "{r3}, {r1}, {r2}"},
	"000000????????????????????001010": {name: "movz", args: "{r3}, {r1}, {r2}"},
	"000000????????????????????010001": {name: "mthi", args: "{r1}"},
	"000000????????????????????010011": {name: "mfhi", args: "{r1}"},
	"000000????????????????????011000": {name: "mult", args: "{r1}, {r2}"},
	"000000????????????????????011001": {name: "multu", args: "{r1}, {r2}"},
	"000000????????????????????100111": {name: "nor", args: "{r3}, {r1}, {r2}"},
	"000000????????????????????100101": {name: "or", args: "{r3}, {r1}, {r2}"},
	"001101??????????????????????????": {name: "ori", args: "{r2}, {r1}, {imm}"},
	"110011??????????????????????????": {name: "pref", args: "{i2}, {imm}({r1})"},
	"101000??????????????????????????": {name: "sb", args: "{r2}, {imm}({r1})"},
	"111111??????????????????????????": {name: "sd", args: "{r2}, {imm}({r1})"},
	"101100??????????????????????????": {name: "sdl", args: "{r2}, {imm}({r1})"},
	"101101??????????????????????????": {name: "sdr", args: "{r2}, {imm}({r1})"},
	"101001??????????????????????????": {name: "sh", args: "{r2}, {imm}({r1})"},
	"000000????????????????????000000": {name: "sll", args: "{r3}, {r2}, {i4}"},
	"000000????????????????????000100": {name: "sllv", args: "{r3}, {r2}, {r1}"},
	"000000????????????????????101010": {name: "slt", args: "{r3}, {r1}, {r2}"},
	"001010??????????????????????????": {name: "slti", args: "{r2}, {r1}, {imm}"},
	"001011??????????????????????????": {name: "sltiu", args: "{r2}, {r1}, {imm}"},
	"000000????????????????????101011": {name: "sltu", args: "{r3}, {r1}, {r2}"},
	"000000????????????????????000011": {name: "sra", args: "{r3}, {r2}, {i4}"},
	"000000????????????????????000111": {name: "srav", args: "{r3}, {r2}, {r1}"},
	"000000????????????????????000010": {name: "srl", args: "{r3}, {r2}, {i4}"},
	"000000????????????????????000110": {name: "srlv", args: "{r3}, {r2}, {r1}"},
	"000000????????????????????100010": {name: "sub", args: "{r3}, {r1}, {r2}"},
	"000000????????????????????100011": {name: "subu", args: "{r3}, {r1}, {r2}"},
	"101011??????????????????????????": {name: "sw", args: "{r2}, {imm}({r1})"},
	"101010??????????????????????????": {name: "swl", args: "{r2}, {imm}({r1})"},
	"000000????????????????????001111": {name: "sync", args: "{i4}"},
	"000000????????????????????001100": {name: "syscall", args: "{code}"},
	// skip traps
	"000000????????????????????100110": {name: "xor", args: "{r3}, {r1}, {r2}"},
	"001110??????????????????????????": {name: "xori", args: "{r2}, {r1}, {imm}"},
	// COP1 (fpu) instructions
	"01000110000???????????????000101": {name: "abs.s", args: "{fr4}, {fr3}"},
	"01000110000???????????????000000": {name: "add.s", args: "{fr4}, {fr3}, {fr2}"},
	"01000110000???????????????011000": {name: "adda.s", args: "{fr3}, {fr2}"},
	"0100010100000000????????????????": {name: "bc1f", args: "{b}"},
	"0100010100000010????????????????": {name: "bc1fl", args: "{b}"},
	"0100010100000001????????????????": {name: "bc1t", args: "{b}"},
	"0100010100000011????????????????": {name: "bc1tl", args: "{b}"},
	"0100010100000000????????????????": {name: "bc1f", args: "{b}"},
	"01000110000???????????????110010": {name: "c.eq.s", args: "{fr3}, {fr2}"},
	"01000110000???????????????110000": {name: "c.f.s", args: "{fr3}, {fr2}"},
	"01000110000???????????????110110": {name: "c.le.s", args: "{fr3}, {fr2}"},
	"01000110000???????????????110100": {name: "c.lt.s", args: "{fr3}, {fr2}"},
	// Skipping cfc1 and ctc1
	"01000110100???????????????100000": {name: "cvt.s.w", args: "{fr4}, {fr3}"},
	"01000110000???????????????100100": {name: "cvt.w.s", args: "{fr4}, {fr3}"},
	"01000110000???????????????000011": {name: "div.s", args: "{fr4}, {fr3}, {fr2}"},
	"110001??????????????????????????": {name: "lwc1", args: "{fr2}, {imm}({r1})"},
	"01000110000???????????????011100": {name: "madd.s", args: "{fr4}, {fr3}, {fr2}"},
	"01000110000???????????????011110": {name: "madda.s", args: "{fr3}, {fr2}"},
	"01000110000???????????????101000": {name: "max.s", args: "{fr4}, {fr3}, {fr2}"},
	"01000100000?????????????????????": {name: "mfc1", args: "{r2}, {fr3}"},
	"01000110000???????????????101001": {name: "min.s", args: "{fr4}, {fr3}, {fr2}"},
	"01000110000???????????????000110": {name: "mov.s", args: "{fr4}, {fr3}"},
	"01000110000???????????????011101": {name: "msub.s", args: "{fr4}, {fr3}, {fr2}"},
	"01000110000???????????????011111": {name: "msuba.s", args: "{fr3}, {fr2}"},
	"01000100100?????????????????????": {name: "mfc1", args: "{r2}, {fr3}"},
	"01000110000???????????????000010": {name: "mul.s", args: "{fr4}, {fr3}, {fr2}"},
	"01000110000???????????????011010": {name: "mula.s", args: "{fr3}, {fr2}"},
	"01000110000???????????????000111": {name: "neg.s", args: "{fr4}, {fr3}"},
	"01000110000???????????????010110": {name: "rsqrt.s", args: "{fr4}, {fr3}, {fr2}"},
	"01000110000???????????????000100": {name: "sqrt.s", args: "{fr4}, {fr2}"},
	"01000110000???????????????000001": {name: "sub.s", args: "{fr4}, {fr3}, {fr2}"},
	"01000110000???????????????011001": {name: "suba.s", args: "{fr3}, {fr2}"},
	"111001??????????????????????????": {name: "swc1", args: "{fr2}, {imm}({r1})"},
	// Sony-specific MIPS instructions
	"011100????????????????????011010": {name: "div1", args: "{r1}, {r2}"},
	"011100????????????????????011011": {name: "divu1", args: "{r1}, {r2}"},
	"011110??????????????????????????": {name: "lq", args: "{r2}, {imm}({r1})"},
	"011100????????????????????000000": {name: "madd", args: "{r3}, {r1}, {r2}"},
	"011100????????????????????100000": {name: "madd1", args: "{r3}, {r1}, {r2}"},
	"011100????????????????????000001": {name: "maddu", args: "{r3}, {r1}, {r2}"},
	"011100????????????????????100001": {name: "maddu1", args: "{r3}, {r1}, {r2}"},
	"011100????????????????????010000": {name: "mfhi1", args: "{r3}"},
	"011100????????????????????010010": {name: "mflo1", args: "{r3}"},
	"000000????????????????????101000": {name: "mfsa", args: "{r3}"},
	"011100????????????????????010001": {name: "mthi1", args: "{r1}"},
	"011100????????????????????010011": {name: "mtlo1", args: "{r1}"}, // nice job sony docs you screwed up
	"000000????????????????????101001": {name: "mtsa", args: "{r1}"},
	"000001?????11000????????????????": {name: "mtsab", args: "{r1}, {imm}"},
	"000001?????11001????????????????": {name: "mtsah", args: "{r1}, {imm}"},
	"000000????????????????????011000": {name: "mult", args: "{r3}, {r1}, {r2}"},
	"011100????????????????????011000": {name: "mult1", args: "{r3}, {r1}, {r2}"},
	"000000????????????????????011001": {name: "multu", args: "{r3}, {r1}, {r2}"},
	"011100????????????????????011001": {name: "multu1", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00101101000": {name: "pabsh", args: "{r3}, {r2}"},
	"011100???????????????00001101000": {name: "pabsw", args: "{r3}, {r2}"},
	"011100???????????????01000001000": {name: "paddb", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00100001000": {name: "paddh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11000001000": {name: "paddsb", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10100001000": {name: "paddsh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10000001000": {name: "paddsw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11000101000": {name: "paddub", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10100101000": {name: "padduh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10000101000": {name: "padduw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00000001000": {name: "paddw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00100101000": {name: "padsbh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10010001001": {name: "pand", args: "{r3}, {r1}, {r2}"},
	"011100???????????????01010101000": {name: "pceqb", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00110101000": {name: "pceqh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00010101000": {name: "pceqw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????01010001000": {name: "pcgtb", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00110001000": {name: "pcgth", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00010001000": {name: "pcgtw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11011101001": {name: "pcpyh", args: "{r3}, {r2}"},
	"011100???????????????01110001001": {name: "pcpyld", args: "{r3}, {r1}, {r2}"},
	"011100???????????????01110101001": {name: "pcpyud", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11101001001": {name: "pdivbw", args: "{r1}, {r2}"},
	"011100???????????????01101101001": {name: "pdivuw", args: "{r1}, {r2}"},
	"011100???????????????01101001001": {name: "pdivw", args: "{r1}, {r2}"},
	"011100???????????????11010101001": {name: "pexch", args: "{r3}, {r2}"},
	"011100???????????????11110101001": {name: "pexcw", args: "{r3}, {r2}"},
	"011100???????????????11010001001": {name: "pexeh", args: "{r3}, {r2}"},
	"011100???????????????11110001001": {name: "pexew", args: "{r3}, {r2}"},
	"011100???????????????11110001000": {name: "pext5", args: "{r3}, {r2}"},
	"011100???????????????11010001000": {name: "pextlb", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10110001000": {name: "pextlh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10010001000": {name: "pextlw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11010101000": {name: "pextub", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10110101000": {name: "pextuh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10010101000": {name: "pextuw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10001001001": {name: "phmadh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10101001001": {name: "phmsbh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????01010101001": {name: "pinteh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????01010001001": {name: "pinth", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10000001001": {name: "pmaddh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00000101001": {name: "pmadduw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00000001001": {name: "pmaddw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00111001000": {name: "pmaxh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00011001000": {name: "pmaxw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????01000001001": {name: "pmfhi", args: "{r3}"},
	"011100???????????????00011110000": {name: "pmfhl.lh", args: "{r3}"},
	"011100???????????????00000110000": {name: "pmfhl.lw", args: "{r3}"},
	"011100???????????????00100110000": {name: "pmfhl.sh", args: "{r3}"},
	"011100???????????????00010110000": {name: "pmfhl.slw", args: "{r3}"},
	"011100???????????????00001110000": {name: "pmfhl.uw", args: "{r3}"},
	"011100???????????????01001001001": {name: "pmflo", args: "{r3}"},
	"011100???????????????00111101000": {name: "pminh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00011101000": {name: "pminw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10100001001": {name: "psubh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00100001001": {name: "pmsubw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????01000101001": {name: "pmthi", args: "{r1}"},
	"011100???????????????00000110001": {name: "pmthl.lw", args: "{r1}"},
	"011100???????????????01001101001": {name: "pmtlo", args: "{r1}"},
	"011100???????????????11100001001": {name: "pmulth", args: "{r3}, {r1}, {r2}"},
	"011100???????????????01100101001": {name: "pmultuw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????01100001001": {name: "pmultw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10011101001": {name: "pnor", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10010101001": {name: "por", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11111001000": {name: "ppac5", args: "{r3}, {r2}"},
	"011100???????????????11011001000": {name: "ppacb", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10111001000": {name: "ppach", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10011001000": {name: "ppacw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11011001001": {name: "prevh", args: "{r3}, {r2}"},
	"011100???????????????11111001001": {name: "prot3w", args: "{r3}, {r2}"},
	"011100????????????????????110100": {name: "psllh", args: "{r3}, {r2}, {i4}"},
	"011100???????????????00010001001": {name: "psllvw", args: "{r3}, {r1}, {r2}"},
	"011100????????????????????111100": {name: "psllw", args: "{r3}, {r2}, {i4}"},
	"011100????????????????????110111": {name: "psrah", args: "{r3}, {r2}, {i4}"},
	"011100???????????????00011101001": {name: "psravw", args: "{r3}, {r1}, {r2}"},
	"011100????????????????????111111": {name: "psraw", args: "{r3}, {r2}, {i4}"},
	"011100????????????????????110110": {name: "psrlh", args: "{r3}, {r2}, {i4}"},
	"011100???????????????00011001001": {name: "psrlvw", args: "{r3}, {r1}, {r2}"},
	"011100????????????????????111110": {name: "psrlw", args: "{r3}, {r2}, {i4}"},
	"011100???????????????01001001000": {name: "psub", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00101001000": {name: "psubh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11001001000": {name: "psubsb", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10101001000": {name: "psubsh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10001001000": {name: "psubsw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11001101000": {name: "psubub", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10101101000": {name: "psubuh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10001101000": {name: "psubuw", args: "{r3}, {r1}, {r2}"},
	"011100???????????????00001001000": {name: "psubh", args: "{r3}, {r1}, {r2}"},
	"011100???????????????10011001001": {name: "pxor", args: "{r3}, {r1}, {r2}"},
	"011100???????????????11011101000": {name: "qfsrv", args: "{r3}, {r1}, {r2}"},
	"011111??????????????????????????": {name: "sq", args: "{r2}, {imm}({r1})"},
}
/** @type{Array<[OfflineAudioContext,HTMLDivElement,HTMLDivElement]>} */
let render_list = [];
let showing_progress = false;

function progress_frame() {
	showing_progress = true;
	try {
		for(let item of render_list) {
			item[2].style.width = (item[0].currentTime / item[0].length * item[0].sampleRate * 100) + "%";
		}
		if(render_list.length)
			window.requestAnimationFrame(progress_frame);
		else
			showing_progress = false;
		return;
	} finally {
		showing_progresss = false;
	}
}

function add_rendering_context(ctx, name) {
	let container = document.createElement("div");
	
	let name_div = document.createElement("div");
	name_div.textContent = name;
	container.appendChild(name_div);
	
	let progressbar = document.createElement("div");
	progressbar.classList.add("progressbar");
	container.appendChild(progressbar);

	let fill = document.createElement("div");
	fill.classList.add("fill");
	fill.style.width = "0%";
	progressbar.appendChild(fill);

	document.getElementById("progress-list").appendChild(container);
	
	let item = [ctx, container, fill];
	render_list.push(item);
	
	if(!showing_progress) {
		progress_frame();
	}

	ctx.addEventListener("complete", () => {
		let idx = render_list.indexOf(item);
		if(idx != -1) render_list.splice(idx, 1);
		document.getElementById("progress-list").removeChild(container);
	})
}

const adsr_rates = new Uint32Array(160);
for(let i = 0; i < 160; i++) {
	let shift = (i - 32) >> 2;
	let rate = (i & 3) + 4;
	rate = Math.floor(rate * (2 ** shift));
	adsr_rates[i] = Math.min(rate, 0x3FFFFFFF);
}

async function load_gamefile() {
	audio_context = new AudioContext({sampleRate: 48000}); // the PS2 SPU runs at 48 kHz
	
	convolver_node = audio_context.createConvolver();
	convolver_node.connect(audio_context.destination);
	fetch(impulse_response_url).then(async (response) => {
		convolver_buffer = await audio_context.decodeAudioData(await response.arrayBuffer())
		convolver_node.buffer = convolver_buffer;
	});
	
	document.getElementById("loadmenu").style.display = "none";
	infile = document.getElementById("fileinput").files[0];
	let filelistelem = document.getElementById("filelist");
	
	let this_sectors = file_sectors;
	let this_sizes = file_sizes;
	if(infile.size == 156485632) {
		do_log("Using demo sectors");
		this_sectors = demo_file_sectors;
		this_sizes = demo_file_sizes;
	} else if(infile.size == 1902393344) {
		do_log("Using Oct. 13 prototype build sectors");
		this_sectors = oct13_file_sectors;
		this_sizes = oct13_file_sizes;
	} else if(infile.size != 1902385152) {
		this_sectors = [0];
		this_sizes = [Math.ceil(infile.size / 2048)];
	} else {
		do_log("Using retail sectors");
	}
	
	for(let i = 0; i < this_sectors.length; i++) {
		let index_string = "0x"+i.toString(16).padStart(4,0);
		let fileelem = document.createElement("div");
		filelistelem.appendChild(fileelem);
		if(this_sizes[i] == 0) {
			fileelem.textContent = index_string+": Empty";
			file_list.push(null);
		} else {
			let part_header_blob = infile.slice(this_sectors[i]*2048, this_sectors[i]*2048+48);
			let part_header = new Uint8Array(await new Response(part_header_blob).arrayBuffer());
			if(part_header[0] == 0x49 && part_header[1] == 0x44 && part_header[2] == 0x4D) {
				fileelem.textContent = index_string+": IDM";
				let part_blob = infile.slice(this_sectors[i]*2048, (this_sectors[i]+this_sizes[i])*2048);
				let part = new Uint8Array(await new Response(part_blob).arrayBuffer());
				let part_dv = new DataView(part.buffer);
				let curr_addr = 0;
				let file_entry = [];
				file_list.push(file_entry);
				let indent = 0;
				while(curr_addr < part.length) {
					if(part[curr_addr] == 0x49 && part[curr_addr+1] == 0x44 && part[curr_addr+2] == 0x4D) {
						if(!(function add_file(file_addr, do_adjust = true) {
							let absolute_offset = file_addr + this_sectors[i]*2048;
							let size = part_dv.getInt32(file_addr+8, true);
							let header_size = part_dv.getInt16(file_addr+6, true) + 16;
							let sub_blob = part_blob.slice(file_addr, file_addr+size);
							let partelem = document.createElement("div");
							filelist.appendChild(partelem);
							let globalid = (part[file_addr+14] + part[file_addr+15] * 256);
							let tc = "\xa0\xa0IDM " + part[file_addr+3].toString(16) + " " + part[file_addr+4].toString(16) + " " + part[file_addr+5].toString(16) + "[" + (part[file_addr+4] + part[file_addr+5] * 256) + "]" + (globalid ? "{" + globalid + "}" : "");
							for(let i = 0; i < indent; i++) {
								tc = "\xa0\xa0" + tc;
							}
							let this_indent = indent;
							let ident = [part[file_addr+3],part[file_addr+4],part[file_addr+5]];
							if(ident[0] == 4 && ident[1] == 4 && ident[2] == 0) {
								tc += " (Texture)";
							} else if(ident[0] == 1 && ident[1] == 0 && ident[2] == 0) {
								tc += " (EOF)";
								if(indent > 0)
									indent--;
							} else if(ident[0] == 4 && ident[1] == 0x25 && ident[2] == 0) {
								tc += " (Script)";
							} else if(ident[0] == 1 && ident[1] == 0x13 && ident[2] == 0) {
								tc += " (Zone Map)";
							} else if(ident[0] == 1 && (ident[1] == 0x12 || ident[1] == 0x20 || ident[1] == 0x8) && ident[2] == 0) {
								if(part[file_addr+header_size] == 0x49 && part[file_addr+header_size+1] == 0x44 && part[file_addr+header_size+2] == 0x4D) {
									size = header_size;
									indent++;
								}
							} else if(ident[0] == 1 && ident[1] == 0x1D && ident[2] == 0) {
								tc += " (Object Pack)"
							} else if(ident[0] == 1 && ident[1] == 0xD && ident[2] == 0) {
								tc += " (Model)";
							} else if(ident[0] == 1 && ident[1] == 0x3 && ident[2] == 0) {
								tc += " (Map Geometry)";
							} else if(ident[0] == 1 && ident[1] == 0x2 && ident[2] == 0) {
								tc += " (Material List)";
							}
							partelem.textContent = tc;
							if(size <= 0) {
								console.warn(size + " size at file " + i);
								return false;
							}
							if(do_adjust)
								curr_addr += size;
							partelem.addEventListener("click", (e) => {
								for(let othersel of document.querySelectorAll(".file-item-selected")) {
									othersel.classList.remove("file-item-selected");
								}
								partelem.classList.add("file-item-selected");
								set_file(sub_blob, file_entry, e.ctrlKey);
							});
							file_entry.push({blob: sub_blob, ident, size, indent: this_indent, offset: absolute_offset});
							if(ident[0] == 1 && ident[1] == 0x1D && ident[2] == 0) {
								indent += 2;
								let arr1_size = part_dv.getUint32(file_addr+header_size, true);
								let arr1_addr = part_dv.getUint32(file_addr+header_size + 0x4, true) + header_size+file_addr;
								for(let i = 0; i < arr1_size; i++) {
									let item_div = document.createElement("div");
									filelist.appendChild(item_div);
									item_div.textContent = "".padStart(indent*2, "\xa0") + i + ":";
									let item_elem = part_dv.getUint32(arr1_addr + i*4, true);
									if(!item_elem) continue;
									item_elem += header_size+file_addr;
									let model_addr = part_dv.getUint32(item_elem + 0x1d0, true);
									let other_addr = part_dv.getUint32(item_elem + 0x1d4, true);
									//do_log(model_addr + ", " + other_addr);
									if(model_addr) add_file(model_addr + header_size+file_addr, false);
									if(other_addr) add_file(other_addr + header_size+file_addr, false);
								}
								indent -= 2;
							}
							return true;
						})(curr_addr)) break;
					} else {
						if(curr_addr % 2048 == 0) {
							curr_addr += 2048;
						} else {
							curr_addr = Math.ceil(curr_addr / 2048) * 2048
						}
					}
				}
			} else {
				if(part_header[24] == 0x53 && part_header[25] == 0x42 && part_header[26] == 0x6C && part_header[27] == 0x6B) {
					fileelem.textContent = index_string+": Sound bank (" + (part_header[0x2e] + (part_header[0x2f] * 256)) + " sounds)";
					let part_blob = infile.slice(this_sectors[i]*2048, (this_sectors[i]+this_sizes[i])*2048);
					fileelem.addEventListener("click", (e) => {
						for(let othersel of document.querySelectorAll(".file-item-selected")) {
							othersel.classList.remove("file-item-selected");
						}
						fileelem.classList.add("file-item-selected");
						set_sblk(part_blob);
					});
				} else if(part_header[32] == 0x53 && part_header[33] == 0x42 && part_header[34] == 0x76 && part_header[35] == 0x32) {
					fileelem.textContent = index_string+": Music file \"" + [...part_header.slice(44,48)].map((cc)=>{return String.fromCharCode(cc);}).join("") + "\"";
					let part_blob = infile.slice(this_sectors[i]*2048, (this_sectors[i]+this_sizes[i])*2048);
					fileelem.addEventListener("click", (e) => {
						for(let othersel of document.querySelectorAll(".file-item-selected")) {
							othersel.classList.remove("file-item-selected");
						}
						fileelem.classList.add("file-item-selected");
						set_sbv2(part_blob);
					});
				} else if(part_header[0] == 0x56 && part_header[1] == 0x41 && part_header[2] == 0x47 && part_header[3] == 0x70) {
					let title = "";
					for(let i = 32; i < 48; i++) {
						if(part_header[i] == 0) break;
						title += String.fromCharCode(part_header[i]);
					}
					fileelem.textContent = index_string+": VAGp sound \"" + title + "\"";
					let part_blob = infile.slice(this_sectors[i]*2048, (this_sectors[i]+this_sizes[i])*2048);
					fileelem.addEventListener("click", (e) => {
						for(let othersel of document.querySelectorAll(".file-item-selected")) {
							othersel.classList.remove("file-item-selected");
						}
						fileelem.classList.add("file-item-selected");
						set_vagp(part_blob);
					});
				} else if(part_header[0] == 0x20 && part_header[1] == 0x4B && part_header[2] == 0x50 && part_header[3] == 0x56) {
					fileelem.textContent = index_string+": KPV audio";
					let part_blob = infile.slice(this_sectors[i]*2048, (this_sectors[i]+this_sizes[i])*2048);
					fileelem.addEventListener("click", (e) => {
						for(let othersel of document.querySelectorAll(".file-item-selected")) {
							othersel.classList.remove("file-item-selected");
						}
						fileelem.classList.add("file-item-selected");
						set_kpv(part_blob);
					});
				} else {
					fileelem.textContent = index_string+": Unknown File";
				}
				file_list.push(null);
			}
		}
	}
}

async function set_sbv2(blob) {
	if(dispose_old) {
		dispose_old();
		dispose_old = null;
	}
	let file = new Uint8Array(await new Response(blob).arrayBuffer());
	do_log(file.length);
	let dv = new DataView(file.buffer);
	let contentelem = document.getElementById("content");
	contentelem.innerHTML = "";
	
	let sbv2 = new SBv2Decoder(file);
	do_log(sbv2);
	
	let sound_start = dv.getUint32(16, true);
	let sound_length = dv.getUint32(20, true);
	let mmid_start = dv.getUint32(24, true);
	
	let sbv2_start = 0x20;
	let instruments_start = dv.getUint32(sbv2_start + 0x20, true) + sbv2_start;
	let num_instruments = dv.getUint16(sbv2_start + 0x16, true);
	
	let instruments = [];
	
	let stop_playing = null;
	dispose_old = ()=>{if(stop_playing) stop_playing();};
	
	let num_midis = sbv2.tracks.length;
	for(let i = (num_midis <= 1 ? 0 : 1); i < num_midis; i++) { // Yes, I'm skipping track zero. Track zero doesn't have anything useful. At least not for this thing.
		let track = sbv2.tracks[i];
		
		let tempo = track.tempo;
		let ticks_per_qnote = track.ticks_per_qnote;
		let data_offset = track.data_offset;
		
		let mtext = `Track ${i}\n`;
		mtext += `  Tempo: ${tempo} BPM\n`;
		mtext += `  Ticks per quarter note: ${ticks_per_qnote}\n`;
		let midi_elem = document.createElement("pre");
		midi_elem.textContent = mtext;
		contentelem.appendChild(midi_elem);
		
		let channel_toggles = [];
		let channel_labels = [];
		let channel_toggles_table = document.createElement("table");
		let channel_toggles_channels = document.createElement("tr");
		let channel_toggles_checkboxes = document.createElement("tr");
		for(let i = 0; i < 16; i++) {
			let channelnum = document.createElement("td");
			channelnum.textContent = i.toString(16);
			channel_labels.push(channelnum);
			channel_toggles_channels.appendChild(channelnum);
			let channelboxcont = document.createElement("td");
			channelnum.style.textAlign = "center";
			let channelboxcheck = document.createElement("input");
			
			channelboxcheck.type = "checkbox";
			channelboxcheck.checked = true;
			channelboxcont.appendChild(channelboxcheck);
			channel_toggles_checkboxes.appendChild(channelboxcont);
			channel_toggles.push(channelboxcheck);
			channelboxcheck.addEventListener("dblclick", () => {
				let amt_on = 0;
				let amt_off = 0;
				for(let toggle of channel_toggles) {
					if(toggle.checked) amt_on++;
					else amt_off++;
				}
				for(let toggle of channel_toggles) {
					toggle.checked = amt_off > amt_on;
				}
				channelboxcheck.checked = true;
			});
		}
		channel_toggles_table.appendChild(channel_toggles_channels);
		channel_toggles_table.appendChild(channel_toggles_checkboxes);
		contentelem.appendChild(channel_toggles_table);
		
		let reverb_toggle = document.createElement("input");
		reverb_toggle.type = "checkbox";
		reverb_toggle.checked = true;
		contentelem.appendChild(reverb_toggle);
		contentelem.appendChild(document.createTextNode("Reverb"));
		contentelem.appendChild(document.createElement("br"));
		
		let loop_count = document.createElement("input");
		loop_count.type = "number";
		loop_count.min = 1;
		loop_count.value = 1;
		contentelem.appendChild(document.createTextNode("Loop count: "));
		contentelem.appendChild(loop_count);		
		contentelem.appendChild(document.createTextNode("\t"));
		
		let silence_seconds = document.createElement("input");
		silence_seconds.type = "number";
		silence_seconds.min = 0;
		silence_seconds.value = 0;
		contentelem.appendChild(document.createTextNode("Seconds of silence at end: "));
		contentelem.appendChild(silence_seconds);		
		contentelem.appendChild(document.createElement("br"));
		
		function calc_channel_mask() {
			let mask = 0;
			for(let i = 0; i < 16; i++) {
				if(channel_toggles[i].checked)
					mask |= (1 << i);
			}
			return mask;
		}
		
		let playback_display = document.createElement("pre");
		let play_button = document.createElement("input");
		play_button.type = "button";
		play_button.value = "Play";
		play_button.addEventListener("click", () => {
			if(stop_playing) { stop_playing(); stop_playing = null; }
			
			let player = new MidiPlayer(sbv2, track, audio_context);
			player.channel_mask = calc_channel_mask();
			player.reverb_enabled = reverb_toggle.checked;
			player.play();
			do_log(player);
			
			let do_vis = () => {
				if(player.curr_timeout == null) return;
				for(let i = 0; i < 16; i++) {
					let channel = player.channels[i];
					let is_playing = false;
					for(let note of channel) {
						if(note) {
							is_playing = true;
							break;
						}
					}
					let vis = channel_labels[i];
					vis.style.backgroundColor = is_playing ? "#ccaacc" : "transparent";
				}
				player.channel_mask = calc_channel_mask();
				player.reverb_enabled = reverb_toggle.checked;
				setTimeout(do_vis, 50);
			};
			do_vis();
			
			stop_playing = () => {
				player.stop();
				for(let vis of channel_labels) {
				vis.style.backgroundColor = "transparent";
				}
			};
		});
		contentelem.appendChild(play_button);
		
		let stop_button = document.createElement("input");
		stop_button.type = "button";
		stop_button.value = "Stop";
		stop_button.addEventListener("click", () => {
			if(stop_playing) { stop_playing(); stop_playing = null; }
		});
		contentelem.appendChild(stop_button);
		
		let savewav_button = document.createElement("input");
		savewav_button.type = "button";
		savewav_button.value = "Save .wav (may take a while)";
		savewav_button.addEventListener("click", async () => {
			/*for(let chan = 0; chan < 16; chan++) {
				let ctx = new OfflineAudioContext(2, (track.seconds + 5)*48000, 48000);
				
				let player = new MidiPlayer(sbv2, track, ctx);
				player.channel_mask = 1 << chan;
				player.play();
				
				let buf = await ctx.startRendering();
				saveAs(new Blob([to_wav(buf)], {type:'audio/wav'}), sbv2.tag + i + "_" + chan + ".wav");
			}*/
			let ctx = new OfflineAudioContext(2, (track.seconds+silence_seconds.value/loop_count.value)*48000*loop_count.value, 48000);
				
			let player = new MidiPlayer(sbv2, track, ctx, loop_count.value);
			player.channel_mask = calc_channel_mask();
			player.reverb_enabled = reverb_toggle.checked;
			player.play();

			add_rendering_context(ctx, "Rendering: " + sbv2.tag + i);
			
			let buf = await ctx.startRendering();
			saveAs(new Blob([to_wav(buf)], {type:'audio/wav'}), sbv2.tag + i + ".wav");
		});
		contentelem.appendChild(savewav_button);
		
		let savemid_button = document.createElement("input");
		savemid_button.type = "button";
		savemid_button.value = "Save as .mid";
		savemid_button.addEventListener("click", () => {
			let outfile = new Uint8Array(100000);
			let outdv = new DataView(outfile.buffer);
			let current_midi_pointer = data_offset;
			let o = 0;
			outfile[o++] = 'M'.charCodeAt(0);
			outfile[o++] = 'T'.charCodeAt(0);
			outfile[o++] = 'h'.charCodeAt(0);
			outfile[o++] = 'd'.charCodeAt(0);
			outdv.setUint32(o, 6); o += 4;
			outdv.setUint16(o, 0); o += 2;
			outdv.setUint16(o, 1); o += 2;
			outdv.setUint16(o, ticks_per_qnote); o += 2;
			
			outfile[o++] = 'M'.charCodeAt(0);
			outfile[o++] = 'T'.charCodeAt(0);
			outfile[o++] = 'r'.charCodeAt(0);
			outfile[o++] = 'k`'.charCodeAt(0);
			let length_placeholder = o; o += 4;
			let length_start = o;
			
			// Write the tempo event
			outfile[o++] = 0; // delta-time of 0
			outfile[o++] = 0xFF; // meta event
			outfile[o++] = 0x51; // set tempo
			outdv.setUint32(o, 60000000 / tempo);// its a 3 byte value so I just write this as 4 bytes and overwrite the first byte with what its actually supposed to be. this is why little endian is better than big endian.
			outfile[o] = 0x3;
			o += 4;
			
			let is_on_wait_byte = true;
			while(current_midi_pointer < file.length) {
				if(is_on_wait_byte) {
					is_on_wait_byte = false;
					let wait_byte = file[current_midi_pointer++];
					outfile[o++] = wait_byte;
					while(wait_byte & 0x80) {
						wait_byte = file[current_midi_pointer++];
						outfile[o++] = wait_byte;
					}
				} else {
					is_on_wait_byte = true;
					if(file[current_midi_pointer] & 0x80) {
						event_type = file[current_midi_pointer];
						if((event_type & 0xF0) == 0xD0) { // reee sony
							outfile[o++] = 0x80 | (event_type & 0xF);
						} else {
							outfile[o++] = event_type;
						}
						current_midi_pointer++;
					}
					if((event_type & 0xF0) == 0xC0) { // one-byte event
						outfile[o++] = file[current_midi_pointer++];
					} else if([0x80, 0x90, 0xA0, 0xB0, 0xE0].includes(event_type & 0xF0)) { // two-byte events
						outfile[o++] = file[current_midi_pointer++];
						outfile[o++] = file[current_midi_pointer++];
					} else if((event_type & 0xF0) == 0xD0) { // note off event
						outfile[o++] = file[current_midi_pointer++];
						outfile[o++] = 63;
					} else if(event_type == 0xFF) { // Meta event
						let meta_start = current_midi_pointer;
						let meta_type = file[current_midi_pointer++];
						let meta_length = 0;
						let length_byte = file[current_midi_pointer++];
						while(length_byte & 0x80) {
							meta_length += length_byte & 0x7F;
							meta_length <<= 7;
							length_byte = file[current_midi_pointer++];
						}
						meta_length += length_byte;
						
						let full_meta = file.subarray(meta_start, current_midi_pointer + meta_length);
						current_midi_pointer += meta_length;
						outfile.set(full_meta, o);
						o += full_meta.length;
						
						if(meta_type == 0x2F) {
							break;
						}
					} else if(event_type == 0xF0) {
						// I'd *not* include this but it'd be more difficult to splice it out so meh/
						let start_sysex = current_midi_pointer;
						while(file[current_midi_pointer++] != 0xF7 && current_midi_pointer < file.length);
						let sysex_length = current_midi_pointer - start_sysex;
						for(let i = 0; i < 4; i++) {
							if(sysex_length & 0xFE00000) {
								outfile[o++] = ((sysex_length >> 21) & 0x7F) | (i == 3 ? 0 : 0x80);
							}
							sysex_length <<= 0x7;
						}
						outfile.set(file.subarray(start_sysex, current_midi_pointer), o);
						o += current_midi_pointer - start_sysex;
					} else {
						throw new Error('Unrecognized MIDI event ' + event_type.toString(16));
					}
				}
			}
		
			outdv.setUint32(length_placeholder, o - length_start);
			
			outfile = outfile.subarray(0, o);
			
			saveAs(new Blob([outfile], {type:"audio/midi"}), [...file.slice(44,48)].map((cc)=>{return String.fromCharCode(cc);}).join("") + i + '.mid');
		});
		contentelem.appendChild(savemid_button);
		
		let vis_button = document.createElement("input");
		vis_button.type = "button";
		vis_button.value = "Save Visualisation (.ply)";
		vis_button.addEventListener("click", () => {
			let total_verts = 0;
			let total_faces = 0;
			let verts_str = "";
			let faces_str = "";
			const time_scale = 0.25;
			let min_note = sbv2.min_note;
			let max_note = sbv2.max_note;
			let channel_programs = new Array(16);
			
			for(let event of track.events) {
				if(event.type == "program_change") {
					channel_programs[event.channel] = event.program;
				}
				if(event.type != "note_on" || !event.note_off)
					continue;
				let event_length = event.note_off.seconds - event.seconds;
				let region = null;
				for(let r of instruments[channel_programs[event.channel] || 0].regions) {
					if(event.note >= r.note_start && event.note <= r.note_end) {
						region = r;
						break;
					}
				}
				if(!region) continue;
				let curve = [[0,0]];
				
				let attack_rate = (region.adsr1 >> 8) & 0x7F;
				let attack_mode = region.adsr1 >> 15;
				let curr_adsr_time = 0;
				if(attack_mode) {
					if(adsr_rates[(attack_rate ^ 0x7F) - 0x18 + 32] > 0) {
						let time_a = (0x60000000 / adsr_rates[(attack_rate ^ 0x7F) - 0x18 + 32]) / 48000;
						curve.push([time_a, 0.75]);
						curr_adsr_time = time_a + (0x1FFFFFFF / adsr_rates[(attack_rate ^ 0x7F) - 0x10 + 32]) / 48000;
						curve.push([curr_adsr_time, 1]);
					}
				} else {
					if(adsr_rates[(attack_rate ^ 0x7F) - 0x10 + 32] > 0) {
						curr_adsr_time = (0x7FFFFFFF / adsr_rates[(attack_rate ^ 0x7F) - 0x10 + 32]) / 48000;
						curve.push([curr_adsr_time, 1]);
					}
				}
				let curr_adsr_percent = 1;
				
				let decay_rate = (region.adsr1 >> 4) & 0xF;
				let sustain_level = region.adsr1 & 0xF;
				let sustain_fraction = ((1/16)*(sustain_level + 1));
				let decay_time_constant = 0x7FFFFFFF / adsr_rates[((decay_rate^0x1f)*4)-0xC+32] / 48000;
				let decay_time = decay_time_constant * Math.log(1 / sustain_fraction)
				for(let i = 0; i <= decay_time / decay_time_constant; i += 0.1) {
					curve.push([curr_adsr_time+i*decay_time_constant, curr_adsr_percent * Math.E ** -i]);
				}
				curr_adsr_time += decay_time;
				curr_adsr_percent *= sustain_fraction;
				curve.push([curr_adsr_time, curr_adsr_percent]);
				
				let sustain_mode = region.adsr2 >> 14;
				let sustain_rate = (region.adsr2 >> 6) & 0x7F;
				if(sustain_mode & 0x2) { // decreasing
					if(sustain_mode & 0x4) { // exponential
						let sustain_time_constant = 0x7FFFFFFF / adsr_rates[(sustain_rate^0x7F)-0xF + 32] / 48000;
						let sustain_time = event_length - curr_adsr_time;
						for(let i = 0; i <= sustain_time / sustain_time_constant + 0.1; i += 0.1) {
							curve.push([curr_adsr_time+i*sustain_time_constant, curr_adsr_percent * Math.E ** -i]);
						}
					} else {
						if(adsr_rates[(sustain_rate ^ 0x7F)-0xF + 32] > 0) {
							curr_adsr_time += (0x7FFFFFFF * curr_adsr_percent / adsr_rates[(sustain_rate ^ 0x7F)-0xF + 32]) / 48000;
							curve.push([curr_adsr_time, 0]);
						}
					}
				} else if(curr_adsr_percent < 1) {
					console.warn("Increasing sustain unimplemented");
				}
				
				let release_point = [event_length, 1];
				for(let i = 0; i < curve.length; i++) {
					let point = curve[i];
					let prev_point = curve[i-1];
					if(point[0] <= release_point[0]) {
						release_point[1] = point[1];
					}
					if(prev_point && prev_point[0] < release_point[0] && point[0] > release_point[0]) {
						release_point[1] = ((point[1]-prev_point[1])/(point[0]-prev_point[0])) * (release_point[0] - prev_point[0]) + prev_point[1];
					}
					if(point[0] >= release_point[0]) {
						curve.length = i;
						break;
					}
				}
				if(release_point[1] > 0 || curve[curve.length-1][1] > 0) {
					curve.push(release_point);
					curr_adsr_percent = release_point[1];
					curr_adsr_time = release_point[0]
					let release_rate = region.adsr2 & 0x1F;
					let release_mode = (region.adsr2 >> 5) & 0x1;
					if(release_mode) {
						let time_constant = 0x7FFFFFFF / adsr_rates[((release_rate^0x1f)*4)-0xC+32] / 48000;
						for(let i = 0; i < 4; i += 0.1) {
							curve.push([curr_adsr_time+i*time_constant, curr_adsr_percent * Math.E ** -i]);
						}
					} else {
						let time_to_silence = curr_adsr_percent * 0x7FFFFFFF / (1 << (0x1f - release_rate)) / 48000;
						curve.push([curr_adsr_time+time_to_silence, 0]);
					}
				}
				
				// output the curve
				if(curve.length >= 1) {
					let color = get_map_color_float(event.channel);
					for(let i = 0; i < curve.length; i++) {
						let x = (event.seconds + curve[i][0]) * time_scale;
						let y_scale = 1 / (max_note-min_note);
						let base_y = (event.note - min_note + 0.5) * y_scale;
						let y_add = curve[i][1] * event.velocity * y_scale * 0.5;
						verts_str += `${x} ${base_y+y_add} ${-event_length/10} ${color[0]} ${color[1]} ${color[2]}\n`;
						verts_str += `${x} ${base_y-y_add} ${-event_length/10} ${color[0]} ${color[1]} ${color[2]}\n`;
						total_verts += 2;
						if(i >= 1) {
							faces_str += `4 ${total_verts-1} ${total_verts-2} ${total_verts-4} ${total_verts-3}\n`;
							total_faces += 1;
						}
					}
				}
			}
			
			saveAs(new Blob([`ply
format ascii 1.0
element vertex ${total_verts}
property float x
property float y
property float z
property float red
property float green
property float blue
element face ${total_faces}
property list uchar int vertex_index
end_header
${verts_str}${faces_str}`], {type:'text/plain'}), sbv2.tag + i + '.ply');
		});
		contentelem.appendChild(vis_button);
		contentelem.appendChild(playback_display);
		
	}

	let webmidi_play_button = document.createElement("input");
	webmidi_play_button.type = "button";
	webmidi_play_button.value = "Start WebMIDI";
	webmidi_play_button.addEventListener("click", async () => {
		setupWebMidi();
		set_web_midi_enabled(true);
		if(stop_playing) { stop_playing(); stop_playing = null; }
		let playing = true;
		
		let player = new MidiPlayer(sbv2, null, audio_context);
		player.reverb_enabled = true;
		do_log(player);

		midi_handler = (e) => {
			player.current_time = audio_context.currentTime;
			let data = e.data;
			if((data[0] & 0xF0) == 0x90) {
				player.handle_event({
					type: "note_on",
					channel: data[0] & 0x0F,
					note: data[1],
					velocity: data[2] / 127
				});
			} else if((data[0] & 0xF0) == 0x80) {
				player.handle_event({
					type: "note_off",
					channel: data[0] & 0x0F,
					note: data[1],
				});
			} else if((data[0] & 0xF0) == 0xB0) {
				player.handle_event({
					type: "control_change",
					channel: data[0] & 0x0F,
					control_function: data[1],
					parameter: data[2]
				});
			} else if((data[0] & 0xF0) == 0xE0) {
				player.handle_event({
					type: "pitch_bend",
					channel: data[0] & 0x0F,
					bend: (data[2] * 128 + data[1]) / 8192 - 1
				})
			} else if((data[0] & 0xF0) == 0xC0) {
				player.handle_event({
					type: "program_change",
					channel: data[0] & 0xF,
					program: data[1]
				});
				if(""+data[1] != webmidi_program_selector.value) {
					webmidi_program_selector.value = ""+data[1];
				}
			}
		}

		player.handle_event({
			type: "program_change",
			channel: 0,
			program: 0
		});
		webmidi_program_selector.value = "0";
		
		stop_playing = () => {
			playing = false;
			midi_handler = null;
			player.stop();
			set_web_midi_enabled(false);
		};
	});
	contentelem.appendChild(webmidi_play_button);
	
	let webmidi_stop_button = document.createElement("input");
	webmidi_stop_button.type = "button";
	webmidi_stop_button.value = "Stop";
	webmidi_stop_button.addEventListener("click", () => {
		if(stop_playing) { stop_playing(); stop_playing = null; }
	});
	contentelem.appendChild(webmidi_stop_button);
	let webmidi_program_selector = document.createElement("input");
	webmidi_program_selector.type = "number";
	webmidi_program_selector.min = "0";
	webmidi_program_selector.max = "127";
	webmidi_program_selector.addEventListener("input", () => {
		do_log(webmidi_program_selector.value);
		if(midi_handler) midi_handler({data: [0xC0, +webmidi_program_selector.value & 0xFF]})
	})
	contentelem.appendChild(webmidi_program_selector);

	contentelem.appendChild(midi_select);
	
	let pre = document.createElement("pre");
	pre.textContent = `Sound start: ${sound_start}
Sound length: ${sound_length}
`;
	contentelem.appendChild(pre);
	
	for(let i = 0; i < num_instruments; i++) {
		let instrument_volume = file[instruments_start + (i*0x8) + 0x1];
		let instrument_pan = dv.getInt16(instruments_start + (i*0x8) + 0x2, true);
		let num_regions = file[instruments_start + (i*0x8)];
		let region_offset = dv.getUint32(instruments_start + (i*0x8) + 0x4, true) + sbv2_start;
		
		let instrument_elem = document.createElement("pre");
		instrument_elem.textContent = `=== Program 0x${i.toString(16)} ===\nVolume: ${instrument_volume}\nPan: ${instrument_pan}`;
		contentelem.appendChild(instrument_elem);
		
		let instrument_obj = {
			volume: instrument_volume / 127,
			regions: []
		};
		instruments.push(instrument_obj);
		
		for(let j = 0; j < num_regions; j++) {
			let region_volume = file[region_offset + j*0x18 + 0x1];
			let region_pitch_a = dv.getInt8(region_offset + j*0x18 + 0x2, false);
			let region_pitch_b = dv.getInt8(region_offset + j*0x18 + 0x3, false);
			let region_note_start = file[region_offset + j*0x18 + 0x6];
			let region_note_end = file[region_offset + j*0x18 + 0x7];
			let region_sample_offset = dv.getUint32(region_offset + j*0x18 + 0x10, true);
			let region_adsr1 = dv.getUint16(region_offset + j*0x18 + 0xA, true);
			let region_adsr2 = dv.getUint16(region_offset + j*0x18 + 0xC, true);
			let region_flags = dv.getUint16(region_offset + j*0x18 + 0xE, true);
			
			let region_obj = {
				volume: region_volume / 127,
				note_start: region_note_start,
				note_end: region_note_end,
				pitch_a: region_pitch_a,
				pitch_b: region_pitch_b,
				adsr1: region_adsr1,
				adsr2: region_adsr2,
				flags: region_flags,
				sound: decode_adpcm(file, sound_start+region_sample_offset, sound_start+sound_length, 48000)
			};
			instrument_obj.regions.push(region_obj)
			
			let region_elem = document.createElement("pre");
			let region_text = `  ==Notes ${region_note_start}-${region_note_end}==\n`;
			region_text += `  Volume: ${region_volume}\n`;
			region_text += `  Pitch bytes: ${region_pitch_a} ${region_pitch_b}\n`;
			region_text += `  Sample data offset: 0x${region_sample_offset.toString(16)}\n`;
			region_text += `  ADSR1: 0x${region_adsr1.toString(16).padStart(4,0)}\n`;
			region_text += `  ADSR2: 0x${region_adsr2.toString(16).padStart(4,0)}\n`;
			region_text += `  Flags: 0x${region_flags.toString(16).padStart(4,0)}\n`;
			region_text += `  Bytes: [${[...file.subarray(region_offset+j*0x18,region_offset+(j+1)*0x18)].map(number => {return number.toString(16).padStart(2,'0')}).join(" ")}]\n`;
			region_elem.textContent = region_text;
			contentelem.appendChild(region_elem);
			
			let button = document.createElement("input");
			button.type = "button";
			button.value = "Play";
			let source = null;
			button.addEventListener("mousedown", () => {
				let sound = region_obj.sound;
				let source = audio_context.createBufferSource();
				source.buffer = sound.buffer;
				source.connect(audio_context.destination);
				source.loop = sound.loop;
				source.loopStart = sound.loop_start;
				source.loopEnd = sound.loop_end;
				source.playbackRate.value = handle_midi_pitch(region_pitch_a, region_pitch_b, Math.floor((region_note_start + region_note_end) / 2)) / 4096;
				source.start();
				let mouseup = () => {
					document.removeEventListener("mouseup", mouseup);
					source.stop();
				};
				document.addEventListener("mouseup", mouseup);
			});
			button.style.marginLeft = "40px";
			contentelem.appendChild(button);
		}
	}
}

let web_midi_enabled = true;

let set_web_midi_enabled = (n) => {web_midi_enabled = n;};

async function setupWebMidi() {
	if(midi_access) return;
	
	let access = await navigator.requestMIDIAccess();
	if(midi_access) return;
	midi_access = access;

	let select_names = [];
	function update_midi_inputs() {
		let old_select_name = null;
		if(midi_select.length > 0) old_select_name = select_names[midi_select.selectedIndex];
		select_names = [];
		midi_select.innerHTML = "";
		for(let [key, value] of midi_access.inputs) {
			select_names.push(key);
			let option = document.createElement("option");
			option.text = value.manufacturer + " " + value.name + " version " + value.version + ", " + value.state + ", " + value.connection;
			midi_select.add(option);
			if(key == old_select_name) midi_select.selectedIndex = midi_select.length - 1;
		}
		update_midi_select();
	}
	function midi_message_handler(e) {
		console.log(e);
		if(midi_handler) midi_handler(e);
	}
	let current_input = null;
	function update_midi_select() {
		let select_name = select_names[midi_select.selectedIndex];
		let input = web_midi_enabled ? midi_access.inputs.get(select_name) : null;
		if(input == current_input) return;
		do_log("Changing midi input");
		if(current_input) {
			current_input.removeEventListener("midimessage", midi_message_handler);
			current_input.close();
		}
		if(input) {
			input.addEventListener("midimessage", midi_message_handler);
			input.open();
		}
		current_input = input;
	}
	update_midi_inputs();
	midi_access.addEventListener("statechange", update_midi_inputs);
	midi_select.addEventListener("change", update_midi_select);

	let set_web_midi_enabled = (n) => {web_midi_enabled = n; update_midi_select();};
}

class MidiPlayer {
	constructor(sbv2, track, ctx, loop = 1) {
		this.sbv2 = sbv2;
		this.track = track;
		this.ctx = ctx;
		if(ctx instanceof OfflineAudioContext) {
			this.convolver_node = this.ctx.createConvolver();
			this.convolver_node.connect(ctx.destination);
			this.convolver_node.buffer = convolver_buffer;
			this.loops_left = loop;
		} else {
			this.convolver_node = convolver_node;
			this.loops_left = Infinity;
		}
		this.curr_timeout = null;
		this.channels = [];
		for(let i = 0; i < 16; i++) {
			this.channels[i] = [];
		}
		this.channel_programs = new Array(16);
		this.channel_programs.fill(undefined);
		this.channel_gains = new Array(16);
		this.channel_gains_reverb = new Array(16);
		this.channel_pans = new Array(16);
		this.channel_pans_reverb = new Array(16);
		this.channel_pan_controls = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
		this.channel_pitch_shift = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
		for(let i = 0; i < 16; i++) {
			let pan = this.channel_pans[i] = this.ctx.createStereoPanner();
			pan.connect(this.ctx.destination);
			let pan_reverb = this.channel_pans_reverb[i] = this.ctx.createStereoPanner();
			pan_reverb.connect(this.convolver_node);

			let gain = this.channel_gains[i] = this.ctx.createGain();
			gain.connect(pan);
			let gain_reverb = this.channel_gains_reverb[i] = this.ctx.createGain();
			gain_reverb.connect(pan_reverb);
		}
		this.current_time = this.ctx.currentTime;
		this.event_index = 0;
		this.channel_mask = 0xFFFF;
		this.reverb_enabled = true;
	}
	
	stop() {
		if(this.curr_timeout != null) clearTimeout(this.curr_timeout);
		this.curr_timeout = null;
		for(let i = 0; i < this.channels.length; i++) {
			for(let j = 0; j < this.channels[i].length; j++) {
				if(this.channels[i][j] instanceof Object) {
					this.channels[i][j].source_node.stop();
					this.channels[i][j] = null;
				}
			}
		}
	};
	
	play() {
		if(!this.curr_timeout) {
			this.process_midi();
		}
	}
	
	stop_note(channel, note_num) {
		let playing_note = this.channels[channel][note_num];
		if(playing_note) {
			this.channels[channel][note_num] = null;
			if(typeof playing_note == "object") {
				let curr_percent = 1;//playing_note.gain_node.gain.value / playing_note.base_gain;
				let time_to_silence = 0;
				let release_rate = playing_note.region.adsr2 & 0x1F;
				let release_mode = (playing_note.region.adsr2 >> 5) & 0x1;
				playing_note.release_gain_node.gain.setValueAtTime(1, this.current_time);
				if(release_mode) {
					let time_constant = 0x7FFFFFFF / adsr_rates[((release_rate^0x1f)*4)-0xC+32] / 48000;
					playing_note.release_gain_node.gain.setTargetAtTime(0, this.current_time, time_constant);
					time_to_silence = time_constant * 4;
				} else {
					time_to_silence = curr_percent * 0x7FFFFFFF / (1 << (0x1f - release_rate)) / 48000;
					playing_note.release_gain_node.gain.linearRampToValueAtTime(0, this.current_time + time_to_silence);
				}
				playing_note.source_node.stop(this.current_time + time_to_silence);
			}
		}
	};

	update_pan(channel) {
		let program = this.channel_programs[channel];
		let instrument = this.sbv2.instruments[program];
		let pan = (instrument ? instrument.pan : 0) * Math.PI / 180;
		pan += Math.asin(this.channel_pan_controls[channel]);
		this.channel_pans[channel].pan.setValueAtTime(Math.sin(pan), this.current_time);
		this.channel_pans_reverb[channel].pan.setValueAtTime(Math.sin(pan), this.current_time);
	}

	update_pitch(channel) {
		let channel_arr = this.channels[channel];
		if(!channel_arr) return;
		for(let i = 0; i < channel_arr.length; i++) {
			let note = channel_arr[i];
			if(note) {
				note.source_node.playbackRate.setValueAtTime(note.base_pitch * (1.122462 ** this.channel_pitch_shift[channel]), this.current_time);
			}
		}
	}

	handle_event(event) {
		if(event.type == "program_change") {
			this.channel_programs[event.channel] = event.program;
			this.update_pan(event.channel);
		} else if(event.type == "note_on") { // note on event
			let note_num = event.note;
			let velocity = event.velocity;
			this.stop_note(event.channel, note_num);
			let playing_note = {gain_node: this.ctx.createGain(), release_gain_node: this.ctx.createGain(), source_node: this.ctx.createBufferSource()};
			let program = this.channel_programs[event.channel] || 0;
			let region = null;
			for(let r of this.sbv2.instruments[program].regions) {
				if(note_num >= r.note_start && note_num <= r.note_end) {
					region = r; // technically regions can overlap and both will play but meh I really don't feel like doing that and I'm pretty sure it wasn't used since it would sound like shit.
					break;
				}
			}
			if(region && ((1 << event.channel) & this.channel_mask)) {
				playing_note.velocity = velocity;
				playing_note.base_gain = (this.sbv2.instruments[program].volume * region.volume * velocity) ** 2 * (665 / 2048)
				playing_note.gain_node.gain.setValueAtTime(0, this.current_time);
				if(!(region.flags & 0x10))
					playing_note.gain_node.connect(this.channel_gains[event.channel]);
				if((region.flags & 0x01) && this.reverb_enabled)
					playing_note.gain_node.connect(this.channel_gains_reverb[event.channel]);
				playing_note.release_gain_node.connect(playing_note.gain_node);
				playing_note.source_node.buffer = region.sound.buffer;
				playing_note.source_node.connect(playing_note.release_gain_node);
				playing_note.source_node.loop = region.sound.loop;
				playing_note.source_node.loopStart = region.sound.loop_start;
				playing_note.source_node.loopEnd = region.sound.loop_end;
				playing_note.base_pitch = handle_midi_pitch(region.pitch_a, region.pitch_b, note_num) / 4096;
				playing_note.source_node.playbackRate.value = playing_note.base_pitch * (1.122462 ** this.channel_pitch_shift[event.channel]);
				playing_note.pitch_a = region.pitch_a;
				playing_note.pitch_b = region.pitch_b;
				playing_note.source_node.start(this.current_time);
				playing_note.region = region;
				playing_note.instrument = this.sbv2.instruments[program];
				// do ADSR. Or at least some of it.
				let attack_rate = (region.adsr1 >> 8) & 0x7F;
				let attack_mode = region.adsr1 >> 15;
				let curr_adsr_time = 0;
				if(attack_mode) {
					if(adsr_rates[(attack_rate ^ 0x7F) - 0x18 + 32] > 0) {
						let time_a = this.current_time + (0x60000000 / adsr_rates[(attack_rate ^ 0x7F) - 0x18 + 32]) / 48000;
						playing_note.gain_node.gain.linearRampToValueAtTime(playing_note.base_gain * 0.75, time_a);
						curr_adsr_time = time_a + (0x1FFFFFFF / adsr_rates[(attack_rate ^ 0x7F) - 0x10 + 32]) / 48000;
						playing_note.gain_node.gain.linearRampToValueAtTime(playing_note.base_gain, curr_adsr_time);
					}
				} else {
					if(adsr_rates[(attack_rate ^ 0x7F) - 0x10 + 32] > 0) {
						curr_adsr_time = this.current_time + (0x7FFFFFFF / adsr_rates[(attack_rate ^ 0x7F) - 0x10 + 32]) / 48000;
						playing_note.gain_node.gain.linearRampToValueAtTime(playing_note.base_gain, curr_adsr_time);
					}
				}
				let curr_adsr_percent = 1;
				
				let decay_rate = (region.adsr1 >> 4) & 0xF;
				let sustain_level = region.adsr1 & 0xF;
				let sustain_fraction = ((1/16)*(sustain_level + 1));
				let decay_time_constant = 0x7FFFFFFF / adsr_rates[((decay_rate^0x1f)*4)-0xC+32] / 48000;
				curr_adsr_time += decay_time_constant * Math.log(1 / sustain_fraction);
				curr_adsr_percent *= sustain_fraction;
				playing_note.gain_node.gain.exponentialRampToValueAtTime((curr_adsr_percent * playing_note.base_gain == 0 ? 0.01 : curr_adsr_percent * playing_note.base_gain), curr_adsr_time);
				
				let sustain_mode = region.adsr2 >> 14;
				let sustain_rate = (region.adsr2 >> 6) & 0x7F;
				if(sustain_mode & 0x2) { // decreasing
					if(sustain_mode & 0x4) { // exponential
						let sustain_time_constant = 0x7FFFFFFF / adsr_rates[(sustain_rate^0x7F)-0xF + 32] / 48000;
						playing_note.gain_node.gain.setTargetAtTime(0, curr_adsr_time, sustain_time_constant);
					} else {
						if(adsr_rates[(sustain_rate ^ 0x7F)-0xF + 32] > 0) {
							curr_adsr_time += (0x7FFFFFFF * curr_adsr_percent / adsr_rates[(sustain_rate ^ 0x7F)-0xF + 32]) / 48000;
							playing_note.gain_node.gain.linearRampToValueAtTime(0, curr_adsr_time);
						}
					}
				} else if(curr_adsr_percent < 1) {
					// okay I could emulate increasing sustain level..... buuuuuuuut
					// the only time this game uses increasing sustain is when the sustain level is 1... which means it doesn't actually increase.
					// so yeah
					console.warn("Increasing sustain unimplemented");
				}
				
				this.channels[event.channel][note_num] = playing_note;
			} else if(!region) {
				console.warn("No region! (Channel " + (event.channel) + ", program " + program + ", note " + note_num + ")");
			} else {
				this.channels[event.channel][note_num] = true;
			}
			
		} else if(event.type == "note_off") { // note off event (this does not follow the midi standard... **GOD DAMN IT SONY WHY CANT YOU FOLLOW STANDARDS** (this music format is a sony thing not an idol minds thing))
			this.stop_note(event.channel, event.note);
		} else if(event.type == "control_change") { // Control mode change
			let control_function = event.control_function;
			let parameter = event.parameter;
			if(control_function == 0x7) {
				this.channel_gains[event.channel].gain.setValueAtTime((parameter / 127) ** 2, this.current_time);
				this.channel_gains_reverb[event.channel].gain.setValueAtTime((parameter / 127) ** 2, this.current_time);
			} else if(control_function == 0xa) {
				this.channel_pan_controls[event.channel] = (parameter / 64) - 1;
				this.update_pan(event.channel);
			} else if(control_function == 0x78) {
				for(let j = 0; j < this.channels[event.channel].length; j++) {
					if(this.channels[event.channel][j] instanceof Object) {
						this.channels[event.channel][j].source_node.stop();
						this.channels[event.channel][j] = null;
					}
				}
			} else if(control_function == 0x7B) {
				for(let i = 0; i < 128; i++) this.stop_note(event.channel, i);
			} else {
				console.warn(`Unrecognized control mode change: 0x${control_function.toString(16)}(${parameter})`);
			}
		} else if(event.type == "pitch_bend") { // Pitch bend
			//do_log(`Pitch shift channel ${event.channel} bend ${event.bend}`);
			this.channel_pitch_shift[event.channel] = event.bend;
			this.update_pitch(event.channel);
		} else if(event.type == "end") { // Meta event
			this.loops_left--;
			this.event_index = 0;
			return true;
		}
	}
	
	process_midi() {
		while(true) {
			let comparison = this.track.events[this.event_index].seconds;
			let force_skip = false;
			while(this.event_index < this.track.events.length && this.track.events[this.event_index].seconds <= comparison && !force_skip) {
				let event = this.track.events[this.event_index];
				this.event_index++;
				let ended = this.handle_event(event);
				if(ended) {
					force_skip = true;
					comparison -= event.seconds;
				}
			}
			this.current_time += this.track.events[this.event_index].seconds - comparison;
			if(this.ctx instanceof OfflineAudioContext) {
				if(this.ctx.length <= (this.current_time * this.ctx.sampleRate) || this.loops_left <= 0) {
					for(let i = 0; i < this.channels.length; i++) {
						for(let j = 0; j < this.channels[i].length; j++) {
							if(this.channels[i][j]) {
								this.stop_note(i, j);
							}
						}
					}
					return;
				}
			} else {
				if(this.loops_left) {
					let wait = (this.current_time - this.ctx.currentTime) * 1000;
					if(wait < -250) {
						this.curr_timeout = null;
						this.process_midi();
					} else {
						this.curr_timeout = setTimeout(this.process_midi.bind(this), wait);
					}
				}
				return;
			}
		}
	}
}

class SBv2Decoder {
	constructor(file) {
		let dv = new DataView(file.buffer);
	
		let sound_start = dv.getUint32(16, true);
		let sound_length = dv.getUint32(20, true);
		let mmid_start = dv.getUint32(24, true);
		
		let sbv2_start = 0x20;
		let instruments_start = dv.getUint32(sbv2_start + 0x20, true) + sbv2_start;
		let num_instruments = dv.getUint16(sbv2_start + 0x16, true);
		
		this.instruments = [];
		this.min_note = 127;
		this.max_note = 0;
		
		this.tag = [...file.slice(44,48)].map((cc)=>{return String.fromCharCode(cc);}).join("");
		
		for(let i = 0; i < num_instruments; i++) {
			let instrument_volume = file[instruments_start + (i*0x8) + 0x1];
			let instrument_pan = dv.getInt16(instruments_start + (i*0x8) + 0x2, true);
			let num_regions = file[instruments_start + (i*0x8)];
			let region_offset = dv.getUint32(instruments_start + (i*0x8) + 0x4, true) + sbv2_start;
			
			let instrument_obj = {
				volume: instrument_volume / 127,
				pan: instrument_pan,
				regions: []
			};
			this.instruments.push(instrument_obj);
			
			for(let j = 0; j < num_regions; j++) {
				let region_volume = file[region_offset + j*0x18 + 0x1];
				let region_pitch_a = dv.getInt8(region_offset + j*0x18 + 0x2, false);
				let region_pitch_b = dv.getInt8(region_offset + j*0x18 + 0x3, false);
				let region_note_start = file[region_offset + j*0x18 + 0x6];
				let region_note_end = file[region_offset + j*0x18 + 0x7];
				let region_sample_offset = dv.getUint32(region_offset + j*0x18 + 0x10, true);
				let region_adsr1 = dv.getUint16(region_offset + j*0x18 + 0xA, true);
				let region_adsr2 = dv.getUint16(region_offset + j*0x18 + 0xC, true);
				let region_flags = dv.getUint16(region_offset + j*0x18 + 0xE, true);
				
				let region_obj = {
					volume: region_volume / 127,
					note_start: region_note_start,
					note_end: region_note_end,
					pitch_a: region_pitch_a,
					pitch_b: region_pitch_b,
					adsr1: region_adsr1,
					adsr2: region_adsr2,
					flags: region_flags,
					sound: decode_adpcm(file, sound_start+region_sample_offset, sound_start+sound_length, 48000),
					bytes: file.subarray(region_offset + j*0x18, region_offset + j*0x18+0x18)
				};
				instrument_obj.regions.push(region_obj)
			}
		}
		
		let is_single_track = (file[mmid_start + 0x11] == 0x49);
		
		this.tracks = [];
		let num_midis = is_single_track ? 1 : file[mmid_start+0x17];
		let version = is_single_track ? 1 : file[mmid_start + 0x14];
		for(let i = 0; i < num_midis; i++) {
			let midi_struct_offset = is_single_track ? (mmid_start + 0x10) : (dv.getUint32(mmid_start+0x20+i*4, true) + 0x10 + mmid_start);
			let midi_substruct_offset = midi_struct_offset + (version == 0x1 ? 0x1C : 0x28);
			
			let tempo = 100 / dv.getUint32(is_single_track ? midi_struct_offset+0x20 : midi_substruct_offset+0x48, true) * 600000;
			let ticks_per_qnote = dv.getUint32(is_single_track ? (midi_struct_offset+0x24) : (midi_substruct_offset+0x54), true);
			let data_offset = dv.getUint32(is_single_track ? midi_struct_offset+0x18 : midi_substruct_offset+0x38, true) + midi_struct_offset;
			let track = {
				tempo,
				ticks_per_qnote,
				events: [],
				data_offset
			};
			this.tracks.push(track);
			
			let ticks = 0;
			let seconds = 0;
			let current_midi_pointer = data_offset;
			let event_type;
			let is_on_wait_byte = true;
			
			while(current_midi_pointer < file.length) {
				if(is_on_wait_byte) {
					is_on_wait_byte = false;
					let wait = 0;
					let wait_byte = file[current_midi_pointer++];
					while(wait_byte & 0x80) {
						wait += wait_byte & 0x7F;
						wait <<= 7;
						wait_byte = file[current_midi_pointer++];
					}
					wait += wait_byte;
					seconds += (wait / ticks_per_qnote) * 60 / tempo;
					ticks += wait;
				} else {
					is_on_wait_byte = true;
					if(file[current_midi_pointer] & 0x80) {
						event_type = file[current_midi_pointer++];
					}
					if((event_type & 0xF0) == 0xC0) { // program change event
						track.events.push({
							type:"program_change",
							channel: event_type & 0xF,
							program: file[current_midi_pointer++],
							seconds,
							ticks
						});
					} else if((event_type & 0xF0) == 0x90) { // note on event
						let note = file[current_midi_pointer++];
						let velocity = file[current_midi_pointer++]/127;
						if(velocity == 0) {
							let off_event;
							track.events.push(off_event = {
								type:"note_off",
								channel: event_type & 0xF,
								note,
								velocity: 0.5,
								seconds,
								ticks
							});
							for(let i = track.events.length-1; i >= 0; i--) {
								let other_event = track.events[i];
								if(other_event.type == "note_on" && other_event.channel == off_event.channel && other_event.note == off_event.note && !other_event.note_off) {
									other_event.note_off = off_event;
									break;
								}
							}
						} else {
							if(note < this.min_note) this.min_note = note;
							if(note > this.max_note) this.max_note = note;
							track.events.push({
								type:"note_on",
								channel: event_type & 0xF,
								note,
								velocity,
								seconds,
								ticks,
								note_off: null
							});
						}
					} else if((event_type & 0xF0) == 0xD0) { // note off event (this does not follow the midi standard... **GOD DAMN IT SONY WHY CANT YOU FOLLOW STANDARDS** (this music format is a sony thing not an idol minds thing))
						let off_event;
						track.events.push(off_event = {
							type:"note_off",
							channel: event_type & 0xF,
							note: file[current_midi_pointer++],
							velocity: 0.5,
							seconds,
							ticks
						});
						for(let i = track.events.length-1; i >= 0; i--) {
							let other_event = track.events[i];
							if(other_event.type == "note_on" && other_event.channel == off_event.channel && other_event.note == off_event.note && !other_event.note_off) {
								other_event.note_off = off_event;
								break;
							}
						}
					} else if((event_type & 0xF0) == 0xB0) { // Control mode change
						track.events.push({
							type:"control_change",
							channel: event_type & 0xF,
							control_function: file[current_midi_pointer++],
							parameter: file[current_midi_pointer++],
							seconds,
							ticks
						});
					} else if((event_type & 0xF0) == 0xE0) { // Pitch bend
						let pitch_lsb = file[current_midi_pointer++];
						let pitch_msb = file[current_midi_pointer++];
						track.events.push({
							type:"pitch_bend",
							channel: event_type & 0xF,
							bend: (pitch_msb * 128 + pitch_lsb) / 8192 - 1,
							seconds,
							ticks
						});
					} else if(event_type == 0xFF) { // Meta event
						let meta_type = file[current_midi_pointer++];
						let meta_length = 0;
						let length_byte = file[current_midi_pointer++];
						while(length_byte & 0x80) {
							meta_length += length_byte & 0x7F;
							meta_length <<= 7;
							length_byte = file[current_midi_pointer++];
						}
						meta_length += length_byte;
						
						let meta_data = file.slice(current_midi_pointer, current_midi_pointer + meta_length);
						
						if(meta_type == 0x2F) {
							track.events.push({
								type:"end",
								seconds,
								ticks
							});
							break;
						} else {
							console.warn(`Unrecognized meta 0x${meta_type.toString(16)}`);
						}
					} else if(event_type == 0xF0) {
						// Sysex event. What's it do? I have no idea! now let's skip it.
						// maybe one day I'll look at the diassembly a bit closer and see
						while(file[current_midi_pointer++] != 0xF7 && current_midi_pointer < file.length);
					} else if(event_type == 0xF3) {
						do_log("Song select: " + file[current_midi_pointer++]);
					} else {
						console.warn(new Error('Unrecognized MIDI event ' + (event_type ? event_type.toString(16) : event_type) + ' at 0x' + current_midi_pointer.toString(16) + ' (' + current_midi_pointer + ')'));
						break;
					}
				}
			}
			track.ticks = ticks;
			track.seconds = seconds;
		}
	}
}

async function set_vagp(blob) {
	if(dispose_old) {
		dispose_old();
		dispose_old = null;
	}
	let file = new Uint8Array(await new Response(blob).arrayBuffer());
	let dv = new DataView(file.buffer);
	let contentelem = document.getElementById("content");
	contentelem.innerHTML = "";
	
	// unlike literally everything else this format uses big endian instead of little endian.
	let sound_start = 0x30;
	let sound_length = dv.getUint32(0x0C, false);
	let sample_rate = dv.getUint32(0x10, false);
	
	let pre = document.createElement("pre");
	pre.textContent = `Sound length: ${sound_length} bytes, ${(sound_length * 24 / 16 / sample_rate).toFixed(3)} seconds
Sample rate: ${sample_rate} Hz`;
	contentelem.appendChild(pre);
	
	let sound = decode_adpcm(file, sound_start, sound_start+sound_length, sample_rate);
	let source = audio_context.createBufferSource();
	source.buffer = sound.buffer;
	source.connect(audio_context.destination);
	source.start();
}

async function set_kpv(blob) {
	if(dispose_old) {
		dispose_old();
		dispose_old = null;
	}
	let file = new Uint8Array(await new Response(blob).arrayBuffer());
	let dv = new DataView(file.buffer);
	let contentelem = document.getElementById("content");
	contentelem.innerHTML = "";
	
	let sound_start = dv.getUint32(0x08, true);
	let sound_length = dv.getUint32(0x0C, true);
	let sample_rate = dv.getUint32(0x10, true);
	let num_channels = dv.getUint32(0x14, true);
	let num_chunks = (file.length - sound_start) / sound_length;
	
	let pre = document.createElement("pre");
	pre.textContent = `Sound length: ${sound_length} bytes, ${(sound_length * 24 / 16 / sample_rate).toFixed(3)} seconds
Sample rate: ${sample_rate} Hz`;
	contentelem.appendChild(pre);
	do_log(num_chunks + " chunks");
	let channels = [];
	let urls = [];
	for(let i = 0; i < num_channels; i++) {
		let chunk_arr = new Uint8Array(sound_length / num_channels * num_chunks);
		for(let j = 0; j < num_chunks; j++) {
			let begin = (j+i/num_channels) * sound_length + sound_start;
			let end = begin + sound_length / num_channels;
			chunk_arr.set(file.subarray(begin, end), j*sound_length/num_channels);
		}
		let sound = decode_adpcm(chunk_arr, 0, chunk_arr.length, sample_rate);
		let wav = new Blob([to_wav(sound.buffer)], {type:'audio/wav'});
		let url = URL.createObjectURL(wav);
		urls.push(url);
		let sound_elem = document.createElement("audio");
		sound_elem.src = url;
		sound_elem.controls = true;
		contentelem.appendChild(sound_elem);
		channels.push(sound);
	}
	dispose_old = () => {for(let url of urls) URL.revokeObjectURL(url);};
	
	/*let stereo_sound = new AudioBuffer({numberOfChannels: 2, length: (file.length - sound_start) / 2, sampleRate: sample_rate});
	let pre_buf = sound.buffer.getChannelData(0);
	let left_buf = stereo_sound.getChannelData(0);
	let right_buf = stereo_sound.getChannelData(1);

	let chunk_samples = sound_length / 16 * 28 / 2;
	for(let chunk = 0; chunk < num_chunks; chunk++) {
		let pre_off = chunk * chunk_samples*2;
		let stereo_off = chunk * chunk_samples;
		for(let i = 0; i < chunk_samples; i++) {
			left_buf[stereo_off+i] = pre_buf[pre_off+i];
			right_buf[stereo_off+i] = pre_buf[pre_off+i+chunk_samples];
		}
	}*/
}

async function set_sblk(blob) {
	if(dispose_old) {
		dispose_old();
		dispose_old = null;
	}

	let file = new Uint8Array(await new Response(blob).arrayBuffer());
	let dv = new DataView(file.buffer);
	let contentelem = document.getElementById("content");
	contentelem.innerHTML = "";

	let header_size = dv.getUint32(0x08, true);
	let num_sounds = dv.getUint16(0x16 + header_size, true);
	let soundarr_ptr = dv.getUint32(0x1c + header_size, true) + header_size;
	let soundarr2_ptr = dv.getUint32(0x20 + header_size, true) + header_size;
	let soundarr3_ptr = dv.getUint32(0x34 + header_size, true) + header_size;
	let sound_start = dv.getUint32(0x10, true);
	//let sound_end = dv.getUint32(0x14, true) + sound_start;
	let urls = [];
	let elem = document.createElement("pre");
	elem.textContent += "Sound start: " + sound_start+"\n";
	for(let i = 0; i < num_sounds; i++) {
		try {
			elem.textContent += "Sound " + i + ":\n"
			let sound_ptr = i * 12 + soundarr_ptr;
			if(dv.getUint8(sound_ptr + 4) == 0) {
				elem.textContent += "Blank!\n";
			} else {
				elem.textContent += "  Default volume: " + dv.getUint16(sound_ptr, true) + "\n";
				elem.textContent += "  Default _2: " + dv.getUint16(sound_ptr+2, true) + "\n";
				let num_sa2 = dv.getUint8(sound_ptr + 4);
				let sound_2_ptr = dv.getInt32(sound_ptr + 8, true) + soundarr2_ptr;
				elem.textContent += "  Num entries: " + num_sa2 + "\n";
				for(let j = 0; j < num_sa2; j++) {
					let entry2 = sound_2_ptr + j*8;
					let e2_type = dv.getUint8(entry2 + 3); // Index into function table at 0x21188
					elem.textContent += "    Type: " + e2_type + "\n";
					if(e2_type == 1) {
						let offset = dv.getUint32(entry2, true) & 0xFFFFFF;
						elem.textContent += "      Offset: " + offset + "\n";
						elem.textContent += "      Other: " + dv.getUint32(entry2 + 4, true) + "\n";
						let sound_3_ptr = offset + soundarr3_ptr;
						let this_sound_start = sound_start + dv.getUint32(sound_3_ptr + 0x10, true);
						elem.textContent += "      Sound start: " + (this_sound_start - sound_start);
						let sound = decode_adpcm(file, this_sound_start, file.length, 16000);
						let wav = new Blob([to_wav(sound.buffer)], {type:'audio/wav'});
						let url = URL.createObjectURL(wav);
						urls.push(url);
						let sound_elem = document.createElement("audio");
						sound_elem.src = url;
						sound_elem.controls = true;
						contentelem.appendChild(elem);
						elem = document.createElement("pre");
						contentelem.appendChild(sound_elem);
						
					} else {
						elem.textContent += "      " + dv.getUint32(entry2, true).toString(16).padStart(8, 0) + " " + dv.getUint32(entry2+4, true).toString(16).padStart(8, 0)+"\n";
					}
				}
			}
		} catch(e) {
			elem.textContent += e + "\n";
		}
		//await new Promise((resolve) => {setTimeout(resolve, 1);});
	}
	if(elem.textContent) contentelem.appendChild(elem);
	dispose_old = () => {for(let url of urls) URL.revokeObjectURL(url);};
}

async function set_file(blob, parent, force_hex) {
	if(dispose_old) {
		dispose_old();
		dispose_old = null;
	}
	let file = new Uint8Array(await new Response(blob).arrayBuffer());
	let dv = new DataView(file.buffer);
	let header_size = dv.getInt16(6, true) + 16;
	let contentelem = document.getElementById("content");
	if(!force_hex && file[3] == 0x4 && file[4] == 0x4 && file[5] == 0x0) {
		do_log("TEXTURE");
		let img_data_start = dv.getInt32(header_size + 4, true) + header_size;
		let props_start = dv.getInt32(header_size+8, true)+header_size;
		let img_width = dv.getInt32(props_start+64, true) * 2;
		let img_height = dv.getInt32(props_start+68, true) * 2;
		do_log(img_data_start + ", " + img_width + ", " + img_height);
		
		let canvas = document.createElement("canvas");
		let swizzle_map;
		canvas.style.width = "1024px";
		contentelem.innerHTML = "";
		contentelem.appendChild(canvas);
		canvas.tabIndex = "0";
		canvas.width = img_width;
		canvas.height = img_height;
		function redraw(palette_x, palette_y, fourbit = false) {
			
			if(fourbit) {
				const xoffs1 = [0, 1, 2, 3, 4, 5, 6, 7, 1, 0, 3, 2, 5, 4, 7, 6];
				const xoffs2 = [1, 0, 3, 2, 5, 4, 7, 6, 0, 1, 2, 3, 4, 5, 6, 7];
				let fheight = img_height * 2;
				canvas.height = fheight;
				let ctx = canvas.getContext("2d");
				let imagedata = ctx.getImageData(0, 0, img_width, fheight);
				let palette;
				if(palette_x != undefined) {
					palette = new Uint8Array(64);
					let curr_img_byte = img_data_start + swizzle_map[palette_y * img_width + palette_x];
					for(let i = 0; i < 2; i++) {
						palette.set(file.slice(curr_img_byte, curr_img_byte + 32), i * 32);
						curr_img_byte += img_width*2; // again, multiplied by two because S W I Z Z L I N G (tm)
					}
					for(let i = 0; i < 16; i++) {
						palette[i*4+3] = palette[i*4+3] * 255 / 128;
					}
				}
				swizzle_map = new Uint32Array(img_width*fheight);
				let curr_img_byte = img_data_start;
				let lower_nib = false;
				for(let row512 = 0; row512 < fheight; row512 += 128) {
					for(let block = 0; block < 128; block += 32) {
						for(let row4 = 0; row4 < 4; row4++) {
							for(let oddness = 0; oddness < 2; oddness++) {
								for(let col128 = 0; col128 < img_width; col128 += 128) {
									for(let row16 = 0; row16 < 8; row16 += 1) {
										for(let blockhalf = 0; blockhalf < 2; blockhalf++) {
											for(let blockcol = 0; blockcol < 4; blockcol++) {
												for(let blocksect = 0; blocksect < 8; blocksect++) {
													let xoffs = (row4 % 2) != 0 ? xoffs1 : xoffs2;
													let x = col128 + block + xoffs[blocksect + (blockhalf*8)]*4 + blockcol;
													let y = row512 + row16*16 + row4*4 + oddness + ((1-(blocksect % 2))*2);
													if(curr_img_byte >= file.length) continue;
													let index;
													swizzle_map[y*img_width+x] = curr_img_byte - img_data_start;
													if(lower_nib) {
														index = file[curr_img_byte++] & 0xF;
													} else {
														index = (file[curr_img_byte] & 0xF0) >> 4;
													}
													lower_nib = !lower_nib;
													let p = y*img_width*4+x*4;
													if(palette) {
														imagedata.data[p] = palette[index*4+0];
														imagedata.data[p+1] = palette[index*4+1];
														imagedata.data[p+2] = palette[index*4+2];
														imagedata.data[p+3] = palette[index*4+3];
													} else {
														imagedata.data[p] = index*16+index;
														imagedata.data[p+1] = index*16+index;
														imagedata.data[p+2] = index*16+index;
														imagedata.data[p+3] = 255;
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				ctx.putImageData(imagedata, 0, 0);
				if(palette) {
					ctx.strokeStyle = "red";
					ctx.rect(palette_x+0.5, palette_y+0.5, 31, 15);
					ctx.stroke();
				}
			} else {		
				const xoffs1 = [0, 1, 2, 3, 1, 0, 3, 2];
				const xoffs2 = [1, 0, 3, 2, 0, 1, 2, 3];
				canvas.height = img_height;
				let ctx = canvas.getContext("2d");
				let imagedata = ctx.getImageData(0, 0, img_width, img_height);
				let palette;
				if(palette_x != undefined) {
					pre_palette = new Uint8Array(1024);
					let curr_img_byte = img_data_start + (palette_y * img_width) + (palette_x * 2); // x gets multiplied by two because S W I Z Z L I N G (tm)
					for(let i = 0; i < 16; i++) {
						pre_palette.set(file.slice(curr_img_byte, curr_img_byte + 64), i * 64);
						curr_img_byte += img_width*2; // again, multiplied by two because S W I Z Z L I N G (tm)
					}
					palette = new Uint8Array(1024);
					for(let i = 0; i < 256; i++) {
						// Deswizzle the palette which is swizzled differently from the image.
						let dblock = Math.floor(i / 32);
						let block = Math.floor(i / 16)%2;
						let chunk = Math.floor(i / 8)%2;
						let subindex = i % 8;
						
						let index = (dblock*32)+(((chunk*2)%8+block)*8)+subindex;
						
						palette[index*4+0] = pre_palette[i*4+0];
						palette[index*4+1] = pre_palette[i*4+1];
						palette[index*4+2] = pre_palette[i*4+2];
						palette[index*4+3] = Math.floor(pre_palette[i*4+3]*255/128);
						
					}
				}
				
				let curr_img_byte = img_data_start;
				for(let row4 = 0; row4 < img_height; row4 += 4) { // de-swizzle the image.
					for(let oddness = 0; oddness < 2; oddness++) {
						for(let block = 0; block < img_width; block += 16) {
							for(let blockhalf = 0; blockhalf < 2; blockhalf++) {
								for(let blockcol = 0; blockcol < 4; blockcol++) {
									for(let blocksect = 0; blocksect < 4; blocksect++) {
										let xoffs = (Math.floor(row4/4) % 2) != 0 ? xoffs2 : xoffs1;
										let x = block + xoffs[blocksect + (blockhalf*4)]*4 + blockcol;
										let y = row4 + oddness + ((blocksect % 2)*2);
										//do_log("(" + x + ", " + y + ")" + " row4:" + row4 + " oddness: " + oddness + "block: " + block);
										if(curr_img_byte >= file.length)
											continue;
										let index = file[curr_img_byte++];
										
										let p = y*img_width*4+x*4;
										if(palette) {
											imagedata.data[p] = palette[index*4+0];
											imagedata.data[p+1] = palette[index*4+1];
											imagedata.data[p+2] = palette[index*4+2];
											imagedata.data[p+3] = palette[index*4+3];
										} else {
											imagedata.data[p] = index;
											imagedata.data[p+1] = index;
											imagedata.data[p+2] = index;
											imagedata.data[p+3] = 255;
										}
									}
								}
							}
						}
					}
				}
				ctx.putImageData(imagedata, 0, 0);
				if(palette) {
					ctx.strokeStyle = "red";
					ctx.rect(palette_x+0.5, palette_y+0.5, 31, 31);
					ctx.stroke();
				}
			}
		}
		redraw(undefined, undefined, false);
		let curr_pal_x = undefined;
		let curr_pal_y = undefined;
		let fourbit = false;
		
		canvas.addEventListener("click", (e) => {
			let rect = canvas.getBoundingClientRect();
			let ix = (e.offsetX * (canvas.width / rect.width));
			let iy = (e.offsetY * (canvas.height / rect.height));
			let pal_x = Math.floor(ix / 32) * 32;
			let pal_y = fourbit ? (Math.floor(iy / 16) * 16) : (Math.floor(iy / 32) * 32);
			if(pal_x == curr_pal_x && pal_y == curr_pal_y) {
				curr_pal_x = undefined;
				curr_pal_y = undefined;
			} else {
				curr_pal_x = pal_x;
				curr_pal_y = pal_y;
			}
			redraw(curr_pal_x, curr_pal_y, fourbit);
		});
		canvas.addEventListener("dblclick", (e) => {
			fourbit = !fourbit;
			curr_pal_x = undefined;
			curr_pal_y = undefined;
			redraw(curr_pal_x, curr_pal_y, fourbit);
		});
		canvas.addEventListener("keydown", (e) => {
			do_log(e.which);
			if(curr_pal_x != undefined && curr_pal_y != undefined) {
				if(e.which == 188 && (curr_pal_x > 0 || curr_pal_y > 0)) {
					curr_pal_x -= 32;
					if(curr_pal_x < 0) {
						curr_pal_x += img_width;
						curr_pal_y -= fourbit?16:32;
					}
				} else if(e.which == 190 && (curr_pal_x < img_width-32 || curr_pal_y < (fourbit?img_height*2-16:img_height-32))) {
					curr_pal_x += 32;
					if(curr_pal_x >= img_width) {
						curr_pal_x -= img_width;
						curr_pal_y += fourbit?16:32;
					}
				}
				do_log(curr_pal_x + ", " + curr_pal_y);
				redraw(curr_pal_x, curr_pal_y, fourbit);
			}
		});
	} else if(!force_hex && file[3] == 0x1 && file[4] == 0x13 && file[5] == 0x0) {
		contentelem.innerHTML = "";
		
		let load_list_blob;
		for(let otherfile of parent) {
			if(otherfile.ident[0] == 0x1 && otherfile.ident[1] == 0xF && otherfile.ident[2] == 0x0) {
				load_list_blob = otherfile.blob;
				break;
			}
		}
		let load_list = [];
		if(load_list_blob) {
			let load_list_dv = new DataView(await new Response(load_list_blob).arrayBuffer());
			let load_list_header_size = load_list_dv.getInt16(6, true) + 16;
			let load_list_count = load_list_dv.getInt16(load_list_header_size + 0x10, true);
			for(let i = 0; i < load_list_count; i++) {
				load_list[i] = load_list_dv.getInt16(load_list_header_size+0x16+i*2, true);
			}
		}
		
		let pre = document.createElement("pre");
		let text = "";
		let x_offset = dv.getFloat32(header_size + 0x0, true);
		let y_offset = dv.getFloat32(header_size + 0x8, true);
		let scale = dv.getFloat32(header_size + 0x10, true);
		text += "X Offset: " + x_offset + "\n";
		text += "Y Offset: " + y_offset + "\n";
		text += "Scale Factor: " + scale + "\n";
		let table_width = dv.getInt32(header_size + 0x14, true);
		let table_height = dv.getInt32(header_size + 0x18, true);
		let table_offset = header_size + dv.getInt32(header_size + 0x1c, true);
		let legend = [];
		let zone_map = [];
		let canvas = document.createElement("canvas");
		canvas.style.width = "1024px";
		let ctx = canvas.getContext('2d');
		contentelem.appendChild(canvas);
		canvas.width = table_width;
		canvas.height = table_height;
		let imagedata = ctx.getImageData(0, 0, table_width, table_height);
		let legend_index = 0;
		for(let y = 0; y < table_height; y++) {
			for(let x = 0; x < table_width; x++) {
				let pointer = dv.getInt32(table_offset + (y * table_width + x) * 4, true);
				if(pointer != 0) {
					let zone_id = dv.getInt16(pointer + header_size + 0x18, true)
					text += "(" + x + ", " + y + "): \n";					
					text += "\t Zone ID: " + zone_id + "\n";
					zone_map[y*table_width+x] = zone_id;
					if(load_list[zone_id] >= 0) {
						let load_id = load_list[zone_id];
						if(!legend[load_id]) {
							legend[load_id] = get_map_color(legend_index++);
						}
						let color = legend[load_id];
						let id_p = (y * table_width + x) * 4;
						imagedata.data[id_p] = color[0];
						imagedata.data[id_p+1] = color[1];
						imagedata.data[id_p+2] = color[2];
						imagedata.data[id_p+3] = 255;
					}
				}
			}
		}
		ctx.putImageData(imagedata,0,0);
		for(let i = 0; i < legend.length; i++) {
			if(!legend[i])
				continue;
			let div = document.createElement("div");
			let color_label = document.createElement("span");
			let id_label = document.createElement("span");
			color_label.textContent = "**";
			id_label.textContent = ": Loads 0x" + i.toString(16);
			color_label.style.color = "rgb(" + legend[i][0] + ", " + legend[i][1] + ", " + legend[i][2] + ")";
			div.appendChild(color_label);
			div.appendChild(id_label);
			contentelem.appendChild(div);
		}
		
		canvas.addEventListener("mousemove", (e) => {
			let rect = canvas.getBoundingClientRect();
			let ix = (e.offsetX * (canvas.width / rect.width));
			let iy = (e.offsetY * (canvas.height / rect.height));
			let zone = zone_map[Math.floor(iy)*table_width+Math.floor(ix)];
			let text = "(" + (ix*scale+x_offset).toFixed(2) + ", " + (iy*scale+y_offset).toFixed(2) + ") " + zone;
			if(load_list[zone] >= 0)
				text += " (loads 0x" + load_list[zone].toString(16).padStart(4,0) + ")";
			canvas.title = text;
		});
		pre.textContent = text;
		contentelem.appendChild(pre);
	} else if(!force_hex && file[3] == 0x1 && (file[4] == 0xD || file[4] == 0x3 || file[4] == 0xC) && file[5] == 0x0) {
		contentelem.innerHTML = "";
		let camera = new THREE.PerspectiveCamera(70, 1.333, 0.01, 30000);
		do_log(camera);
		
		let dispose_list = [];
		dispose_old = () => {
			for(let item of dispose_list) {
				if(item && item.dispose) item.dispose();
			}
		};
		
		let materials = [];
		let materials_blob;
		let this_indent = 0;
		for(let otherfile of parent) {
			if(!this_indent && otherfile.blob == blob) {
				this_indent = otherfile.indent;
				break;
			}
		}
		for(let otherfile of parent) {
			if(otherfile.indent <= this_indent && otherfile.ident[0] == 0x1 && otherfile.ident[1] == 0x2 && otherfile.ident[2] == 0x0) {
				materials_blob = otherfile.blob;
			}
			if(otherfile.blob == blob)
				break;
		}
		if(materials_blob) {
			materials = await extract_materials(materials_blob, parent);
		} else {
			materials = await extract_materials(file_list[0x7][0].blob, file_list[0x7]);
		}
		for(let material of materials) {
			if(material.canvas) {
				material.texture = new THREE.CanvasTexture(material.canvas, THREE.UVMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.NearestFilter,THREE.NearestFilter);
				dispose_list.push(material.texture);
			}
		}
		do_log(materials);
		
		let scene = new THREE.Scene();
		scene.background = new THREE.Color(0x404080);
		dispose_list.push(scene);
		
		let light = new THREE.HemisphereLight();
		light.color.setRGB( 0.8, 0.7, 0.6 );
		scene.add( light );
		dispose_list.push(light);
		
		let parts = [];
		let parts_string = "";
		let origin = new THREE.Vector3();
		let origin_total = 0;
		let curr_mat_index = null;
		let render_order = 0;
		for(let offset = header_size; offset <= file.length-4; offset += 4) {
			if(dv.getUint32(offset, true) != 0x3F3F3F3F)
				continue;
			offset += 4;
			if(curr_mat_index == null) {
				curr_mat_index = dv.getUint16(offset - 0x4C, true);
				if(dv.getUint32(offset - 0x58, true) == 0)
					curr_mat_index = dv.getUint16(offset - 0x5C, true);
			}
			let this_mat_index = curr_mat_index;
			let part_string = "PART " + parts.length + "\n";
			part_string += "Material " + this_mat_index + "\n";
			part_string += "Offset 0x" + offset.toString(16) + "\n";
			let geometry = new THREE.BufferGeometry();
			dispose_list.push(geometry);
			let indices;
			let is_transparent = false;
			while(true) {
				if(offset > file.length-4)
					break;
				let num_verts = file[offset+2];
				part_string += file[offset].toString(16) + " " + file[offset+1].toString(16) + " " + file[offset+2].toString(16) + " " + file[offset+3].toString(16) + "\n";
				if(file[offset+1] == 0x80 && file[offset+3] == 0x68) {
					offset += 4;
					if(!geometry.getAttribute('position')) {
						for(let i = 0; i < num_verts; i++) {
							origin.x += dv.getFloat32(offset+(i*12)+0, true);
							origin.y += dv.getFloat32(offset+(i*12)+4, true);
							origin.z += dv.getFloat32(offset+(i*12)+8, true);
							origin_total++;
						}
						geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(file.buffer, offset, num_verts*3), 3));
					} else if(!geometry.getAttribute('normal')) {
						geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(file.buffer, offset, num_verts*3), 3));
						// generally, models with normals use 0x10 for white instead of 0x80 in the color map (or 0x20 instead of 0xff if textured).
						// I'm not 100% sure this is how it's done but it seems to work
						if(file[4] == 0xD) {
							let color_attribute = geometry.getAttribute('color');
							let alpha_attribute = geometry.getAttribute('alpha');
							let color_arr = color_attribute.array;
							let alpha_arr = alpha_attribute.array;
							for(let i = 0; i < color_arr.length; i++) {
								color_arr[i] *= 0x08; // scale the thing
							}
							for(let i = 0; i < alpha_arr.length; i++) {
								//alpha_arr[i] *= 0x08; // scale the other thing
								alpha_arr[i] = 1; // alpha is forced to one I guess
							}
							alpha_attribute.needsUpdate = true;
							color_attribute.needsUpdate = true;
						}
					} else if(!geometry.vertex_group_weights) {
						geometry.vertex_group_weights = new Float32Array(file.buffer, offset, num_verts*3);
					}
					offset += num_verts * 12;
				} else if(file[offset+1] == 0x80 && file[offset+3] == 0x72) {
					offset += 4;
					indices = [];
					for(let i = 2; i < num_verts; i++) {
						if(file[offset+i] >= 0x80)
							continue;
						indices.push(i-2);
						indices.push(i-1);
						indices.push(i-0);
					}
					offset += Math.ceil(num_verts/4)*4;
				} else if(file[offset+1] == 0xC0 && file[offset+3] == 0x6E){
					let colortype = file[offset];
					offset += 4;
					if(!geometry.getAttribute('color')) {
						let colors = new Float32Array(num_verts*3);
						let alphas = new Float32Array(num_verts);
						for(let i = 0; i < num_verts; i++) {
							let one_level = 0x80;
							let multiplier = (materials[this_mat_index] && materials[this_mat_index].texture) ? 1 : 0.5;
							colors[i*3] = (file[offset+i*4] / one_level * multiplier);
							colors[i*3+1] = (file[offset+i*4+1] / one_level * multiplier);
							colors[i*3+2] = (file[offset+i*4+2] / one_level * multiplier);
							alphas[i] = (file[offset+i*4+3] / one_level);
							if(alphas[i] < 1) is_transparent = true;
						}
						geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
						geometry.addAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
					} else if(!geometry.vertex_group_offsets) {
						geometry.vertex_group_offsets = new Uint8Array(file.buffer, offset, num_verts*4);
					}
					offset += num_verts * 4;
				} else if(file[offset+1] == 0x80 && file[offset+3] == 0x64) {
					offset += 4;
					let flipped_uvs = new Float32Array(new Float32Array(file.buffer, offset, num_verts*2));
					for(let i = 1; i < flipped_uvs.length; i += 2) {
						flipped_uvs[i] = 1 - flipped_uvs[i];
					}
					geometry.addAttribute('uv', new THREE.BufferAttribute(flipped_uvs, 2));
					offset += num_verts * 8;
				} else {
					if(dv.getUint32(offset, true) != 0x17000000) {
						curr_mat_index = null;
					}
					break;
				}
			}
			if(indices) {
				// make them all face the same way as their normals if they exist
				if(geometry.getAttribute('normal')) {
					let normals = geometry.getAttribute('normal').array;
					let vertices = geometry.getAttribute('position').array;
					let flip_odd = 0;
					let flip_even = 0;
					for(let i = 0; i < indices.length; i += 3) {
						let v1 = new THREE.Vector3(vertices[indices[i+0]*3+0], vertices[indices[i+0]*3+1], vertices[indices[i+0]*3+2]);
						let v2 = new THREE.Vector3(vertices[indices[i+1]*3+0], vertices[indices[i+1]*3+1], vertices[indices[i+1]*3+2]);
						let v3 = new THREE.Vector3(vertices[indices[i+2]*3+0], vertices[indices[i+2]*3+1], vertices[indices[i+2]*3+2]);
						let normal_sum = new THREE.Vector3(normals[indices[i+0]*3+0], normals[indices[i+0]*3+1], normals[indices[i+0]*3+2])
							.add(new THREE.Vector3(normals[indices[i+1]*3+0], normals[indices[i+1]*3+1], normals[indices[i+1]*3+2]))
							.add(new THREE.Vector3(normals[indices[i+2]*3+0], normals[indices[i+2]*3+1], normals[indices[i+2]*3+2]));
						if(v2.sub(v1).cross(v3.sub(v1)).dot(normal_sum) < 0) { // triangle's facing the wrong way
							[indices[i+1], indices[i+0]] = [indices[i+0], indices[i+1]];
						}
					}
				}
				geometry.setIndex(indices);
			}
			let material = new (geometry.getAttribute('normal') ? THREE.MeshPhongMaterial : THREE.MeshBasicMaterial)({side: THREE.DoubleSide, vertexColors: THREE.VertexColors, transparent: is_transparent || (materials[this_mat_index] && materials[this_mat_index].has_transparency), opacity: 1, alphaTest: 0.05});
			if(materials[this_mat_index] && materials[this_mat_index].texture) {
				material.map = materials[this_mat_index].texture
			}
			let mesh = new THREE.Mesh(geometry, material);
			dispose_list.push(mesh);
			dispose_list.push(material);
			mesh.part_string = part_string;
			mesh.mat_index = this_mat_index;
			parts_string += part_string;
			mesh.renderOrder = --render_order;
			scene.add(mesh);
			parts.push(mesh);
		}
		
		function build_file() {
			let total_verts = 0;
			let total_faces = 0;
			let verts_str = "";
			let faces_str = "";
			for(let part of parts) {
				let geometry = part.geometry;
				let pos_array = geometry.getAttribute('position').array;
				let color_array, alpha_array, normal_array, uv_array;
				if(geometry.getAttribute('color')) color_array = geometry.getAttribute('color').array;
				if(geometry.getAttribute('alpha')) alpha_array = geometry.getAttribute('alpha').array;
				if(geometry.getAttribute('normal')) normal_array = geometry.getAttribute('normal').array;
				if(geometry.getAttribute('uv')) uv_array = geometry.getAttribute('uv').array;
				let num_verts = pos_array.length/3;
				for(let i = 0; i < num_verts; i++) {
					let verts_line = `${pos_array[i*3]} ${pos_array[i*3+1]} ${pos_array[i*3+2]} `;
					if(color_array) {
						verts_line += `${color_array[i*3]} ${color_array[i*3+1]} ${color_array[i*3+2]} `;
					} else {
						verts_line += `255 255 255 `;
					}
					if(alpha_array) {
						verts_line += `${alpha_array[i]} `;
					} else {
						verts_line += `255 `;
					}
					if(normal_array) {
						verts_line += `${normal_array[i*3]} ${normal_array[i*3+1]} ${normal_array[i*3+2]} `;
					} else {
						verts_line += `0 1 0 `;
					}
					if(uv_array) {
						verts_line += `${uv_array[i*2]} ${uv_array[i*2+1]} `;
					} else {
						verts_line += `0 0 `;
					}
					verts_line += part.mat_index + "\n";
					verts_str += verts_line;
				}
				let indices = geometry.getIndex().array;
				for(let i = 0; i < indices.length; i += 3) {
					faces_str += `3 ${indices[i] + total_verts} ${indices[i+1] + total_verts} ${indices[i+2] + total_verts}\n`
				}
				total_faces += indices.length/3;
				total_verts += num_verts;
			}
			return `ply
format ascii 1.0
element vertex ${total_verts}
property float x
property float y
property float z
property float red
property float green
property float blue
property float alpha
property float nx
property float ny
property float nz
property float s
property float t
property int material_index
element face ${total_faces}
property list uchar int vertex_index
end_header
${verts_str}${faces_str}`;
		}
		
		function build_py_file(filename) {
			let escaped_filename = filename.replace(/("\\)/g, "\\$1");
			let total_verts = 0;
			let total_faces = 0;
			let verts_str = [];
			let faces_str = [];
			let colors_str = [];
			let vgo_str = [];
			let vgw_str = [];
			let uvs_str = [];
			let mats_str = [];
			let mat_def_str = [];
			let evenness = 0;
			let face_evenness = 0;
			let mat_evenness = 0;
			let color_evenness = 0;
			let uv_evenness = 0;
			let use_diffuse = [];
			let used_mats = [];
			for(let part of parts) {
				if(!used_mats.includes(part.mat_index)) {
					used_mats.push(part.mat_index);
				}
			}
			used_mats.sort((a,b)=>{return a-b;});
			for(let part of parts) {
				let geometry = part.geometry;
				let pos_array = geometry.getAttribute('position').array;
				let color_array, alpha_array, normal_array, uv_array, vgw_array, vgo_array;
				if(geometry.getAttribute('color')) color_array = geometry.getAttribute('color').array;
				if(geometry.getAttribute('alpha')) alpha_array = geometry.getAttribute('alpha').array;
				if(geometry.getAttribute('normal')) normal_array = geometry.getAttribute('normal').array;
				if(geometry.getAttribute('uv')) uv_array = geometry.getAttribute('uv').array;
				if(geometry.vertex_group_weights) vgw_array = geometry.vertex_group_weights;
				if(geometry.vertex_group_offsets) vgo_array = geometry.vertex_group_offsets;
				
				if(normal_array) use_diffuse[part.mat_index] = true;
				
				let num_verts = pos_array.length/3;
				for(let i = 0; i < num_verts; i++) {
					let verts_line = `(${pos_array[i*3]},${-pos_array[i*3+2]},${pos_array[i*3+1]})`;
					evenness++;
					if((evenness % 10) == 0) {
						evenness = 0;
						verts_line = "\n" + verts_line;
					}
					verts_str.push(verts_line);
					let prefix_rgb = "";
					color_evenness++;
					if((color_evenness % 10) == 0) {
						prefix_rgb = "\n";
						color_evenness = 0;
					}
					
					if(color_array) {
						colors_str.push(prefix_rgb+`(${color_array[i*3]},${color_array[i*3+1]},${color_array[i*3+2]},${alpha_array?alpha_array[i]:1})`);
					} else {
						colors_str.push(prefix_rgb+`(1,1,1,${alpha_array?alpha_array[i]:1})`)
					}
					
					uv_evenness++;
					let prefix_uv = "";
					if((uv_evenness % 15) == 0) {
						prefix_uv = "\n";
						uv_evenness = 0;
					}
					if(uv_array) {
						uvs_str.push(prefix_uv+`(${uv_array[i*2]},${uv_array[i*2+1]})`);
					} else {
						uvs_str.push(prefix_uv+`(0,0)`);
					}

					if(vgo_array) {
						let parts = [];
						for(let j = 0; j < 3; j++) {
							let weight = vgw_array[i*3+j];
							let num = vgo_array[i*4+j];
							if(weight == 0) parts.push("None");
							else parts.push(`'bone_${num/3}'`);
						}
						vgo_str.push(prefix_uv+`(${parts})`);
					} else {
						vgo_str.push(prefix_uv+`(None,None,None)`);
					}
					if(vgw_array) {
						vgw_str.push(prefix_uv+`(${vgw_array[i*3]},${vgw_array[i*3+1]},${vgw_array[i*3+2]})`);
					}
				}
				let indices = geometry.getIndex().array;
				for(let i = 0; i < indices.length; i += 3) {
					face_evenness++;
					let prefix = "";
					if((face_evenness % 10) == 0) {
						face_evenness = 0;
						prefix = "\n";
					}
					faces_str.push(`${prefix}(${indices[i] + total_verts},${indices[i+1] + total_verts},${indices[i+2] + total_verts})`);
					mat_evenness++
					prefix = "";
					if((mat_evenness % 30) == 0) {
						mat_evenness = 0;
						prefix = "\n";
					}
					mats_str.push(prefix+used_mats.indexOf(part.mat_index));
				}
				total_faces += indices.length/3;
				total_verts += num_verts;
			}
			
			for(let i = 0; i < materials.length; i++) {
				if(!used_mats.includes(i)) continue;
				let material = materials[i];
				let texture_code = "";
				if(material.canvas) {
					texture_code = `node_tex = nodes.new(type='ShaderNodeTexImage')
node_tex.interpolation = "Closest" 
tex_data = '${material.canvas.toDataURL().substring(22)}'
bytes = base64.b64decode(tex_data)
fh = open(os.path.join(bpy.app.tempdir,"${escaped_filename}_m${i}_img.png"), "wb")
fh.write(bytes)
fh.close()
img = bpy.data.images.load(os.path.join(bpy.app.tempdir,"${escaped_filename}_m${i}_img.png"), check_existing=False)
img.pack()
img.name = "${escaped_filename}_m${i}_img"
node_tex.image = img
node_tex.location = -800,-400
links.new(node_tex.outputs[0], node_mixrgb.inputs[2])
links.new(node_tex.outputs[1], node_math.inputs[1])

`;
				}
				mat_def_str.push(`mat = bpy.data.materials.new("${escaped_filename}_m${i}")
mat.use_nodes = True
mat.blend_method = "HASHED"
nodes = mat.node_tree.nodes
for node in nodes:
	nodes.remove(node)
links = mat.node_tree.links

node_attribute = nodes.new(type='ShaderNodeAttribute')
node_attribute.attribute_name = 'Col'
node_attribute.location = -800,0
node_attribute_a = nodes.new(type='ShaderNodeAttribute')
node_attribute_a.attribute_name = 'Alpha'
node_attribute_a.location = -800,400

node_mixrgb = nodes.new(type='ShaderNodeMixRGB')
node_mixrgb.blend_type = 'MULTIPLY'
node_mixrgb.inputs[0].default_value = 1
node_mixrgb.location = -400,0
links.new(node_attribute.outputs[0], node_mixrgb.inputs[1])

node_math = nodes.new(type='ShaderNodeMath')
node_math.operation = 'MULTIPLY'
node_math.inputs[1].default_value = 1
node_math.location = -400,400
links.new(node_attribute_a.outputs[0], node_math.inputs[0])

${texture_code}node_mat = nodes.new(type='ShaderNode${!use_diffuse[i] ? "Emission" : "BsdfDiffuse"}')
node_mat.location = 0,0
links.new(node_mixrgb.outputs[0], node_mat.inputs[0])

node_transparent = nodes.new(type='ShaderNodeBsdfTransparent')
node_transparent.location = 0,400

node_mixshader = nodes.new(type='ShaderNodeMixShader')
node_mixshader.location = 400,0
links.new(node_math.outputs[0], node_mixshader.inputs[0])
links.new(node_transparent.outputs[0], node_mixshader.inputs[1])
links.new(node_mat.outputs[0], node_mixshader.inputs[2])

node_output = nodes.new(type='ShaderNodeOutputMaterial')
node_output.location = 800,0
links.new(node_mixshader.outputs[0], node_output.inputs[0])

mesh.materials.append(mat)
`);
			}
			


			return `import bpy
import base64
import io
import os

verts = (${verts_str.join(",")})
faces = (${faces_str.join(",")})
mats_index = (${mats_str.join(",")})
colors_rgb_in = (${colors_str.join(",")})
uv_in = (${uvs_str.join(",")})
vgo_in = (${vgo_str.join(",")})
vgw_in = (${vgw_str.join(",")})

scene = bpy.context.scene
mesh = bpy.data.meshes.new("${escaped_filename}")
mesh.from_pydata(verts, [], faces)

colors_rgb = mesh.vertex_colors.new(name="Col")
colors_a = mesh.vertex_colors.new(name="Alpha")
for loop in mesh.loops:
	colors_rgb.data[loop.index].color = colors_rgb_in[loop.vertex_index]
	color_a_in = colors_rgb_in[loop.vertex_index][3]
	colors_a.data[loop.index].color = (color_a_in,color_a_in,color_a_in,1)
uv = mesh.uv_layers.new(name="UVMap")
for loop in mesh.loops:
	uv.data[loop.index].uv = uv_in[loop.vertex_index]

obj = bpy.data.objects.new("${escaped_filename}", mesh)
scene.collection.objects.link(obj)

for i in range(0, ${total_verts}):
	vg_names = vgo_in[i]
	vg_weights = vgw_in[i]
	for j in range(0, 3):
		if vg_names[j] == None:
			continue
		group = obj.vertex_groups.get(vg_names[j])
		if group == None:
			group = obj.vertex_groups.new(name=vg_names[j])
		group.add([i], vg_weights[j], 'REPLACE')

mesh.materials.clear()

${mat_def_str.join("\n")}

for i in range(0, ${total_faces}):
	mesh.polygons[i].material_index = mats_index[i]`
		}
		
		if(origin_total > 0) {
			origin.divideScalar(origin_total);
		}
		if(origin.x != origin.x) origin.x = 0;
		if(origin.y != origin.y) origin.y = 0;
		if(origin.z != origin.z) origin.z = 0;
		
		let renderer = new THREE.WebGLRenderer({antialias: true, precision: "highp", sortObjects: false});
		renderer.setSize(1024, 768);
		contentelem.appendChild(renderer.domElement);
		dispose_list.push(renderer);
		
		let info_overlay = document.createElement("pre");
		info_overlay.classList.add("info-overlay");
		contentelem.appendChild(info_overlay);
		
		contentelem.appendChild(document.createElement("br"));
		
		let save_button = document.createElement("input");
		save_button.type = "button";
		save_button.value = "Save model (.ply)";
		save_button.addEventListener("click", () => {
			let filename = prompt("filename? (no extension)");
			if(filename) saveAs(new Blob([build_file()], {type:"text/plain"}), filename + ".ply");
		});
		contentelem.appendChild(save_button);
		
		let save_py_button = document.createElement("input");
		save_py_button.type = "button";
		save_py_button.value = "Save model (Blender .py)";
		save_py_button.addEventListener("click", () => {
			let filename = prompt("filename? (no extension)");
			saveAs(new Blob([build_py_file(filename)], {type:"application/x-python-code"}), filename + ".py");
		});
		contentelem.appendChild(save_py_button);
		
		let pitch = 0;
		let yaw = 0;
		let distance = 1;
		
		renderer.domElement.addEventListener("mousedown", (e) => {
			let lastx = e.screenX;
			let lasty = e.screenY;
			function mousemove_handler(e2) {
				let dx = (e2.screenX - lastx)/renderer.domElement.height*2;
				let dy = (e2.screenY - lasty)/renderer.domElement.height*2;
				lastx = e2.screenX;
				lasty = e2.screenY;
				if(e.button == 2) {
					let fov_tan = Math.tan(camera.fov * Math.PI / 180 / 2);
					origin.add(new THREE.Vector3(-dx*distance*fov_tan,dy*distance*fov_tan,0).applyEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ')));
				} else {
					pitch -= dy * 4;
					yaw -= dx * 4;
				}
				render();
				e2.preventDefault();
			}
			function mouseup_handler(e2) {
				document.removeEventListener("mousemove", mousemove_handler);
				document.removeEventListener("mouseup", mouseup_handler);
				e2.preventDefault();
			}
			document.addEventListener("mousemove", mousemove_handler);
			document.addEventListener("mouseup", mouseup_handler);
			e.preventDefault();
		});
		let mouse_vector = new THREE.Vector2();
		let raycaster = new THREE.Raycaster();
		let last_hit = null;
		renderer.domElement.addEventListener("mousemove", (e) => {
			let rect = renderer.domElement.getBoundingClientRect();
			mouse_vector.x = (e.offsetX / rect.width) * 2 - 1
			mouse_vector.y = -(e.offsetY / rect.height) * 2 + 1;
			
			raycaster.setFromCamera(mouse_vector, camera);
			let intersects = raycaster.intersectObjects(scene.children);
			if(!intersects.length ? (last_hit) : (last_hit != intersects[0].object)) {					
				if(last_hit) {
					last_hit.material.color.set(0xFFFFFF);
					last_hit = null;
					info_overlay.textContent = "";
				}
				if(intersects.length >= 1) {
					intersects[0].object.material.color.set(0xFF0000);
					last_hit = intersects[0].object;
				}
				render();
			}
			if(intersects.length >= 1) {
				let point = intersects[0].point;
				info_overlay.textContent = "(" + point.x.toFixed(2) + "," + point.y.toFixed(2) + "," + point.z.toFixed(2) + ")\n" + last_hit.part_string;
			}
		});
		renderer.domElement.addEventListener("mouseout", (e) => {
			if(last_hit) {
				last_hit.material.color.set(0xFFFFFF);
				info_overlay.textContent = "";
				render();
				last_hit = null;
			}
		});
		renderer.domElement.addEventListener("wheel", (e) => {
			distance *= (Math.E**(e.deltaY*0.003));
			render();
		});
		renderer.domElement.addEventListener("contextmenu", e => {e.preventDefault();});
		
		render();
		function render() {
			camera.position.copy(origin);
			camera.setRotationFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
			camera.translateZ(distance);
			camera.updateMatrix();
			renderer.render(scene, camera);
		}
	} else if(!force_hex && file[3] == 0x1 && file[4] == 0x2 && file[5] == 0x0) {
		contentelem.innerHTML = "";
		let materials = await extract_materials(blob, parent);
		for(let material of materials) {
			let pre = document.createElement("pre");
			pre.textContent = material.string;
			contentelem.appendChild(pre);
			if(material.canvas) contentelem.appendChild(material.canvas);
		}
	} else if(!force_hex && file[3] == 0x4 && file[4] == 0x25 && file[5] == 0x0) {
		contentelem.innerHTML = "";
		let text = "";
		let endtext = "";
		let masks = new Map();
		for(let [template, inst] of Object.entries(mips_instructions)) {
			let mask_num = parseInt(template.replace(/[01]/g, "1").replace(/\?/g, "0"), 2) | 0;
			let template_num = parseInt(template.replace(/\?/g, "0"), 2) | 0;
			let mask = masks.get(mask_num);
			if(!mask) {
				mask = new Map();
				masks.set(mask_num, mask);
			}
			if(mask.has(template_num)) {console.warn(`${inst.name} shares opcode with ${mask.get(template_num).name}!`);}
			mask.set(template_num, inst);
		}
		
		let symbols = [];
		let symbols_raw = [];
		let defined_functions = {};
		let last_function = 0x100;
		let first_symbol_string = file.length - header_size;
		let string_table_end = 0;
		let datasymbol_addrs = new Set();
		let symbol_table_offset = dv.getUint32(12 + header_size, true) + header_size;
		let symbol_table_count = dv.getUint32(16 + header_size, true);
		endtext += "Symbols: \n";
		for(let i = 0; i < symbol_table_count; i++) {
			let i_offset = i * 12 + symbol_table_offset;
			let i_a = dv.getUint32(i_offset+0, true);
			let i_b = dv.getUint32(i_offset+4, true);
			let i_c = dv.getUint32(i_offset+8, true);
			symbols_raw.push([i_a,i_b,i_c]);
			let label = "";
			if(i_a && i_a < first_symbol_string) first_symbol_string = i_a;
			for(let j = i_a + header_size; j < symbol_table_offset && file[j] != 0; j++) {
				label += String.fromCharCode(file[j]);
				if(j-header_size+2 > string_table_end) string_table_end = j-header_size+2;
			}
			symbols[i] = label;
			if(i_b) {
				defined_functions[i_b] = label;
				if(i_b > last_function) last_function = i_b;
			}
			endtext += "\"" + label + "\" " + i_b.toString(16) + " " + i_c.toString(16) + "\n";
		}
		let symbol_table_bytes = new ArrayBuffer(16 * (symbols_raw.length+1));
		let symbol_table_dv = new DataView(symbol_table_bytes);
		for(let i = 0; i < symbols_raw.length+1; i++) {
			let [i_a,i_b,i_c] = i == symbols_raw.length ? [first_symbol_string, 0, 0x20000] : symbols_raw[i];
			let type = (i_c & 0xFFFF0000) >>> 16;
			symbol_table_dv.setUint32(i*16 + 0, i_a - first_symbol_string, true); // st_name
			symbol_table_dv.setUint32(i*16 + 4, i_b, true); // st_value
			symbol_table_dv.setUint32(i*16 + 8, 0, true); // st_size
			if(i == 0) symbol_table_dv.setUint8(i*16 + 12, 0);
			else if(i == symbols_raw.length) symbol_table_dv.setUint8(i*16 + 12, 0x3);
			else symbol_table_dv.setUint8(i*16 + 12, 0x10); // st_info
			symbol_table_dv.setUint8(i*16 + 13, 0x0); // st_other
			symbol_table_dv.setUint16(i*16 + 14, (i == 0 || type == 2) ? 1 : 0, true); // st_shndx
		}
		
		let replacements = {};
		let replacement_table_offset = dv.getUint32(4 + header_size, true) + header_size;
		let replacement_table_count = dv.getUint32(8 + header_size, true);
		let relocations = [];
		endtext += "Relocations: \n";
		for(let i = 0; i < replacement_table_count; i++) {
			let i_offset = i * 12 + replacement_table_offset;
			let i_a = dv.getUint32(i_offset+0, true);
			let i_b = dv.getUint32(i_offset+4, true);
			let i_c = dv.getUint32(i_offset+8, true);
			let type_str = ["R_MIPS_NONE", "R_MIPS_16", "R_MIPS_32", "R_MIPS_REL32", "R_MIPS_26", "R_MIPS_HI16", "R_MIPS_LO16", "R_MIPS_GPREL16", "R_MIPS_LITERAL", "R_MIPS_GOT16", "R_MIPS_PC16", "R_MIPS_CALL16", "R_MIPS_GPREL32"][i_b & 255];
			endtext += i_a.toString(16) + " " + type_str + " " + symbols[i_b >> 8] + " " + i_c.toString(16) + "\n";
			replacements[i_a] = symbols[i_b >> 8];
			relocations.push([i_a, i_b]);
		}

		let bs_offset = dv.getUint32(0x34 + header_size, true) + header_size;
		let tag_addr = 0;
		if(bs_offset) {
			while(true) {
				let tag_byte = dv.getUint8(bs_offset);
				let tag = tag_byte & 3;
				if(!(tag_byte & 0xFC)) {
					tag_addr = dv.getUint32(bs_offset+1, true);
					bs_offset += 5;
					if(!tag_addr) break;
				} else {
					tag_addr += tag_byte & 0xFC;
					bs_offset += 1;
				}

				relocations.push([tag_addr, [6,5,4,2][tag]]);
				
				if(tag == 0) {
					let target_addr = dv.getUint16(tag_addr+header_size, true)
					endtext += tag_addr.toString(16) + " R_MIPS_LO16 " + target_addr.toString(16) + "\n";
					// FUN_002a3a20(tag_addr, 6, dv.getUint16(tag_addr+header_size, true));
				} if(tag == 1) {
					let lookahead_bs_offset = bs_offset;
					let lookahead_tag_addr = tag_addr;
					while(true) {
						let lookahead_tag_byte = dv.getUint8(lookahead_bs_offset);
						if((lookahead_tag_byte & 0xFC) == 0) {
							lookahead_tag_addr = dv.getUint32(lookahead_bs_offset+1, true);
							if(lookahead_tag_addr == 0) {
								throw new Error("Error code 10");
							}
							lookahead_bs_offset += 5;
						} else {
							lookahead_tag_addr += lookahead_tag_byte & 0xFC;
							lookahead_bs_offset += 1;
						}
						if(!(lookahead_tag_byte & 3)) break;
					}
					let target_addr = (0x10000 * dv.getUint16(tag_addr+header_size, true) + dv.getInt16(lookahead_tag_addr+header_size, true));
					datasymbol_addrs.add(target_addr);
					endtext += tag_addr.toString(16) + " R_MIPS_HI16 " + target_addr.toString(16) + "\n";
					// FUN_002a3a20(tag_addr, 5, 0x10000 * dv.getUint16(tag_addr+header_size, true) + dv.getUint16(lookahead_tag_addr+header_size, true));
				} else if(tag == 2) {
					let target_addr = (dv.getUint32(tag_addr+header_size, true) & 0x3ffffff) << 2;
					if(target_addr > last_function) last_function = target_addr;
					endtext += tag_addr.toString(16) + " R_MIPS_26 " + (target_addr).toString(16) + "\n";
					if(!defined_functions[target_addr]) defined_functions[target_addr] = "f_" + target_addr.toString(16);
					// FUN_002a3a20(tag_addr, 4, (dv.getUint32(tag_addr+header_size, true) & 0x3ffffff) << 2);
				} else if(tag == 3) {
					let target_addr = dv.getUint32(tag_addr+header_size, true);
					endtext += tag_addr.toString(16) + " R_MIPS_32 " + target_addr.toString(16) + "\n";
					// FUN_002a3a20(tag_addr, 2, dv.getUint32(tag_addr+header_size, true));
				}
			}
		}

		let rel_table = new ArrayBuffer(8 * relocations.length);
		let rel_table_dv = new DataView(rel_table);
		for(let i = 0; i < relocations.length; i++) {
			let [i_a,i_b] = relocations[i];
			if((i_b >>> 8) == 0) i_b = (symbols_raw.length << 8) | (i_b & 0xFF);
			rel_table_dv.setUint32(i*8 + 0, i_a, true);
			rel_table_dv.setUint32(i*8 + 4, i_b, true);
		}

		let code_end = first_symbol_string;
		for(let addr of datasymbol_addrs) {
			if(addr < code_end && addr > last_function) code_end = addr;
		}
		
		let branches = [];
		let branch_vis = [];
		for(let i = 0x100; i < code_end; i += 4) {
			branch_vis[i] = [];
			let val = dv.getUint32(i+header_size, true);
			if(val == 0) continue;
			let inst;
			for(let [mask, templates] of masks) {
				inst = templates.get(mask & val);
				if(inst) break;
			}
			if(!inst) continue;
			if(/{b}/g.test(inst.args)) {
				branches.push([i, (((val & 0xFFFF) << 16 >> 14) + i + 4)]);
			}/* else if(inst.name == "jal" && !replacements[i]) {
				let fun = ((val & 0x3FFFFFF) << 2);
				if(fun < file.length-header_size && i >= 0x100 && !defined_functions[fun]) {
					defined_functions[fun] = "f_" + fun.toString(16);
				}
			}*/
		}
		branches.sort((a,b) => {
			return Math.abs(a[1]-a[0]) - Math.abs(b[1]-b[0]);
		});
		do_log(branches);
		// Box drawing characters:
		// │─┌└
		let brwidth = 0;
		for(let [bra,brb] of branches) {
			if(branch_vis[brb] == undefined) continue;
			let brmin = Math.min(bra,brb);
			let brmax = Math.max(bra,brb);
			let found = false;
			let level = 0;
			if(!level) {
				while(!found) {
					level++;
					found = true;
					for(let i = brmin; i <= brmax; i += 4) {
						if('│┌└'.includes(branch_vis[i][level])) {
							found = false;
							break;
						}
					}
				}
			}
			for(let i = brmin; i <= brmax; i += 4) {
				let bv = branch_vis[i];
				while(bv.length <= level) bv.push(" ");
				brwidth = Math.max(brwidth, bv.length);
				if(i == brmin || i == brmax) {
					if(i == brmin) {
						bv[level] = "┌";
					} else if(i == brmax) {
						bv[level] = "└";
					}
					for(let i = 1; i < level; i++) {
						if(bv[i] == ' ' || bv[i] == '│')
							bv[i] = '─';
					}
					if(i == bra && bv[0] != '>') {
						bv[0] = '─';
					} else {
						bv[0] = '>';
					}
				} else if(bv[level] == ' ') {
					bv[level] = '│';
				}
			}
		}
		
		for(let i = 0x100; i < code_end; i += 4) {
			let val = dv.getUint32(i+header_size, true);
			if(defined_functions[i]) {
				text += defined_functions[i] + ":\n";
			}
			text += i.toString(16).padStart(6,0) + " " + val.toString(16).padStart(8,0) + " " + branch_vis[i].reverse().join("").padStart(brwidth, " ");
			let inst = null;
			if(val == 0) {
				inst = {name: "nop", args: ""};
			} else {
				for(let [mask, templates] of masks) {
					inst = templates.get(mask & val);
					if(inst) break;
				}
			}
			if(inst) {
				let args = inst.args;
				args = args.replace(/{imm}/g, "0x" + (val & 0xFFFF).toString(16));
				args = args.replace(/{j}/g, replacements[i] || ("0x" + ((val & 0x3FFFFFF) << 2).toString(16)));
				args = args.replace(/{r1}/g, mips_registers[((val >> 21) & 0x1F)]);
				args = args.replace(/{r2}/g, mips_registers[((val >> 16) & 0x1F)]);
				args = args.replace(/{r3}/g, mips_registers[((val >> 11) & 0x1F)]);
				args = args.replace(/{r4}/g, mips_registers[((val >> 6) & 0x1F)]);
				args = args.replace(/{i1}/g, ((val >> 21) & 0x1F));
				args = args.replace(/{i2}/g, ((val >> 16) & 0x1F));
				args = args.replace(/{i3}/g, ((val >> 11) & 0x1F));
				args = args.replace(/{i4}/g, ((val >> 6) & 0x1F));
				args = args.replace(/{fr1}/g, "f"+((val >> 21) & 0x1F).toString().padStart(2,0));
				args = args.replace(/{fr2}/g, "f"+((val >> 16) & 0x1F).toString().padStart(2,0));
				args = args.replace(/{fr3}/g, "f"+((val >> 11) & 0x1F).toString().padStart(2,0));
				args = args.replace(/{fr4}/g, "f"+((val >> 6) & 0x1F).toString().padStart(2,0));
				args = args.replace(/{b}/g, "0x" + (((val & 0xFFFF) << 16 >> 14) + i + 4).toString(16));
				text += inst.name + " " + args;
			}
			text += "\n";
		}
		text += "\n";
		datasymbol_addrs = [...datasymbol_addrs, first_symbol_string].sort((a,b)=>{return a-b;}).filter((item) => {return item >= code_end});
		for(let i = 0; i < datasymbol_addrs.length-1; i++) {
			let start = datasymbol_addrs[i];
			let end = datasymbol_addrs[i+1];
			text += "d_" + start.toString(16) + "\n";
			for(let i = start; i < end; i += 16) {
				let slice = file.slice(header_size+i, Math.min(header_size+i+16, header_size+end));
				let line = (i).toString(16).padStart(6,0) + " " + [...slice].map(item => {return item.toString(16).padStart(2,0);}).join(" ").padEnd(52) + [...slice].map((item)=>{return dos_chars[item]}).join("");
				line += "   ";
				for(let j = 0; j < 4; j++) {
					if(header_size+i+j*4+3 < file.length)
					line += dv.getFloat32(header_size + i + j*4, true).toPrecision(6).padStart(16, " ");
				}
				text += line + "\n";
			}
			text += "\n";
		}
		let save_button = document.createElement("input");
		save_button.type = "button";
		save_button.value = "Export to ELF";
		save_button.onclick = () => {
			let fn = prompt("Filename? (no extension");
			if(!fn) return;

			const shstr_str = "\0.rel\0.strtab\0.shstrtab\0.symtab\0";

			let parts = [];
			parts.push(new Uint8Array([
				0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x01, 0x00, 0x08, 0x00, 0x01, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00,
				0x06, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
			]));
			let data_off = parts[parts.length-1].length;
			parts.push(file.subarray(header_size, first_symbol_string+header_size));
			
			let rel_off = data_off + parts[parts.length-1].length;
			parts.push(new Uint8Array(rel_table));

			let str_off = rel_off + parts[parts.length-1].length;
			let string_table_len = string_table_end - first_symbol_string;
			string_table_len = (string_table_len + 3) & ~3;
			parts.push(file.subarray(first_symbol_string+header_size, first_symbol_string+string_table_len+header_size));

			let shstr_off = str_off + parts[parts.length-1].length;
			let shstr_len = (shstr_str.length + 3) & ~3;
			let shstr_arr = new Uint8Array(shstr_len);
			for(let i = 0; i < shstr_str.length; i++) shstr_arr[i] = shstr_str.charCodeAt(i);
			parts.push(shstr_arr);

			let sym_off = shstr_off + parts[parts.length-1].length;
			parts.push(new Uint8Array(symbol_table_bytes));

			let header_off = sym_off + parts[parts.length-1].length;
			let header_bytes = new Uint8Array(6 * 0x28);
			let header_dv = new DataView(header_bytes.buffer);
			for(let i = 0; i < 6; i++) {
				let o = i*0x28;
				header_dv.setUint32(o + 0x00, [0, 0, 1, 6, 14, 24][i], true); // sh_name
				header_dv.setUint32(o + 0x04, [0, 1, 9, 3, 3, 2][i], true); // sh_type
				header_dv.setUint32(o + 0x08, [0, 7, 0, 0, 0, 0][i], true); // sh_flags
				header_dv.setUint32(o + 0x0C, 0, true); // sh_addr
				header_dv.setUint32(o + 0x10, [0, data_off, rel_off, str_off, shstr_off, sym_off][i], true); // sh_offset
				header_dv.setUint32(o + 0x14, i == 0 ? 0 : parts[i].length, true); // sh_size
				header_dv.setUint32(o + 0x18, [0, 0, 5, 0, 0, 3][i], true); // sh_link
				header_dv.setUint32(o + 0x1C, [0, 0, 1, 0, 0, 1][i], true); // sh_info
				header_dv.setUint32(o + 0x20, [0, 0x40, 4, 1, 1, 4][i], true); // sh_addralign
				header_dv.setUint32(o + 0x24, [0, 0, 0x8, 0, 0, 0x10][i], true); // sh_entsize
			}
			parts.push(header_bytes);
			new DataView(parts[0].buffer).setUint32(0x20, header_off, true);
			saveAs(new Blob(parts), fn + ".o");
		}
		contentelem.appendChild(save_button);
		let pre = document.createElement("pre");
		pre.textContent = text + endtext;
		contentelem.appendChild(pre);
	} else if(!force_hex && file[3] == 0x1 && file[4] == 0xe8 && file[5] == 0x3) {
		contentelem.innerHTML = "";
		
		let total = dv.getUint16(12 + header_size, true);
		
		let pre = document.createElement("pre");
		let text = "Header:\n\n";
		text += "text start: " + dv.getUint32(8 + header_size, true).toString(16) + "\n";
		text += "entries: " + total.toString(16) + "\n";
		text += "dunno: " + dv.getUint16(14 + header_size, true).toString(16) + "\n\n";
		
		for(let i = 0; i < total; i++) {
			let ofs = 16 + header_size + (i * 12);
			let name_ptr = dv.getUint32(ofs, true);
			let content_ptr = dv.getUint32(ofs+4, true);
			let something = dv.getUint32(ofs+8, true);
			
			let name = "";
			for(let j = name_ptr+header_size; j < file.length; j++) {
				if(!file[j]) break;
				if(file[j] == 0x0A) {
					name += "\n";
				} else if(file[j] == 1) {
					let thing = [file[j+3], file[j+4]-2, file[j+2]-2];
					let amount = file[j+1]-2;
					j += 5;
					for(let k = 0; k < amount; k++) {
						let part = [];
						for(let l = 0; l < 4; l++) {
							let b = file[j];
							j++;
							if(b == 0xFD) {
								let b2 = file[j];
								if(b2 == 2) {
									part.push(0xFD);
								} else if(((b2 - 0x40) & 0xFF) < 0x21) {
									part.push((b2 - 0x40) & 0xFF);
								} else {
									part.push(0);
								}
								j++;
							} else {
								part.push(b);
							}
						}
							thing.push(part);
					}
					j--;
					name += JSON.stringify(thing);
				} else {
					name += dos_chars[file[j]];
				}
			}
			let content = "";
			for(let j = content_ptr+header_size; j < file.length; j++) {
				if(!file[j]) break;
				if(file[j] == 0x0A) {
					content += "\n";
				} else if(file[j] == 1) {
					let thing = [file[j+3], file[j+4]-2, file[j+2]-2];
					let amount = file[j+1]-2;
					j += 5;
					for(let k = 0; k < amount; k++) {
						let part = [];
						for(let l = 0; l < 4; l++) {
							let b = file[j];
							j++;
							if(b == 0xFD) {
								let b2 = file[j];
								if(b2 == 2) {
									part.push(0xFD);
								} else if(((b2 - 0x40) & 0xFF) < 0x21) {
									part.push((b2 - 0x40) & 0xFF);
								} else {
									part.push(0);
								}
								j++;
							} else {
								part.push(b);
							}
						}
							thing.push(part);
					}
					j--;
					content += JSON.stringify(thing);
				} else {
					content += dos_chars[file[j]];
				}
			}
			text += `0x${i.toString(16)} (${i}) (name ptr: ${name_ptr.toString(16)} content ptr:  ${content_ptr.toString(16)})\nsomething: ${something.toString(16)}\n${name}\n${content}\n\n`;
		}
		pre.textContent = text;
		contentelem.appendChild(pre);
	} else if(!force_hex && file[3] == 0x1 && file[4] == 0x10 && file[5] == 0x0) {
		contentelem.innerHTML = "";
		let pre = document.createElement("pre");
		contentelem.appendChild(pre);
		let text = "";
		let num_part1s = dv.getInt32(header_size, true);
		let part1s_ptr = dv.getInt32(header_size+4, true);
		let type_coords_obj = {}
		for(let i = 0; i < num_part1s; i++) {
			let type = dv.getInt32(part1s_ptr + 0x18, true);
			let coords_list = type_coords_obj[type];
			if(!coords_list) type_coords_obj[type] = coords_list = [];
			text += `\nItem ${i} (Type ${type}, 0x${type.toString(16)}):\n`;
			text += `\t${dv.getFloat32(part1s_ptr+0, true)}\n`;
			text += `\t${dv.getFloat32(part1s_ptr+4, true)}\n`;
			text += `\t${dv.getFloat32(part1s_ptr+8, true)}\n`;
			text += `\t${dv.getFloat32(part1s_ptr+12, true)}\n`;
			text += `\t${dv.getFloat32(part1s_ptr+28, true)}\n`;
			let num_part2s = dv.getInt32(part1s_ptr+16, true);
			let part2s_ptr = dv.getInt32(part1s_ptr+20, true);
			for(let j = 0; j < num_part2s; j++) {
				text += `\tItem2 ${j} (${dv.getFloat32(part2s_ptr+4, true)}):\n`;
				let num_part3s = dv.getInt32(part2s_ptr, true);
				let part3s_ptr = dv.getInt32(part2s_ptr+16, true);
				for(let k = 0; k < num_part3s; k++) {
					text += `\t\tItem3 ${k} (${dv.getFloat32(part3s_ptr, true)})\n`;
					let tree_x = dv.getFloat32(part1s_ptr+0, true) + dv.getFloat32(part3s_ptr, true);
					let tree_y = dv.getFloat32(part1s_ptr+8, true) + dv.getFloat32(part2s_ptr+4, true);
					text += `\t\t\t(${tree_x.toFixed(3)}ft, ${tree_y.toFixed(3)}ft)\n`;
					text += `\t\t\t(${(tree_x*0.3048).toFixed(3)}m, ${(tree_y*0.3048).toFixed(3)}m)\n`;
					coords_list.push({
						name: `obj${type.toString(16)}_${i}_${j}_${k}`,
						x_ft: tree_x,
						y_ft: tree_y,
						x_m: tree_x*0.3048,
						y_m: tree_y*0.3048,
					});
					part3s_ptr += 0x10;
				}
				part2s_ptr += 0x14;
			}
			part1s_ptr += 0x40;
		}
		for(let list of Object.values(type_coords_obj)) {
			text += "\n";
			for(let obj of list) {
				text += `${obj.name},${obj.x_ft},${obj.y_ft},${obj.x_m},${obj.y_m}\n`
			}
		}
		pre.textContent = text;
	} else if(!force_hex && file[4] == 0x12 && file[5] == 0x0 && !(file[header_size] == 0x49 && file[header_size+1] == 0x44 && file[header_size+2] == 0x4d)) {
		contentelem.innerHTML = "";
		let num_bones = dv.getUint16(0x38 + header_size, true);
		let bones_base = dv.getUint32(0x20 + header_size, true) + header_size;
		let text = "";
		let script = "";
		script += `import bpy
armature = bpy.data.armatures.new("Armature")
obj = bpy.data.objects.new("Armature", armature)
scn = bpy.context.scene
scn.collection.objects.link(obj)
bpy.context.view_layer.objects.active = obj
obj.select_set(True)
bpy.ops.object.mode_set(mode='EDIT')
`;
		let script_linker = ``;
		let script_linker_2 = ``;
		for(let i = 0; i < num_bones; i++) {
			let bone_base = bones_base + i*0x50;
			let bone_x = dv.getFloat32(bone_base+0x20, true);
			let bone_y = dv.getFloat32(bone_base+0x24, true);
			let bone_z = dv.getFloat32(bone_base+0x28, true);
			let a_x = dv.getFloat32(bone_base+0x10, true);
			let a_y = dv.getFloat32(bone_base+0x14, true);
			let a_z = dv.getFloat32(bone_base+0x18, true);
			let b_x = dv.getFloat32(bone_base+0x30, true);
			let b_y = dv.getFloat32(bone_base+0x34, true);
			let b_z = dv.getFloat32(bone_base+0x38, true);

			let ref_a = dv.getUint16(bone_base+0, true);
			let ref_b = dv.getUint16(bone_base+2, true);
			let ref_c = dv.getUint16(bone_base+4, true);
			let ref_d = dv.getUint16(bone_base+6, true);
			let ref_e = dv.getInt32(bone_base+8, true);
			ref_e = (ref_e == -1 ? null : ref_e / 0x50);
			let ref_f = dv.getInt32(bone_base+12, true);
			ref_f = (ref_f == -1 ? null : ref_f / 0x50);
			text += "bone_" + i + ":\n";
			text += "  " + bone_x + ", " + bone_y + ", " + bone_z + "\n";
			text += "  a pos: " + a_x + ", " + a_y + ", " + a_z + "\n";
			text += "  b pos: " + b_x + ", " + b_y + ", " + b_z + "\n";
			
			text += "  self ref: " + "bone_" + ref_a + "\n";
			text += "  b: " + "bone_" + ref_b + "\n";
			text += "  c: " + "bone_" + ref_c + "\n";
			text += "  mirror ref: " + "bone_" + ref_d + "\n";
			text += "  parent: " + (ref_e != null ? ("bone_" + ref_e) : "null") + "\n";
			text += "  primary child: " + (ref_f != null ? ("bone_" + ref_f) : "null") + "\n";
			text += "\n";
			script += `
bone_${i} = armature.edit_bones.new('bone_${i}')
bone_${i}.head = (${bone_x}, ${-bone_z}, ${bone_y})
bone_${i}.tail = (${bone_x+a_x}, ${-bone_z-a_z}, ${bone_y+a_y})
`;
			script_linker += `
bone_${i}.parent = ${ref_e != null ? "bone_" + ref_e : "None"}`;
			if(ref_f != null) {
				script_linker_2 += `
bone_${i}.tail = bone_${ref_f}.head.copy()
bone_${ref_f}.use_connect = True
`;
			}
		}

		let save_button = document.createElement("input");
		save_button.type = "button";
		save_button.value = "Save as .py (Blender)";
		save_button.addEventListener("click", () => {
			let filename = prompt("filename? (no extension)");
			saveAs(new Blob([script, script_linker, script_linker_2], {type:"application/x-python-code"}), filename + ".py");
		});
		contentelem.appendChild(save_button);
		
		let pre = document.createElement("pre");
		pre.textContent = text;
		contentelem.appendChild(pre);
	} else {
		contentelem.innerHTML = "";
		let save_button = document.createElement("input");
		save_button.type = "button";
		save_button.value = "Save";
		save_button.addEventListener("click", () => {
			let filename = prompt("filename?");
			if(filename) saveAs(blob.slice(header_size), filename);
		});
		contentelem.appendChild(save_button);
		let pre = document.createElement("pre");
		let text = "HEADER:\n";
		for(let i = 0; i < header_size; i += 16) {
			let slice = file.slice(i, Math.min(i+16, header_size));
			let line = i.toString(16).padStart(6,0) + " " + [...slice].map(item => {return item.toString(16).padStart(2,0);}).join(" ").padEnd(52) + [...slice].map((item)=>{return dos_chars[item]}).join("");
			text += line + "\n";
		}
		text += "\nBODY:\n";
		for(let i = header_size; i < file.length; i += 16) {
			let slice = file.slice(i, Math.min(i+16, file.length));
			let line = (i-header_size).toString(16).padStart(6,0) + " " + [...slice].map(item => {return item.toString(16).padStart(2,0);}).join(" ").padEnd(52) + [...slice].map((item)=>{return dos_chars[item]}).join("");
			line += "   ";
			for(let j = 0; j < 4; j++) {
				if(i+j*4+3 < file.length)
				line += dv.getFloat32(i + j*4, true).toPrecision(6).padStart(16, " ");
			}
			text += line + "\n";
		}
		pre.textContent = text;
		contentelem.appendChild(pre);
	}
}

let PIXEL_STORAGE_FORMATS = [
	"PSMCT32", "PSMCT42", "PSMCT16",  null,      null,      null, null, null,
	null,      null,      "PSMCT16S", null,      null,      null, null, null,
	null,      null,      null,       "PSMT8",   "PSMT4",   null, null, null,
	null,      null,      null,       "PSMT8H",  null,      null, null, null,
	null,      null,      null,       null,      "PSMT4HL", null, null, null,
	null,      null,      null,       null,      "PSMT4HH", null, null, null,
	"PSMZ32",  "PSMZ24",  "PSMZ16",   "PSMZ16S", null,      null, null, null,
];
let CLUT_PIXEL_STORAGE_FORMATS = [
	"PSMCT32", null, "PSMCT16", null, null, null, null, null,
	null,      null, "PSMCT16S"
]
let TEXTURE_FILTERING_TYPES = [
	"NEAREST",
	"LINEAR",
	"NEAREST_MIPMAP_NEAREST",
	"NEAREST_MIPMAP_LINEAR",
	"LINEAR_MIPMAP_NEAREST",
	"LINEAR_MIPMAP_LINEAR"
];
let CLAMP_TYPES = ["REPEAT", "CLAMP", "REGION_CLAMP", "REGION_REPEAT"];

async function extract_materials(blob, parent) {
	let file = new Uint8Array(await new Response(blob).arrayBuffer());
	let dv = new DataView(file.buffer);
	let header_size = dv.getInt16(6, true) + 16;
	let texture_files = [];
	let this_indent = -1;
	for(let otherfile of parent) {
		if(this_indent != -1) {
			if(otherfile.indent < this_indent)
				break;
			if(otherfile.indent == this_indent && otherfile.ident[0] == 0x1 && otherfile.ident[1] == 0x0 && otherfile.ident[2] == 0x0)
				break;
			if(otherfile.indent == this_indent && otherfile.ident[0] == 0x4 && otherfile.ident[1] == 0x4 && otherfile.ident[2] == 0x0) {
				texture_files.push(otherfile.blob);
			}
		} else if(otherfile.blob == blob) {
			this_indent = otherfile.indent;;
		}
	}
	let textures = [];
	for(let tex_file of texture_files) {
		textures.push(new ImageDecoder(new Uint8Array(await new Response(tex_file).arrayBuffer())));
	}
	let mat_list_offset = dv.getUint32(header_size + 0x10, true) + header_size;
	let num_materials = dv.getUint32(header_size + 0x14, true);
	let materials = [];
	for(let i = 0; i < num_materials; i++) {
		let mat_offset = mat_list_offset + (0x270 * i);
		let tex_file_index = file[mat_offset + 0x28];
		let mat_str = "Material " + i + "\n";
		let mat_obj = {
			contexts: [{
				scroll_x: dv.getFloat32(mat_offset + 0x70, true),
				scroll_y: dv.getFloat32(mat_offset + 0x74, true),
			}, {
				scroll_x: dv.getFloat32(mat_offset + 0x60, true),
				scroll_y: dv.getFloat32(mat_offset + 0x64, true),
			}]
		};
		let canvas = null;
		let has_transparency = false;
		
		let num_registers = file[mat_offset + 0x1A0];
		
		for(let j = 0; j < num_registers; j++) {
			let register_addr = file[mat_offset + 0x1B8 + j*16]; // should probably actually parse the GIFtag but I don't think there's any other kinds of giftags
			let context = mat_obj.contexts[register_addr & 1];
			let register_val = dv.getBigUint64(mat_offset + 0x1B0 + j*16, true);
			switch(register_addr & 0xFE) {
			case 0x06:
				context.tex0 = {
					tbp0: Number(register_val & 0x3FFFn),
					tbw: Number((register_val >> 14n) & 0x3Fn),
					psm: PIXEL_STORAGE_FORMATS[(register_val >> 20n) & 0x3Fn],
					tw: Number((register_val >> 26n) & 0xFn),
					th: Number((register_val >> 30n) & 0xFn),
					tcc: Number((register_val >> 34n) & 0x1n),
					tfx: ["MODULATE", "DECAL", "HIGHLIGHT", "HIGHLIGHT2"][(register_val >> 35n) & 0x3n],
					cbp: Number((register_val >> 37n) & 0x3FFFn),
					cpsm: CLUT_PIXEL_STORAGE_FORMATS[(register_val >> 51n) & 0xFn],
					csm: ["CSM1","CSM2"][(register_val >> 55n) & 0x1n],
					csa: Number((register_val >> 56n) & 0x1Fn),
					cld: Number((register_val >> 61n) & 0x7n)
				};
				break;
			case 0x08:
				context.clamp = {
					wms: CLAMP_TYPES[(register_val) & 0x3n],
					wmt: CLAMP_TYPES[(register_val >> 2n) & 0x3n],
					minu: Number((register_val >> 4n) & 0x3FFn),
					maxu: Number((register_val >> 14n) & 0x3FFn),
					minv: Number((register_val >> 24n) & 0x3FFn),
					maxv: Number((register_val >> 34n) & 0x3FFn),
				};
				break;
			case 0x14:
				context.tex1 = {
					lcm: Number(register_val & 0x1n),
					mxl: Number((register_val >> 2n) & 0x7n),
					mmag: TEXTURE_FILTERING_TYPES[(register_val >> 5n) & 0x1n],
					mmin: TEXTURE_FILTERING_TYPES[(register_val >> 6n) & 0x7n],
					mtba: Number((register_val >> 9n) & 0x1n),
					l: Number((register_val >> 19n) & 0x1n),
					k: (Number((register_val >> 32n) & 0xFFFn) << 20 >> 20) / 16,
				}
				break;
			case 0x34:
				context.miptbp1 = {
					tbp1: Number(register_val & 0x3FFFn),
					tbw1: Number((register_val << 14n) & 0x3Fn),
					tbp2: Number((register_val << 20n) & 0x3FFFn),
					tbw2: Number((register_val << 34n) & 0x3Fn),
					tbp3: Number((register_val << 40n) & 0x3FFFn),
					tbw3: Number((register_val << 54n) & 0x3Fn),
				}
				break;
			case 0x42:
				context.alpha = {
					a: ["Cs", "Cd", "0"][register_val & 0x3n],
					b: ["Cs", "Cd", "0"][(register_val >> 2n) & 0x3n],
					c: ["As", "Ad", "FIX"][(register_val >> 4n) & 0x3n],
					d: ["Cs", "Cd", "0"][(register_val >> 6n) & 0x3n],
					fix: Number((register_val >> 32n) & 0xFFn) / 0x80,
				};
				break;
			case 0x48:
			case 0x47:
				context = mat_obj.contexts[1 - (register_addr & 1)];
			default:
				context["unk_" + register_addr.toString(16)] = register_val.toString(16);
			}
		}
		
		for(let j = 0; j < 2; j++) {
			let context = mat_obj.contexts[j];
			mat_str += "\nContext " + (j+1) + ":\n";
			for(let [regname, reg] of Object.entries(context)) {
				mat_str += " " + regname + ": " + JSON.stringify(reg) + "\n";
			}
		}
		
		if(tex_file_index == 0xff) {
			mat_str += "\nNO TEXTURE\n\n";
		} else {
			mat_str += "\nTEXTURE (file " + tex_file_index + ")\n";
			let tex_descriptor = file.slice(mat_offset + 0x1B0, mat_offset+0x1B8);
			
			mat_obj.tbp0 = tex_descriptor[0] | ((tex_descriptor[1] & 0x3f) << 8);
			mat_obj.tbw = (tex_descriptor[1] >> 6) | ((tex_descriptor[2] & 0xf) << 2);
			mat_obj.psm = PIXEL_STORAGE_FORMATS[(tex_descriptor[2] >> 4) | ((tex_descriptor[3] & 0x3) << 4)];
			mat_obj.tw = (tex_descriptor[3] >> 2) & 0xf;
			mat_obj.th = (tex_descriptor[3] >> 6) | ((tex_descriptor[4] & 0x3) << 2);
			mat_obj.tcc = (tex_descriptor[4] >> 2) & 0x1;
			mat_obj.tfx = ["MODULATE", "DECAL", "HIGHLIGHT", "HIGHLIGHT2"][(tex_descriptor[4] >> 3) & 0x3];
			mat_obj.cbp = (tex_descriptor[4] >> 5) | (tex_descriptor[5] << 3) | ((tex_descriptor[6] & 0x7) << 11);
			mat_obj.cpsm = CLUT_PIXEL_STORAGE_FORMATS[(tex_descriptor[6] >> 3) & 0xF];
			mat_obj.csm = ["CSM1","CSM2"][tex_descriptor[6] >> 7];
			mat_obj.csa = tex_descriptor[7] & 0x1F;
			mat_obj.cld = tex_descriptor[7] >> 5;
			
			mat_str += [...tex_descriptor].map(item => {return item.toString(16).padStart(2,0);}).join(" ") + "\n";
			let decoder = textures[tex_file_index];
			let mat_width = 1 << mat_obj.tw;
			let mat_height = 1 << mat_obj.th;
			let size_byte = tex_descriptor[3];
			mat_str += mat_width + "x" + mat_height + "\n";
			if(mat_width == undefined) mat_width = 256;
			if(mat_height == undefined)mat_height = 256;
			let in_x = 0;
			let in_y = 0;
			let pal_x = 0;
			let pal_y = 0;
			let is_4bit = (tex_descriptor[2] & 0xF0) == 0x40;
			if(tex_descriptor[0] & 0x40) in_x += 256;
			if(tex_descriptor[0] & 0x20) in_x += 128;
			if(tex_descriptor[0] & 0x10) in_x += 64;
			if(tex_descriptor[0] & 0x04) in_x += 32;
			if(tex_descriptor[0] & 0x01) in_x += 16;
			
			if(tex_descriptor[1] & 0x02) in_x += 2048;
			if(tex_descriptor[1] & 0x01) in_x += 1024;
			if(tex_descriptor[0] & 0x80) in_x += 512;
			if(tex_descriptor[0] & 0x08) in_y += 32;
			if(tex_descriptor[0] & 0x02) in_y += 16;
			
			if(tex_descriptor[5] & 0x08) pal_x += 256;
			if(tex_descriptor[5] & 0x04) pal_x += 128;
			if(tex_descriptor[5] & 0x02) pal_x += 64;
			if(tex_descriptor[4] & 0x80) pal_x += 32;
			if(tex_descriptor[4] & 0x20) pal_x += 16;
			
			if(tex_descriptor[5] & 0x40) pal_x += 2048;
			if(tex_descriptor[5] & 0x20) pal_x += 1024;
			if(tex_descriptor[5] & 0x10) pal_x += 512;
			if(tex_descriptor[5] & 0x01) pal_y += 32;
			if(tex_descriptor[4] & 0x40) pal_y += 16;
			in_y += Math.floor(in_x / decoder.img_width) * 64;
			in_x = in_x % decoder.img_width;
			if(is_4bit) {
				let pos_index = decoder.deswizzle_map_4bit[decoder.swizzle_map[in_y*decoder.img_width+in_x] << 1];
				in_y = Math.round(pos_index / decoder.img_width_4bit / 16) * 16;
				in_x = Math.round((pos_index % decoder.img_width_4bit) / 16) * 16;
			}
			pal_y += Math.floor(pal_x / decoder.img_width) * 64;
			pal_x = pal_x % decoder.img_width;
			mat_str += "img: ("+in_x+","+in_y+")\n";
			mat_str += "pal: ("+pal_x+","+pal_y+")\n";
			if(mat_width && mat_height) {
				canvas = document.createElement('canvas');
				if(mat_width < 256 && mat_height < 256) {
					if(mat_width < mat_height)
						canvas.style.height = "256px";
					else
						canvas.style.width = "256px";
				}
				canvas.width = mat_width;
				canvas.height = mat_height;
				has_transparency = decoder.decode(is_4bit, pal_x*2+pal_y*decoder.img_width, in_x, in_y, canvas);
			}
		}
		Object.assign(mat_obj, {string: mat_str, canvas, has_transparency});
		materials.push(mat_obj);
	}
	return materials
}

class ImageDecoder {
	constructor(file) {
		let dv = new DataView(file.buffer);
		let header_size = dv.getInt16(6, true) + 16;
		
		// build the swizzle tables
		let img_data_start = dv.getInt32(header_size + 4, true) + header_size;
		let props_start = dv.getInt32(header_size+8, true)+header_size;
		this.img_width = dv.getInt32(props_start+64, true) * 2; // the width/height is based on what it would be if this was a 32-bit texture
		this.img_height = dv.getInt32(props_start+68, true) * 2;// however this game doesnt use 32-bit textures so yeah.
		this.img_width_4bit = this.img_width;
		this.img_height_4bit = this.img_height * 2;
		this.img_data = file.subarray(img_data_start, img_data_start+this.img_width*this.img_height);
		
		this.swizzle_map = new Uint32Array(this.img_width*this.img_height);
		this.deswizzle_map = new Uint32Array(this.img_width*this.img_height);
		let swizzled_byte = 0;
		
		const xoffs1_4bit = [0, 1, 2, 3, 4, 5, 6, 7, 1, 0, 3, 2, 5, 4, 7, 6];
		const xoffs2_4bit = [1, 0, 3, 2, 5, 4, 7, 6, 0, 1, 2, 3, 4, 5, 6, 7];
		const xoffs1 = [0, 1, 2, 3, 1, 0, 3, 2];
		const xoffs2 = [1, 0, 3, 2, 0, 1, 2, 3];
		for(let row4 = 0; row4 < this.img_height; row4 += 4) { // de-swizzle the image.
			for(let oddness = 0; oddness < 2; oddness++) {
				for(let block = 0; block < this.img_width; block += 16) {
					for(let blockhalf = 0; blockhalf < 2; blockhalf++) {
						for(let blockcol = 0; blockcol < 4; blockcol++) {
							for(let blocksect = 0; blocksect < 4; blocksect++) {
								let xoffs = (Math.floor(row4/4) % 2) != 0 ? xoffs2 : xoffs1;
								let x = block + xoffs[blocksect + (blockhalf*4)]*4 + blockcol;
								let y = row4 + oddness + ((blocksect % 2)*2);
								this.swizzle_map[y*this.img_width+x] = swizzled_byte;
								this.deswizzle_map[swizzled_byte] = y*this.img_width+x;
								swizzled_byte++;
							}
						}
					}
				}
			}
		}
		this.swizzle_map_4bit = new Uint32Array(this.img_width_4bit*this.img_height_4bit);
		this.deswizzle_map_4bit = new Uint32Array(this.img_width_4bit*this.img_height_4bit);
		swizzled_byte = 0;
		// if highly nested arrays give you PTSD look away.
		for(let row512 = 0; row512 < this.img_height_4bit; row512 += 128) {
			for(let block = 0; block < 128; block += 32) {
				for(let row4 = 0; row4 < 4; row4++) {
					for(let oddness = 0; oddness < 2; oddness++) {
						for(let col128 = 0; col128 < this.img_width_4bit; col128 += 128) {
							for(let row16 = 0; row16 < 8; row16 += 1) {
								for(let blockhalf = 0; blockhalf < 2; blockhalf++) {
									for(let blockcol = 0; blockcol < 4; blockcol++) {
										for(let blocksect = 0; blocksect < 8; blocksect++) {
											let xoffs = (row4 % 2) != 0 ? xoffs1_4bit : xoffs2_4bit;
											let x = col128 + block + xoffs[blocksect + (blockhalf*8)]*4 + blockcol;
											let y = row512 + row16*16 + row4*4 + oddness + ((1-(blocksect % 2))*2);
											this.swizzle_map_4bit[y*this.img_width_4bit+x] = swizzled_byte;
											this.deswizzle_map_4bit[swizzled_byte] = y*this.img_width_4bit+x;
											swizzled_byte++;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		// theoretically the image format supports 32-bit textures as well but they're never used anywhere so I'm just gonna not implement that.
	}
	
	decode(is_4bit, palette_offset, x_in, y_in, canvas, x_out = 0, y_out = 0, width_out = canvas.width, height_out = canvas.height) {
		let ctx = canvas.getContext('2d');
		let img_data = ctx.getImageData(x_out, y_out, width_out, height_out);
		let palette;
		if(palette_offset != undefined) {
			let pre_palette = new Uint8Array(1024);
			let curr_img_byte = palette_offset;
			for(let i = 0; i < 16; i++) {
				pre_palette.set(this.img_data.slice(curr_img_byte, curr_img_byte + 64), i * 64);
				curr_img_byte += this.img_width*2; // width gets multiplied by two because S W I Z Z L I N G (tm)
			}
			palette = new Uint8Array(1024);
			for(let i = 0; i < 256; i++) {
				// The palette is swizzled in such a way that the same code can be used to decode both 4-bit palettes and 8-bit palettes
				let dblock = Math.floor(i / 32);
				let block = Math.floor(i / 16)%2;
				let chunk = Math.floor(i / 8)%2;
				let subindex = i % 8;
				
				let index = (dblock*32)+(((chunk*2)%8+block)*8)+subindex;
				
				palette[index*4+0] = pre_palette[i*4+0];
				palette[index*4+1] = pre_palette[i*4+1];
				palette[index*4+2] = pre_palette[i*4+2];
				palette[index*4+3] = Math.floor(pre_palette[i*4+3]*255/128);
				
			}
		} else {
			palette = new Uint8Array(1024);
			if(is_4bit) {
				for(let i = 0; i < 16; i++) {
					palette[i*4+0] = i*17;
					palette[i*4+1] = i*17;
					palette[i*4+2] = i*17;
					palette[i*4+3] = 255;
				}
			} else {
				for(let i = 0; i < 256; i++) {
					palette[i*4+0] = i;
					palette[i*4+1] = i;
					palette[i*4+2] = i;
					palette[i*4+3] = 255;
				}
			}
		}
		let has_transparency = false;
		for(let y = y_in; y < y_in+height_out; y++) {
			for(let x = x_in; x < x_in+width_out; x++) {
				let palette_index = 0;
				if(is_4bit) {
					let offset = this.swizzle_map_4bit[y * this.img_width_4bit + x];
					palette_index = (offset & 1) ? (this.img_data[offset>>1] & 0x0F) : ((this.img_data[offset>>1] & 0xF0) >> 4);
				} else {
					palette_index = this.img_data[this.swizzle_map[y * this.img_width + x]];
				}
				palette_index = palette_index || 0;
				let img_data_offset = ((y-y_in) * width_out + (x-x_in))*4;
				img_data.data[img_data_offset+0] = palette[palette_index*4+0];
				img_data.data[img_data_offset+1] = palette[palette_index*4+1];
				img_data.data[img_data_offset+2] = palette[palette_index*4+2];
				img_data.data[img_data_offset+3] = palette[palette_index*4+3];
				if(palette[palette_index*4+3] < 255)
					has_transparency = true;
			}
		}
		ctx.putImageData(img_data, x_out, y_out);
		return has_transparency;
	}
}

function decode_adpcm(data, start_offset, end_offset, sample_rate = 22050) {
	const ADPCM_COEFFICIENTS = [
		[0,0],
		[60,0],
		[115,-52],
		[98,-55],
		[122,-60]
	];
	let loop_start = 0;
	let loop = false;
	// first lets figure out where the end point is.
	for(let i = start_offset; i < end_offset; i += 16) {
		if((data[i+1]) & 2) {
			loop = true;
			if((data[i+1]) & 4) {
				loop_start = ((i - start_offset) / 16 * 28) / sample_rate;
			}
		}
		if((data[i+1] & 1) || !((data[i+16] >> 4) <= 4)) {
			end_offset = i + 16;
			break;
		}
	}
	// yeeted from here https://bitbucket.org/rerwarwar/gamestuff/src/default/JAD/vag.c
	let buffer = new AudioBuffer({length: (end_offset-start_offset) * 28 / 16, numberOfChannels: 1, sampleRate: sample_rate});
	let float_buffer = buffer.getChannelData(0);
	let p0 = 0;
	let p1 = 0;
	for(let i = start_offset; i < end_offset; i += 16) {
		let shift = data[i] & 0xf;
		let index = data[i] >> 4;
		let flags = data[i+1];
		let c0 = ADPCM_COEFFICIENTS[index][0];
		let c1 = ADPCM_COEFFICIENTS[index][1];
		for(let j = 0; j < 28; j++) {
			let b = (j & 1) ? (data[i+2+(j>>1)] >> 4) : (data[i+2+(j>>1)] & 0xF);
			if(b > 7) b -= 16; // sign-extend the nibble
			let error = (b << 18) >> shift;
			let predicted = p0 * c0 + p1 * c1;
			p1 = p0;
			p0 = (error + predicted) >> 6
			float_buffer[((i-start_offset) >> 4) * 28 + j] = p0 / 32768;
		}
	}
	return {
		buffer,
		loop,
		loop_start,
		loop_end: buffer.duration
	};
}

function get_map_color_float(index) {
	let base_color = [[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1]][(index % 6)];
	let page = Math.floor(index / 6) + 1;
	let page_bits = page.toString(2).length;
	let divisor = 2**(page_bits-1);
	let offset = (page & (2**(page_bits - 1)-1)) / divisor;
	return base_color.map(i => {return i / divisor + offset;});
}
function get_map_color(index) {
	return get_map_color_float(index).map(i => {return Math.round(i * 255);});
}


// this is basically a JS translation of some assembly code.
// a0/a1: bytes 2/3 of region, a2: note number, a3: pitch shift
function handle_midi_pitch(a0, a1, a2, a3 = 0) {
	let v0, v1, t0, t1, t2, s0;
	// some look up tables
	// if you really want to graph them go ahead but they're probably lookups for exponents and shizz.
	const table1 = [0x8000, 0x879C, 0x8FAC, 0x9837, 0xA145, 0xAADC, 0xB504, 0xBFC8, 0xCB2F, 0xD744, 0xE411, 0xF1A1];
	const table2 = [0x8000, 0x800E, 0x801D, 0x802C, 0x803B, 0x804A, 0x8058, 0x8067, 0x8076, 0x8085, 0x8094, 0x80A3, 0x80B1, 0x80C0, 0x80CF, 0x80DE, 0x80ED, 0x80FC, 0x810B, 0x811A, 0x8129, 0x8138, 0x8146, 0x8155, 0x8164, 0x8173, 0x8182, 0x8191, 0x81A0, 0x81AF, 0x81BE, 0x81CD, 0x81DC, 0x81EB, 0x81FA, 0x8209, 0x8218, 0x8227, 0x8236, 0x8245, 0x8254, 0x8263, 0x8272, 0x8282, 0x8291, 0x82A0, 0x82AF, 0x82BE, 0x82CD, 0x82DC, 0x82EB, 0x82FA, 0x830A, 0x8319, 0x8328, 0x8337, 0x8346, 0x8355, 0x8364, 0x8374, 0x8383, 0x8392, 0x83A1, 0x83B0, 0x83C0, 0x83CF, 0x83DE, 0x83ED, 0x83FD, 0x840C, 0x841B, 0x842A, 0x843A, 0x8449, 0x8458, 0x8468, 0x8477, 0x8486, 0x8495, 0x84A5, 0x84B4, 0x84C3, 0x84D3, 0x84E2, 0x84F1, 0x8501, 0x8510, 0x8520, 0x852F, 0x853E, 0x854E, 0x855D, 0x856D, 0x857C, 0x858B, 0x859B, 0x85AA, 0x85BA, 0x85C9, 0x85D9, 0x85E8, 0x85F8, 0x8607, 0x8617, 0x8626, 0x8636, 0x8645, 0x8655, 0x8664, 0x8674, 0x8683, 0x8693, 0x86A2, 0x86B2, 0x86C1, 0x86D1, 0x86E0, 0x86F0, 0x8700, 0x870F, 0x871F, 0x872E, 0x873E, 0x874E, 0x875D, 0x876D, 0x877D];
	
	a0 <<= 0x18;
	v0 = a0 >> 0x18;
	a1 <<= 0x18;
	a1 >>= 0x18;
	a2 &= 0xFFFF;
	a3 <<= 0x10;
	a3 >>= 0x10;
	if(v0 < 0) {
		s0 = 0;
		v0 = -v0;
		v0 <<= 0x18;
		v0 >>= 0x18;
	} else {
		s0 = 0x1;
	}
	a0 = v0 & 0xFFFF;
	a1 &= 0xFFFF;
	
	// START OF SOME FUNCTION (which I'm inlining here)
	t0 = a0;
	a3 = a3 << 0x10;
	a3 = a3 >> 0x10;
	a1 &= 0xFFFF;
	a3 += a1;
	if(a3 < 0) {
		v1 = a3 + 0x7F;
	} else {
		v1 = a3;
	}
	a0 = 0x2AAAAAAB;
	v1 >>= 0x7;
	v0 = a2 + v1;
	v0 -= t0;
	v0 <<= 0x10;
	a1 = v0 >> 0x10;
	t1 = Math.floor(a1 * (a0/0x100000000)); // not exactly but meh
	a2 = v1;
	v1 = a2 << 0x7;
	a3 -= v1;
	v0 >>= 0x1F;
	v1 = t1 >> 0x1
	v1 -= v0;
	t0 = v1 - 0x2;
	v0 = v1 << 0x1;
	v0 += v1;
	v0 <<= 0x2;
	a1 -= v0;
	v0 = a1 << 0x10;
	v0 >>= 0x10;
	a0 = a1;
	if(v0 < 0) {
		a0 = a1 + 0xC;
		t0 = v1 - 0x3;
		v0 = a0 << 0x10;
		
	} else if(v0 != 0) {
		v0 = a0 << 0x10;
	} else {
		v0 = a0 << 0x10;
		if(a3 < 0) {
			a0 = a1 + 0xC;
			t0 = v1 - 0x3;
			v0 = a0 << 0x10;
		}
	}
	if(a3 < 0) {
		v0 = a0 - 0x1;
		a0 = v0 + a2;
		v0 = a2 + 0x1;
		v0 <<= 0x7;
		a3 += v0;
		v0 = a0 << 0x10;
	}
	v0 >>= 0xF;
	v1 = a3 << 0x1;
	a0 = table1[v0 >> 0x1];
	v0 = table2[v1 >> 0x1];
	t1 = (a0 * v0) & 0xFFFFFFFF;
	v0 = t0 << 0x10;
	v0 >>= 0x10;
	a1 = t1 >> 0x10;
	if(v0 < 0) {
		a0 = -v0;
		v1 = a0 - 0x1;
		v0 = 0x1;
		v0 <<= v1;
		a1 += v0;
		a1 >>>= a0; // this one's a logical shift so three >'s
	}
	v0 = a1 & 0xFFFF;
	// END OF SOME FUNCTION
	if(s0 != 0) {
		a0 = 0x57619F1;
		v1 = v0 << 0x1;
		v1 += v0;
		v1 <<= 0x2;
		v1 -= v0;
		v1 <<= 0x4;
		v1 -= v0;
		v0 = v1 << 0x6;
		v0 += v1;
		v0 <<= 0x2;
		v0 = Math.floor(v0 * (a0/0x100000000));
		v0 >>>= 0xA;
	}
	v0 &= 0xFFFF;
	return v0;
}

let to_wav = (function() {
/*The MIT License (MIT) Copyright (c) 2015 Jam3

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
	function audioBufferToWav (buffer, opt) {
		opt = opt || {}

		var numChannels = buffer.numberOfChannels
		var sampleRate = buffer.sampleRate
		var format = opt.float32 ? 3 : 1
		var bitDepth = format === 3 ? 32 : 16

		var result
		if (numChannels === 2) {
			result = interleave(buffer.getChannelData(0), buffer.getChannelData(1))
		} else {
			result = buffer.getChannelData(0)
		}

		return encodeWAV(result, format, sampleRate, numChannels, bitDepth)
	}

	function encodeWAV (samples, format, sampleRate, numChannels, bitDepth) {
		var bytesPerSample = bitDepth / 8
		var blockAlign = numChannels * bytesPerSample

		var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample)
		var view = new DataView(buffer)

		/* RIFF identifier */
		writeString(view, 0, 'RIFF')
		/* RIFF chunk length */
		view.setUint32(4, 36 + samples.length * bytesPerSample, true)
		/* RIFF type */
		writeString(view, 8, 'WAVE')
		/* format chunk identifier */
		writeString(view, 12, 'fmt ')
		/* format chunk length */
		view.setUint32(16, 16, true)
		/* sample format (raw) */
		view.setUint16(20, format, true)
		/* channel count */
		view.setUint16(22, numChannels, true)
		/* sample rate */
		view.setUint32(24, sampleRate, true)
		/* byte rate (sample rate * block align) */
		view.setUint32(28, sampleRate * blockAlign, true)
		/* block align (channel count * bytes per sample) */
		view.setUint16(32, blockAlign, true)
		/* bits per sample */
		view.setUint16(34, bitDepth, true)
		/* data chunk identifier */
		writeString(view, 36, 'data')
		/* data chunk length */
		view.setUint32(40, samples.length * bytesPerSample, true)
		if (format === 1) { // Raw PCM
			floatTo16BitPCM(view, 44, samples)
		} else {
			writeFloat32(view, 44, samples)
		}

		return buffer
	}

	function interleave (inputL, inputR) {
		var length = inputL.length + inputR.length
		var result = new Float32Array(length)

		var index = 0
		var inputIndex = 0

		while (index < length) {
			result[index++] = inputL[inputIndex]
			result[index++] = inputR[inputIndex]
			inputIndex++
		}
		return result
	}

	function writeFloat32 (output, offset, input) {
		for (var i = 0; i < input.length; i++, offset += 4) {
			output.setFloat32(offset, input[i], true)
		}
	}

	function floatTo16BitPCM (output, offset, input) {
		for (var i = 0; i < input.length; i++, offset += 2) {
			var s = Math.max(-1, Math.min(1, input[i]))
			output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true)
		}
	}

	function writeString (view, offset, string) {
		for (var i = 0; i < string.length; i++) {
			view.setUint8(offset + i, string.charCodeAt(i))
		}
	}
	return audioBufferToWav;
})();

// so I imported a short bit of white noise into the game as a music instrument and turned on the reverb and then played it.
// so yeah that's how I got this.

const impulse_response_url = "data:audio/ogg;base64,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OacUY4wx5pxjjDHGGHPOMcYYY4w55xhjjDHGnHPOMcYYY8455xhjjDHnnHOMMcaYAACgAgcAgAAbRTYnGAkqNGQlABAOAAAYw5RzzkEoJZUKIcYgdFBKSq1VCDEGIYRSUmotas45CCGUklJr0XPOQQihlJRai6qFUEopJaXWWnQtdFJKSam1GKOUIoSQUkqttRidEyGEklJqLcbmnIylpNRajDE252QsJaXWYoyxOeeca621FmOtzTnnXGspthhrbc45p3tsMdZYa3POOZ9bi63GWgsAMHlwAIBKsHGGlaSzwtHgQkNWAgC5AQCMUowx5pxzzjnnnHPOSaUYc845CCGEEEIIIZRKMeaccxBCCCGEEEIoGXPOOQchhBBCCCGEUErpnHMQQgghhBBCCKGU0jnnIIQQQgghhBBCKaVzzkEIIYQQQgghhFJKCCGEEEIIIYQQQgillFJCCCGEEEIIIYQQSimlhBBCCCGEEEIIIZRSSgkhhBBCCCGEEEIopZQSQgghhBBCCCWEUEoppZQQQgihhBBCCKGUUkopIYRSSikhhBBCKaWUUkIooYQQQgghlFJKKaWUEkIpIYQQQgillFJKKaWUUkIIIYQQSimllFJKKaWEUEIIIZRSSimllFJCKCWEEkIopZRSSimlhFBCCCGEUEoppZRSSgkhhBJCCKEAAKADBwCAACMqLcROM648AkcUMkxAhYasBADSAgAAQ6y11lprrbXWWmsNUtZaa6211lprrbVGKWuttdZaa6211lprqbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaSymllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSAdgFGw6A0RNGElJnGVYaceMJGCKQQkNWAgBpAQCAMYwx5hh0EEpJKaUKIecghE5CKq3FFmOEkHMQQiglpdZiizF4DkIIIZTSUmwxxlg8ByGEEFJqLcYYYwyyhVBKKSm11mKMtRbZQiillJRaizHWWoMxppSSUmqt1VhjrMUYE0pIqbXW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";
</script>
<style>
#filelist {
	background-color: #ccc;
	position:absolute;
	left:0px;
	top:0px;
	bottom:0px;
	width:290px;
	overflow:auto;
}
.file-item-selected {
	background-color: #aaa;
}
.info-overlay {
	position: absolute;
	pointer-events: none;
	color: white;
	background-color: rgba(0,0,0,0.2);
	top: 0px;
	left: 0px;
}

#content {
	position: absolute;
	left: 290px;
	top: 0px;
	bottom:0px;
	right: 0px;
	overflow: auto;
}
#loadmenu {
	text-align:center;
	position: relative;
}
canvas {
  image-rendering: optimizeSpeed;
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: -o-crisp-edges;
  image-rendering: pixelated;
  -ms-interpolation-mode: nearest-neighbor;
}

#progress-list {
	position: fixed;
	right: 0px;
	top: 0px;
	display: inline-block;
	margin: 0px;
	padding: 0px;
}
#progress-list > div {
	margin: 0px;
	background-color: rgba(0, 0, 0, 0.5);
	color: white;
	border-bottom: 1px solid white;
	padding: 10px;

}
.progressbar {
	width: 400px;
	height: 20px;
	margin: 0px;
	border: 1px solid #ccffcc;
	background-color: #ccffcc44;
	position: relative;
}
.progressbar .fill {
	position: absolute;
	left: 0px;
	top: 0px;
	height: 100%;
	width: 0%;
	background-color: #ccffcc;
}

</style>
</head>
<body>
<div id="filelist">
</div>
<div id="content">
</div>
<div id="loadmenu">
	<div>Please select the GAMEFILE.DAT file off the game disk.</div>
	<div>The file from the demo disk will *not* work.</div>
	<div>You may want to try out the <a href="https://monster860.github.io/ntdf-editor/">new tool</a></div>
	<input type="file" id="fileinput">
	<input type="button" onclick="load_gamefile()" value="Load">
</div>
<div id="progress-list">
</div>
</body>
</html>
